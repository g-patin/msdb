{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome !","text":"<p>Welcome on the documentation website of the * material science database (msdb) python package. You will find on this website information and tutorials on how to install and use the msdb* package.</p>"},{"location":"#new-users","title":"New users","text":"<p>If you are a new user, look at the Get started section. It provides all the basic information you need to know about the package.</p>"},{"location":"#contributions","title":"Contributions","text":"<p>We are welcoming any contributions, comments (positive and negative), ideas, etc. This is important to improve the quality of the package and its documentation. If you have encountered a bug or spotted an error, please don't hesitate to contact us by email (see below).</p>"},{"location":"#what-is-this-package-about","title":"What is this package about ?","text":"<p>This package has been designed for users that perform scientific analyses on materials. It aims to provide a generic working environment that can be used to store information about the objects, the materials, the analytical methods, the users, etc. The idea is to have a central location - a folder on your computer - where there will several txt files in which you will be able to store information that can be access and use when needed.   </p>"},{"location":"#what-does-this-package-provide","title":"What does this package provide ?","text":"<p>The package provides two main resources: - database files: create txt and csv files to store relevant information regarding your analytical tasks. - users functions: a set of functions to access (getters) and modify (adders / removers) the content of the database files.</p>"},{"location":"#website-structure","title":"Website structure","text":"<p>The documentation follows the structure described by Daniele Procida, which organizes documentation into four different groups (Tutorials, How-to, Explanations, References).</p>"},{"location":"#cite-package","title":"Cite package","text":"<p>If you are using this package for a publication, please cite the package as follows: </p> <ul> <li>Patin, G., 2025, material science database, Python Package, v.0.0.4, https://github.com/g-patin/msdb</li> </ul>"},{"location":"create-MFT-class-instance/","title":"Create an MFT class instance","text":"<p>The functions provided by the microfading package only work on an instance of a microfading test class (MFT). The creation of an instance of a microfading class is a two-steps procedure and is described below:</p>"},{"location":"create-MFT-class-instance/#1-get-mft-data-files","title":"1. Get MFT data files","text":"<p>Retrieve a list of data files on which the functions provided by the class will be applied. The data files need to be constrained to a specific file structure (For more information about it, see the data files section).</p> <pre><code>import microfading as mf\n</code></pre> <pre><code># Here we are using the test data, but you should use your own data files\nfiles = mf.get_datasets()\n</code></pre> <p> </p>"},{"location":"create-MFT-class-instance/#2-create-mft-class-instance","title":"2. Create MFT class instance","text":"<p>Create the instance using the files as the main parameter.</p> <pre><code>mc = mf.MFT(files=files) # mc stands for microfading class\nmc\n</code></pre> <pre>\nMicrofading data class - Number of files = 5\n</pre>"},{"location":"get-started/","title":"Get started","text":"<p>In this section, we will give you all the essential information to correctly start using the <code>microfading</code> package.</p>"},{"location":"get-started/#1-do-you-have-microfading-data-files","title":"1. Do you have microfading data files?","text":"<p>The whole package is based on microfading data files that you either obtained yourself when performing microfading measurements or obtained from someone else. Each file corresponds to a single microfading measurement. The files consist of excel files with a specific structure organizing the data inside the files. Check the datafiles section for more information about it. </p> <p>If you don't have any microfading files, the package has a function to load microfading files, so that you can use these files to play with the functionalities of the package (see get_datasets section).  </p> <p>If you have files, the following lines of code shows how you can import them in the jupyter notebook: \u00a0</p> <pre><code># I use this package to select files on my local computer\nfrom glob import glob \n</code></pre> <pre><code># I use the command 'cd &lt;path&gt;' to change the current directory and be in the folder where the microfading files are.\n</code></pre> <pre><code>cd /home/username/Documents/MFT\n</code></pre> <pre><code># Using the glob method, I select the files that contain the words 'BW1' and 'MFT' in the filename.\nfiles = sorted(glob('*BW1*MFT*'))\nfiles\n</code></pre> <pre>[PosixPath('/home/username/Documents/MFT/2024-144_MF.BWS002.G01_avg_BW1_model_2024-07-30_MFT2.xlsx'),\nPosixPath('/home/username/Documents/MFT/2024-144_MF.BWS003.G01_avg_BW1_model_2024-08-02_MFT2.xlsx')]\n</pre> <p> </p>"},{"location":"get-started/#2-central-role-of-the-mft-class","title":"2. Central role of the <code>MFT</code> class","text":"<p>Once you have selected microfading files and encapsulated them inside a python list, you will need to create an instance of the <code>MFT</code> class passing the variable for your microfading files as argument (see code below). Most of the functions provided by the package can only be accessed through the <code>MFT</code> class. </p> <pre><code>import microfading as mf\n</code></pre> <p><pre><code>m = mf.MFT(files=files)\n</code></pre> </p>"},{"location":"get-started/#3-three-keywords-function-get-plot-compute","title":"3. Three keywords function: get, plot, compute","text":"<p>Once you have created an instance of the <code>MFT</code> class, you can access the functions. The name of each function starts by a verb: get, plot, or compute. Enter one of the verbs and use the auto-completion tool (<code>Tab</code> button) to display a list of available functions.</p> <p></p> <p>List of all the plotting functions.</p> <p>The functions can be run without passing any arguments, this will output the default values. To adjust the output to your needs, you will need to modify the values of the arguments. For instance, the function <code>get_cielab()</code> returns the \\(\\Delta E_{00}\\) values by default. If you want to retrieve other CIELAB coordinates, you will need to pass in a new value for the argument coordinates (see code below). To know the role of each argument in a function and which values can you pass in, you will need to read the documentation (see below). The latter can either be access in the jupyter notebook or in the References section of this website.</p> <p></p> <p>Play with the argument values of functions </p>"},{"location":"get-started/#4-use-the-databases","title":"4. Use the databases","text":"<p>If you are planning to perform microfading measurements more than once, we advise you to make use of the databases. This will allow you to save metadata about the microfaded object in the excel data file, which can ultimately be used to perform queries. For example, you could ask to retrieve all measurements performed on a given material or on objects created by a specific artist,etc. Unfortunately, such as a possibility has not been implemented yet.</p> <p>To start using the databases, you will first need to create them and fill them with some information. To learn how to create databases, see the Create databases section. To learn how to fill the databases and properly manage them, see the Databases management section. </p>"},{"location":"get-started/#5-use-the-docstrings","title":"5. Use the docstrings","text":"<p>Whenever you will use functions from the <code>microfading</code> package, you will always be able to access the docstrings. These contain valuable information that will help you to adequately use the functions. To open the dosctrings, you have two possibilites:</p> <ol> <li> <p>Write the name of a function (without parentheses) followed by a question mark (see example below).</p> <p></p> <p>Opening a docstring with a question mark.</p> </li> <li> <p>Write the name of a function (with parentheses), place the cursor inside the parentheses and press <code>Ctrl + Caps Lock</code> (see example below).</p> </li> </ol> <p></p> <p>Opening a tooltip docstring window.</p>"},{"location":"installation/","title":"Installation","text":"<p>To install the latest version of the microfading package, open a terminal and enter the following command:</p> <pre><code>pip install microfading\n</code></pre> <p>If you wish to install a specific version of the microfading package, the version number can be added to the pip command as illustrated in the following example:</p> <pre><code>pip install microfading==1.0.10\n</code></pre> <p> </p> <p>To upgrade the package, open a terminal and enter the following command</p> <pre><code>pip install --upgrade microfading\n</code></pre>"},{"location":"package-usage/","title":"Package usage","text":"<p>The package can be used with or without databases.</p> <ul> <li> <p>If you just want to process and visualize a few microfading analyses then you might not need databases.</p> </li> <li> <p>if you are seeking to establish a long-term microfading framework where you want to connect information about the objects with microfading analyses, then you  might be interested in using databases.</p> </li> </ul>"},{"location":"references/","title":"References","text":""},{"location":"references/#commands","title":"Commands","text":""},{"location":"references/#datasets","title":"Datasets","text":"<ul> <li><code>get_datasets [MFT, rawfiles, BWS, stdev]</code> - Retrieve examples of data files.</li> </ul>"},{"location":"references/#databases-management","title":"Databases management","text":"<ul> <li><code>create_DB [folder]</code> - Create two empty databases (projects and objects).</li> <li><code>get_creators</code> - Retrieve a list of names corresponding to the persons that created the microfaded objects.</li> <li><code>get_DB [db]</code> - Retrieve the databases.</li> <li><code>get_institutions</code> - Retrieve a list of institutions owning the microfaded objects.</li> <li><code>get_path_DB</code> - Retrieve the absolute path of the folder where the databases are stored.</li> <li><code>get_persons</code> - Retrieve a list of persons that performed microfading analyses.</li> <li><code>add_new_institution</code> - Add a new institution to the database.</li> <li><code>add_new_person</code> - Add a new person to the list of persons doing microfading analyses.</li> <li><code>add_new_project</code> - Add a new project to the database.</li> <li><code>add_new_object</code> - Add a new object to the database.</li> <li><code>update_DB_project [new, old]</code> - Modify or add a new parameter to the project database.</li> <li><code>update_DB_object [new, old]</code> - Modify or add a new parameter to the object database.</li> </ul>"},{"location":"references/#data-processing","title":"Data processing","text":"<ul> <li><code>process_rawdata [files, device]</code> - Process rawdata files into interim files.</li> </ul>"},{"location":"references/#mft-class","title":"MFT class","text":"<ul> <li><code>data_points</code> - Select colourimetric values for one or multiple light dose values.</li> </ul>"},{"location":"references/#microfading.microfading.MFT","title":"<code>MFT</code>","text":"<p>               Bases: <code>object</code></p> Source code in <code>microfading/microfading.py</code> <pre><code>class MFT(object):\n\n    def __init__(self, files:list, BWS:Optional[bool] = True) -&gt; None:\n        \"\"\"Instantiate a Microfading (MFT) class object in order to manipulate and visualize microfading analysis data.\n\n        Parameters\n        ----------\n        files : list\n            A list of string, where each string corresponds to the absolute path of text or csv file that contains the data and metadata of a single microfading measurement. The content of the file requires a specific structure, for which an example can be found in \"datasets\" folder of the microfading package folder (Use the get_datasets function to retrieve the precise location of such example files). If the file structure is not respected, the script will not be able to properly read the file and access its content.\n\n        BWS : bool, optional\n            When False, it ignores the measurements performed on BWS samples if included. \n\n        \"\"\"\n        self.files = files\n        self.BWS = BWS        \n\n        if self.BWS == False:\n            self.files = [x for x in self.files if 'BW' not in x.name]\n\n\n    def __repr__(self) -&gt; str:\n        return f'Microfading data class - Number of files = {len(self.files)}'\n\n\n    def add_info(self, parameters:Union[list,str], values:Union[list,str]):\n\n        if isinstance(parameters, str):\n            parameters = [parameters]\n\n        if isinstance(values, str):\n            values = [values]\n\n        if len(parameters) == 1 and isinstance(values, list):\n            values = [values]\n\n\n        info_df = self.get_metadata()\n\n        for parameter, value in zip(parameters,values):\n\n\n            # List available parameters if parameter not found\n            if parameter not in info_df.index:\n                raise ValueError(f\"Parameter '{parameter}' not found in the 'info' sheet.\\nAvailable parameters: {list(info_df.index)}\")\n\n            info_df.loc[parameter] = value\n\n\n        for col, file in zip(info_df.columns, self.files):\n\n            df_cl = pd.read_excel(file, sheet_name='CIELAB') \n            df_sp = pd.read_excel(file, sheet_name='spectra') \n            df_info = info_df[col]            \n            df_info.name = 'value'\n\n            # Write all sheets back to the Excel file\n            with pd.ExcelWriter(file) as writer:\n\n                df_info.to_excel(writer, sheet_name='info', index=True)\n                df_cl.to_excel(writer, sheet_name=\"CIELAB\", index=False)\n                df_sp.to_excel(writer, sheet_name=\"spectra\", index=False)\n\n\n    def compute_delta(self, coordinates:Optional[list] = ['dE00'], dose_unit:Optional[list] = 'He', dose_values:Union[int, float, list, tuple] = 'all', derivation:Optional[bool] = False):\n        \"\"\"Retrieve the CIE delta values for a given set of colorimetric coordinates corresponding to the given microfading analyses.\n\n        Parameters\n        ----------\n        coordinates : list, optional\n            List of colorimetric coordinates, by default ['dE00']\n            Any of the following coordinates can be added to the list: 'dE76', 'dE00', 'dR_vis' , 'L*', 'a*', 'b*', 'C*', 'h'.\n\n        dose_unit : str, optional\n            Define the light energy dose, by default 'He'\n            Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        dose_values : Union[int, float, list, tuple], optional\n            Dose values for which the colourimetric values will be returned, by default 'all'\n            When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n            A single dose value (an integer or a float number) can be entered.\n            A list of dose values, as integer or float, can also be entered.\n            A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n        derivation : bool, optional\n            Whether to return the first derivative values of the desired coordinates, by default False\n\n        Returns\n        -------\n        A list of pandas dataframes\n            It returns a a list of pandas dataframes where each column corresponds to a light energy dose or a desired coordinate.\n        \"\"\"          \n\n        # Retrieve the data        \n        cielab_data = self.read_files(sheets=['CIELAB'])\n        cielab_data = [x[0] for x in cielab_data]       \n\n        # Rename the LabCh coordinates to dL*, da*, db*, dC*, dh\n        coordinates = [f'd{x}' if x in ['L*','a*','b*','C*','h'] else x for x in coordinates]\n\n        # Compute the delta values\n        deltas = self.get_cielab(coordinates=coordinates, dose_unit=dose_unit, dose_values=dose_values)\n\n        # Whether to compute the first derivation \n        if derivation:\n            deltas = [pd.DataFrame(np.gradient(x.T.values, x.index, axis=1).T, columns=x.columns, index=x.index) for x in deltas]\n\n        return deltas     \n\n\n    def compute_fitting(self, plot:Optional[bool] = True, return_data:Optional[bool] = False, dose_unit:Optional[str] = 'Hv', coordinate:Optional[str] = 'dE00', equation:Optional[str] = 'power_3p', initial_params:Optional[List[float]] = 'auto', bounds:Optional[list] = (-np.inf, np.inf), x_range:Optional[Tuple[int]] = (0,5.1,0.1), save: Optional[bool] = False, path_fig: Optional[str] = 'cwd') -&gt; Union[None, Tuple[np.ndarray, np.ndarray]]:\n        \"\"\"Fit the values of a given colourimetric coordinates. \n\n        Parameters\n        ----------\n        plot : bool, optional\n            Whether to show the fitted data, by default True\n\n        return_data : bool, optional\n            Whether to return the fitted data, by default False\n\n        dose_unit : string, optional\n            Unit of the light energy dose, by default 'He'\n            Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        coordinate : string, optional\n            Select the desired colourimetric coordinate from the following list: ['L*', 'a*','b*', 'C*', 'h', 'dL*', 'da*','db*', 'dC*', 'dh', 'dE76', 'dE00', 'dR_vis'], by default 'dE00'\n\n        equation : str, optional\n            Mathematical equation used to fit the coordinate values, by default 'c0*(x**c1)'.\n            Any others mathematical can be given. The following equation is often relevant for fitting microfading data: '((x) / (c0 + (c1*x))) + c2'.\n\n        initial_params : Optional[List[float]], optional\n            Initial guesses of the 'c' parameters given in the equation (c0, c1, c2, etc.), by default [0.1, 0.0]\n\n        x_range : Optional[Tuple[int]], optional\n            Values along which the fitted values should be computed (start, end, step), by default (0, 1001, 1)\n\n        save : Optional[bool], optional\n            Whether to save the plot, by default False\n\n        path_fig : Optional[str], optional\n            Absolute path of the figure to be saved, by default 'default'\n\n        Returns\n        -------\n        Union[None, Tuple[np.ndarray, np.ndarray]]\n            _description_\n        \"\"\"\n\n        # Retrieve the range light dose values\n        doses = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't': 't_sec'}  \n        x_model = np.arange(*x_range)\n\n        # Retrieve the data        \n        all_data = []\n\n        for data in self.get_data(data='cl'):\n            if 'mean' in data.columns.get_level_values(1):\n                cl_mean_data = data.xs(key='mean', axis=1, level=1)  # the mean colorimetric data\n                doses_data = data.xs(key='value', axis=1, level=1)   # the light energy data\n\n                all_data.append(pd.concat([doses_data, cl_mean_data], axis=1))\n\n            else:\n                all_data.append(data.xs(key='value', axis=1, level=1))                \n\n        # Added the delta LabCh values to the data dataframes\n        coordinates = ['L*', 'a*', 'b*', 'C*', 'h']\n        data = [d.assign(**{f'd{coord}': d[coord] - d[coord].values[0] for coord in coordinates}) for d in all_data]\n\n        # Select the wanted dose_unit and coordinate\n        selected_data = [x[[doses[dose_unit], coordinate]] for x in data]\n        selected_data = [x.set_index(x.columns[0]) for x in selected_data]\n\n        # Define the fitting equation and bounds\n        config_functions = get_DB_config()['functions']\n        existing_equations = list(config_functions.keys())\n\n        if equation in existing_equations:\n            bounds = eval(config_functions[equation]['bounds'])\n            equation = config_functions[equation]['expression']           \n\n        # Define the function to fit\n        def fit_function(x, *params):\n            param_dict = {f'c{i}': param for i, param in enumerate(params)}\n            param_dict['x'] = x\n            return eval(equation, globals(), param_dict)        \n\n        # Create an empty dataframe for the fitted data\n        fitted_data = pd.DataFrame(index=pd.Series(x_model))\n\n        # Empty list to store the labels\n        fitted_labels = []\n\n        # Emtpy list to store the optimized parameters\n        fitted_parameters = []\n\n        if initial_params == 'auto':\n            initial_params = ['auto']\n\n        initial_params = initial_params * len(self.files)\n\n\n        for d, p in zip(selected_data,initial_params):\n\n            # retrieve the x(light dose) and y(coordinate) values\n            x_data, y_data = d.index, d.iloc[:,0].values\n\n            # estimate the initial parameters\n            if p == 'auto':  \n\n                y_diff = y_data[-1] - y_data[0]\n\n                if equation == \"c0*x\":\n                    if y_diff &lt; 0:\n                        p = [-0.1]\n                    elif y_diff &gt; 0:\n                        p = [0.1]\n                    elif y_diff == 0:\n                        p  = [0]\n\n                elif equation == \"c0*x+c1\":                    \n\n                    if y_diff &lt; 0:\n                        c0 = -0.1\n                    elif y_diff &gt; 0:\n                        c0 = 0.1\n                    elif y_diff == 0:\n                        c0  = 0\n\n                    c1 = y_data[0]\n                    p = [c0,c1]\n\n                elif equation == \"c0*(x**c1)\":                    \n\n                    if y_diff &lt; 0:\n                        c0 = -0.1\n                    elif y_diff &gt; 0:\n                        c0 = 0.1\n                    elif y_diff == 0:\n                        c0  = 0\n\n                    p = [c0,0.1]\n\n                elif equation == \"c0*(x**c1)+c2\":                    \n\n                    if y_diff &lt; 0:\n                        c0 = -0.1\n                    elif y_diff &gt; 0:\n                        c0 = 0.1\n                    elif y_diff == 0:\n                        c0  = 0\n\n                    c2 = y_data[0]\n                    p = [c0,0.1,c2]\n\n\n                elif equation == \"(c0/(1+np.exp(c1*x)))\":                    \n\n                    if y_diff &lt; 0:\n                        c0 = -0.1\n                    elif y_diff &gt; 0:\n                        c0 = 0.1\n                    elif y_diff == 0:\n                        c0  = 0\n\n                    p = [c0,-0.1]\n\n\n                elif equation == \"(c0/(1+np.exp(c1*x)))+c2\":                    \n\n                    if y_diff &lt; 0:\n                        c0 = -0.1\n                    elif y_diff &gt; 0:\n                        c0 = 0.1\n                    elif y_diff == 0:\n                        c0  = 0                    \n\n                    c2 = y_data[0]\n                    p = [c0,-0.1,c2]\n\n\n            # perform the curve fitting, return the optimized parameters (popt) and the covariance matrix (pcov)\n            popt, pcov = curve_fit(fit_function, x_data, y_data, p0=p, bounds=bounds)\n\n            # generate fitted y data\n            fitted_y = fit_function(x_model, *popt)\n\n            # append it to the fitted_data dataframe\n            fitted_data = pd.concat([fitted_data, pd.DataFrame(fitted_y, index=pd.Series(x_model))], axis=1)\n\n            # Calculate R-squared value\n            residuals = y_data - fit_function(x_data, *popt)\n            ss_res, ss_tot = np.sum(residuals**2), np.sum((y_data - np.mean(y_data))**2)        \n            r_squared = np.round(1 - (ss_res / ss_tot), 3)\n\n            # Create a string representation of the equation with optimized parameters\n            optimized_equation = equation\n            for i, param in enumerate(popt):\n                optimized_equation = optimized_equation.replace(f'c{i}', str(np.round(param,2)))\n\n            fitted_labels.append(f'{optimized_equation}, $R^2$ = {r_squared}')\n            fitted_parameters.append(popt)\n\n        fitted_data.columns = [f'{x.split(\".\")[-1]}, $y$ = {y}' for x,y in zip(self.get_meas_ids, fitted_labels)]         \n\n        # Plot the data\n        if plot:            \n\n            labels_H = {\n                'Hv': 'Exposure dose $H_v$ (Mlxh)',\n                'He': 'Radiant Exposure $H_e$ (MJ/m\u00b2)',\n                't' : 'Exposure duration (seconds)'\n            }\n\n            sns.set_theme(context='paper', font='serif', palette='colorblind')\n            fig, ax = plt.subplots(1,1, figsize=(10,6))\n            fs = 24\n\n\n            pd.concat(selected_data, axis=1).plot(ax=ax, color='0.7', ls='-', lw=5, legend=False)\n            fitted_data.plot(ax=ax, lw=2, ls='--')\n\n            ax.set_xlabel(labels_H[dose_unit], fontsize=fs)\n            ax.set_ylabel(labels_eq[coordinate],fontsize=fs)\n\n            ax.set_xlim(0)    \n\n            ax.xaxis.set_tick_params(labelsize=fs)\n            ax.yaxis.set_tick_params(labelsize=fs)   \n\n            plt.tight_layout()    \n\n\n            # Whether to save the figure\n            if save:\n\n                filename = f'MFT_{coordinate}-fitted.png'\n\n                if save:      \n\n                    if path_fig == 'cwd':\n                        path_fig = f'{os.getcwd()}/{filename}' \n\n                    plt.savefig(path_fig, dpi=300, facecolor='white')\n\n            plt.show()\n\n        if return_data:\n            return fitted_parameters, fitted_data, pcov, r_squared   \n\n\n    def compute_JND(self, dose_unit:Optional[str] = 'Hv', JND_dE = 1.5, light_intensity=50, daily_exposure:Optional[int] = 10, yearly_exposure:Optional[int] = 365, fitting = True):\n        \"\"\"Compute the just noticeable difference (JND) corresponding to each input data file.\n\n        Parameters\n        ----------\n        dose_unit : Optional[str], optional\n            Unit of the light dose energy, by default 'Hv'\n            Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        JND_dE : float, optional\n            The dE00 value corresponding to one JND, by default 1.5\n\n        light_intensity : int, optional\n            The illuminance or the irradiance value of the intended light source, by default 50\n\n        daily_exposure : Optional[int], optional\n            Amount of exposure hours per day, by default 10\n\n        yearly_exposure : Optional[int], optional\n            Amount of exposure days per year, by default 365\n\n        fitting : bool, optional\n            Whether to fit the microfading data necessary to compute the JND value, by default True\n\n        Returns\n        -------\n        A list of numerical values as string (uncertainty string with a nominal and standard deviation value)\n            It returns a list of numerical values corresponding to the amount of years necessary to reach one JND. \n        \"\"\"\n\n        H_step = 0.01\n        dE_fitted = self.compute_fitting(dose_unit='Hv', x_range=(0,5.1,H_step), return_data=True, plot=False)[1]\n        dE_rate = np.gradient(dE_fitted.T.values, H_step, axis=1)\n        dE_rate_mean = [np.mean(x[-20:]) for x in dE_rate]\n        dE_rate_std = [np.std(x[-20:]) for x in dE_rate]\n\n        rates = [ufloat(x, y) for x,y in zip(dE_rate_mean, dE_rate_std)]\n\n        times_years = []\n\n        for rate in rates:\n\n            if dose_unit == 'Hv':\n\n                JND_dose = (JND_dE / rate) * 1e6                     # in lxh\n                time_hours = JND_dose / light_intensity\n                time_years = time_hours / (daily_exposure * yearly_exposure)            \n\n            if dose_unit == 'He':\n                JND_dose = (JND_dE / rate) * 1e6                     # in J/m\u00b2\n                time_sec = JND_dose / light_intensity\n                time_hours = time_sec / 3600\n                time_years = time_hours / (daily_exposure * yearly_exposure)\n\n            times_years.append(time_years)\n\n        return times_years\n\n\n    def compute_mean(self, return_data:Optional[bool] = True, criterion:Optional[str] = 'spot_group', dose_unit:Optional[str] = 'He', save:Optional[bool] = False, folder:Optional[str] = '.', filename:Optional[str] = 'default'):\n        \"\"\"Compute mean and standard deviation values of several microfading measurements.\n\n        Parameters\n        ----------\n        return_data : Optional[bool], optional\n            Whether to return the data, by default True        \n\n        criterion : Optional[str], optional\n            _description_, by default 'group'            \n\n        save : Optional[bool], optional\n            Whether to save the average data as an excel file, by default False\n\n        folder : Optional[str], optional\n            Folder where the excel file will be saved, by default 'default'\n            When 'default', the file will be saved in the same folder as the input files\n            When '.', the file will be saved in the current working directory\n            One can also enter a valid path as a string.\n\n        filename : Optional[str], optional\n            Filename of the excel file containing the average values, by default 'default'\n            When 'default', it will use the filename of the first input file\n            One can also enter a filename, but without a filename extension.\n\n        Returns\n        -------\n        tuple, excel file\n            It returns a tuple composed of three elements (info, CIELAB data, spectral data). When 'save' is set to True, an excel is created to stored the tuple inside three distinct excel sheet (info, CIELAB, spectra).\n\n        Raises\n        ------\n        RuntimeError\n            _description_\n        \"\"\"\n\n        if len(self.files) &lt; 2:        \n            raise RuntimeError('Not enough files. At least two measurement files are required to compute the average values.')\n\n\n        def mean_std_with_nan(arrays):\n            '''Compute the mean of several numpy arrays of different shapes.'''\n\n            # Find the maximum shape\n            max_shape = np.max([arr.shape for arr in arrays], axis=0)\n\n            # Create arrays with NaN values\n            nan_arrays = [np.full(max_shape, np.nan) for _ in range(len(arrays))]\n\n            # Fill NaN arrays with actual values\n            for i, arr in enumerate(arrays):\n                nan_arrays[i][:arr.shape[0], :arr.shape[1]] = arr\n\n            # Calculate mean\n            mean_array = np.nanmean(np.stack(nan_arrays), axis=0)\n\n            # Calculate std\n            std_array = np.nanstd(np.stack(nan_arrays), axis=0)\n\n            return mean_array, std_array\n\n\n        def to_float(x):\n            try:\n                return float(x)\n            except ValueError:\n                return x\n\n\n        ###### SPECTRAL DATA #######\n\n        data_sp = self.get_data(data='sp')\n\n        # Get the energy dose step\n        #H_values = [x.columns.astype(float) for x in data_sp]       \n        H_values = [x.values.flatten() for x in self.get_doses(dose_unit=dose_unit)]\n        step_H = sorted(set([x[2] - x[1] for x in H_values]))[0]\n        highest_He = np.max([x[-1] for x in H_values])\n\n        # Average the spectral data\n        sp = mean_std_with_nan(data_sp)\n        sp_mean = sp[0]\n        sp_std = sp[1] \n\n\n        # Wanted energy dose values          \n        wanted_H = np.round(np.arange(0,highest_He+step_H,step_H),2)  \n\n        if len(wanted_H) != sp_mean.shape[1]:            \n            wanted_H = np.linspace(0,highest_He,sp_mean.shape[1])\n\n        # Retrieve the wavelength range\n        wl = self.get_wavelength.iloc[:,0]\n\n\n        # Create a multi-index pandas DataFrame\n        doses_dict = {'He': 'He_MJ/m2', 'Hv': 'Hv_Mlxh', 't': 't_sec'}\n        H_tuples = [(dose, measurement) for dose in wanted_H for measurement in ['mean', 'std']]\n        multiindex_cols = pd.MultiIndex.from_tuples(H_tuples, names=[doses_dict[dose_unit], 'Measurement'])\n\n        data_df_sp = np.empty((len(wl), len(wanted_H) * 2))       \n        data_df_sp[:, 0::2] = sp_mean\n        data_df_sp[:, 1::2] = sp_std\n        df_sp_final = pd.DataFrame(data_df_sp,columns=multiindex_cols, index=wl)\n        df_sp_final.index.name = 'wavelength_nm'\n\n\n\n        ###### COLORIMETRIC DATA #######\n\n        data_cl = self.get_data(data='cl')\n        columns_cl = data_cl[0].columns.get_level_values(0)\n\n        # Average the colorimetric data    \n        cl = mean_std_with_nan(data_cl)\n        cl_mean = cl[0]\n        cl_std = cl[1]\n\n        # Create a multi-index pandas DataFrame\n        cl_tuples = [(x, measurement) for x in data_cl[0].columns.get_level_values(0) for measurement in ['mean', 'std']]\n        multiindex_cols = pd.MultiIndex.from_tuples(cl_tuples, names=['coordinates', 'Measurement'])\n\n        data_df_cl = np.empty((cl_mean.shape[0], cl_mean.shape[1] * 2))       \n        data_df_cl[:, 0::2] = cl_mean\n        data_df_cl[:, 1::2] = cl_std\n        df_cl_final = pd.DataFrame(data_df_cl,columns=multiindex_cols, )\n\n        df_cl_final.drop([('He_MJ/m2','std'), ('Hv_Mlxh','std'), ('t_sec','std')], axis=1, inplace=True)\n\n        mapper = {('He_MJ/m2', 'mean'): ('He_MJ/m2', 'value'), ('Hv_Mlxh', 'mean'): ('Hv_Mlxh', 'value'), ('t_sec', 'mean'): ('t_sec', 'value')}\n        df_cl_final.columns = pd.MultiIndex.from_tuples([mapper.get(x, x) for x in df_cl_final.columns])\n\n\n        cl_cols = df_cl_final.columns\n        cl_cols_level1 = [x[0] for x in cl_cols]\n        cl_cols_level2 = [x[1] for x in cl_cols]\n        df_cl_final.columns = np.arange(0,df_cl_final.shape[1])\n\n        df_cl_final = pd.concat([pd.DataFrame(data=np.array([cl_cols_level2])), df_cl_final])\n        df_cl_final.columns = cl_cols_level1\n        df_cl_final = df_cl_final.set_index(df_cl_final.columns[0])\n\n\n        ###### INFO #######\n\n        data_info = self.get_metadata().fillna('none')\n\n        # Select the first column as a template\n        df_info = data_info.iloc[:,0]\n\n\n        # Rename title file\n        df_info.rename({'[SINGLE MICROFADING ANALYSIS]': '[MEAN MICROFADING ANALYSES]'}, inplace=True)\n\n        # Date time\n        most_recent_dt = max(data_info.loc['date_time'])\n        df_info.loc['date_time'] = most_recent_dt\n\n        # Project data info\n        df_info.loc['project_id'] = '_'.join(sorted(set(data_info.loc['project_id'].values)))\n        df_info.loc['project_leader'] = '_'.join(sorted(set(data_info.loc['project_leader'].values)))\n        df_info.loc['co-researchers'] = '_'.join(sorted(set(data_info.loc['co-researchers'].values)))\n        df_info.loc['start_date'] = '_'.join(sorted(set(data_info.loc['start_date'].values)))\n        df_info.loc['end_date'] = '_'.join(sorted(set(data_info.loc['end_date'].values)))\n        df_info.loc['keywords'] = '_'.join(sorted(set(data_info.loc['keywords'].values)))\n\n        # Object data info\n        if len(set([x.split('_')[0] for x in data_info.loc['institution'].values])) &gt; 1:\n            df_info.loc['institution'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['institution'].values])))\n\n        df_info.loc['object_id'] = '_'.join(sorted(set(data_info.loc['object_id'].values)))\n        df_info.loc['object_category'] = '_'.join(sorted(set(data_info.loc['object_category'].values)))\n        df_info.loc['object_type'] = '_'.join(sorted(set(data_info.loc['object_type'].values)))\n        df_info.loc['object_technique'] = '_'.join(sorted(set(data_info.loc['object_technique'].values)))\n        df_info.loc['object_title'] = '_'.join(sorted(set(data_info.loc['object_title'].values)))\n        df_info.loc['object_name'] = '_'.join(sorted(set(data_info.loc['object_name'].values)))\n        df_info.loc['object_creator'] = '_'.join(sorted(set(data_info.loc['object_creator'].values)))\n        df_info.loc['object_date'] = '_'.join(sorted(set(data_info.loc['object_date'].values)))\n        df_info.loc['object_material'] = '_'.join(sorted(set(data_info.loc['object_material'].values)))\n        df_info.loc['color'] = '_'.join(sorted(set(data_info.loc['color'].values)))\n        df_info.loc['colorants'] = '_'.join(sorted(set(data_info.loc['colorants'].values)))\n        df_info.loc['colorants_name'] = '_'.join(sorted(set(data_info.loc['colorants_name'].values)))\n        df_info.loc['binding'] = '_'.join(sorted(set(data_info.loc['binding'].values)))\n        df_info.loc['ratio'] = '_'.join(sorted(set(data_info.loc['ratio'].values)))\n        df_info.loc['thickness_um'] = '_'.join(sorted(set(data_info.loc['thickness_um'].values)))\n        df_info.loc['status'] = '_'.join(sorted(set(data_info.loc['status'].values)))\n\n        # Device data info\n        if len(set(data_info.loc['device'].values)) &gt; 1:\n            df_info.loc['device'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['device'].values])))\n\n        df_info.loc['measurement_mode'] = '_'.join(sorted(set(data_info.loc['measurement_mode'].values)))\n        df_info.loc['zoom'] = '_'.join(sorted(set(data_info.loc['zoom'].values)))\n        df_info.loc['iris'] =  '_'.join(set([str(x) if f'{x}'.isnumeric() else x for x in list(data_info.loc['iris'].values)]))\n        df_info.loc['geometry'] = '_'.join(sorted(set(data_info.loc['geometry'].values)))\n        df_info.loc['distance_ill_mm'] = '_'.join(set([str(x) if f'{x}'.isnumeric() else x for x in list(data_info.loc['distance_ill_mm'].values)]))\n        df_info.loc['distance_coll_mm'] = '_'.join(set([str(x) if f'{x}'.isnumeric() else x for x in list(data_info.loc['distance_coll_mm'].values)]))\n\n\n        if len(set(data_info.loc['fiber_fading'].values)) &gt; 1:\n            df_info.loc['fiber_fading'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['fiber_fading'].values])))\n\n        if len(set(data_info.loc['fiber_ill'].values)) &gt; 1:\n            df_info.loc['fiber_ill'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['fiber_ill'].values])))\n\n        if len(set(data_info.loc['fiber_coll'].values)) &gt; 1:\n            df_info.loc['fiber_coll'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['fiber_coll'].values])))\n\n        if len(set(data_info.loc['lamp_fading'].values)) &gt; 1:\n            df_info.loc['lamp_fading'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['lamp_fading'].values])))\n\n        if len(set(data_info.loc['lamp_ill'].values)) &gt; 1:\n            df_info.loc['lamp_ill'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['lamp_ill'].values])))\n\n        if len(set(data_info.loc['filter_fading'].values)) &gt; 1:\n            df_info.loc['filter_fading'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['filter_fading'].values])))\n\n        if len(set(data_info.loc['filter_ill'].values)) &gt; 1:\n            df_info.loc['filter_ill'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['filter_ill'].values])))\n\n        if len(set(data_info.loc['white_standard'].values)) &gt; 1:\n            df_info.loc['white_standard'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['white_standard'].values])))\n\n\n        # Analysis data info\n\n        criterion_value = df_info.loc[criterion]\n        object_id = df_info.loc['object_id']\n        if criterion == 'group':            \n            df_info.loc['meas_id'] = f'MF.{object_id}.{criterion_value}'\n        elif criterion == 'object' or criterion == 'project':\n             df_info.loc['meas_id'] = f'MF.{criterion_value}'\n        else:\n            print('Choose one of the following options for the criterion parameter: [\"group\", \"object\", \"project\"]')\n\n        meas_nbs = '-'.join([x.split('.')[-1] for x in self.get_meas_ids])\n        df_info.loc['spot_group'] = f'{\"-\".join(sorted(set(data_info.loc[\"spot_group\"].values)))}_{meas_nbs}'    \n        df_info.loc['spot_description'] = '_'.join(sorted(set(data_info.loc['spot_description'].values)))\n        df_info.loc['background'] = '_'.join(sorted(set(data_info.loc['background'].values)))  \n\n        if len(set(data_info.loc['specular_component'].values)) &gt; 1:\n            df_info.loc['specular_component'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['specular_component'].values]))) \n\n\n        df_info.loc['integration_time_sample_ms'] = np.round(np.mean(data_info.loc['integration_time_sample_ms'].astype(float).values),1)\n        df_info.loc['integration_time_whitestandard_ms'] = np.round(np.mean(data_info.loc['integration_time_whitestandard_ms'].astype(float).values),1)\n        df_info.loc['average'] = '_'.join([str(x) for x in sorted(set(data_info.loc['average'].astype(str).values))]) \n        df_info.loc['duration_min'] = np.round(np.mean(data_info.loc['duration_min'].values),1)\n        df_info.loc['interval_sec'] = '_'.join([str(x) for x in sorted(set(data_info.loc['interval_sec'].values))])\n        df_info.loc['measurements_N'] = '_'.join([str(x) for x in sorted(set(data_info.loc['measurements_N'].astype(str).values))])\n        df_info.loc['illuminant'] = '_'.join(sorted(set(data_info.loc['illuminant'].values)))\n        df_info.loc['observer'] = '_'.join(sorted(set(data_info.loc['observer'].values)))\n\n\n        # Beam data info\n\n        df_info.loc['beam_photo'] = '_'.join(sorted(set(data_info.loc['beam_photo'].values)))\n        df_info.loc['resolution_micron/pixel'] = '_'.join(set([str(x) if f'{x}'.isnumeric() else x for x in list(data_info.loc['resolution_micron/pixel'].values)]))\n\n        fwhm = data_info.loc['FWHM_micron']\n        fwhm_avg = np.mean([i for i in [to_float(x) for x in fwhm] if isinstance(i, (int, float))])\n        df_info.loc['FWHM_micron'] = fwhm_avg\n\n        power_infos = data_info.loc['radiantFlux_mW'].values\n        power_values = []\n\n        for power_info in power_infos:\n            if \"_\" in str(power_info):\n                power_value = ufloat_fromstr(power_info.split('_')[0])\n                power_values.append(power_value)                            \n\n            else: \n                power_values.append(power_info)               \n\n        power_mean = np.round(np.mean(power_values),3)\n        power_std = np.round(np.std(power_values),3)\n        df_info.loc['radiantFlux_mW'] = f'{ufloat(power_mean,power_std)}'    \n\n\n        irr_values = [str(ufloat(x,0)) if isinstance(x, int) else x for x in data_info.loc['irradiance_Ee_W/m^2'] ] \n        irr_mean = np.int32(np.mean([unumpy.nominal_values(ufloat_fromstr(x)) for x in irr_values]))\n        irr_std = np.int32(np.std([unumpy.nominal_values(ufloat_fromstr(x)) for x in irr_values]))\n        irr_avg = ufloat(irr_mean, irr_std)    \n        df_info.loc['irradiance_Ee_W/m^2'] = irr_avg\n\n        lm = [x for x in data_info.loc['luminuousFlux_lm'].values]\n        lm_avg = np.round(np.mean(lm),3)\n        df_info.loc['luminuousFlux_lm'] = lm_avg\n\n        ill = [x for x in data_info.loc['illuminance_Ev_Mlx']]\n        ill_avg = np.round(np.mean(ill),3)\n        df_info.loc['illuminance_Ev_Mlx'] = ill_avg\n\n\n        # Results data info\n        df_info.loc['radiantExposure_He_MJ/m^2'] = df_cl_final.index.values[-1]\n        df_info.loc['exposureDose_Hv_Mlxh'] = np.round(df_cl_final['Hv_Mlxh'].values[-1],4)\n\n\n        # Rename the column\n        df_info.name = 'value'\n\n\n        ###### SAVE THE MEAN DATAFRAMES #######\n\n        if save:  \n\n            # set the folder\n            if folder == \".\":\n                folder = Path('.')  \n\n            elif folder == 'default':\n                folder = Path(self.files[0]).parent\n\n            else:\n                if Path(folder).exists():\n                    folder = Path(folder)         \n\n            # set the filename\n            if filename == 'default':\n                filename = f'{Path(self.files[0]).stem}_MEAN{Path(self.files[0]).suffix}'\n\n            else:\n                filename = f'{filename}.xlsx'\n\n\n            # create a excel writer object\n            with pd.ExcelWriter(folder / filename) as writer:\n\n                df_info.to_excel(writer, sheet_name='info', index=True)\n                df_cl_final.to_excel(writer, sheet_name=\"CIELAB\", index=True)\n                df_sp_final.to_excel(writer, sheet_name='spectra', index=True)\n\n            print(f'{folder / filename} successfully created.')\n\n\n        ###### RETURN THE MEAN DATAFRAMES #######\n\n        if return_data:\n            return df_info, df_cl_final, df_sp_final\n\n\n    def compute_sp_derivate(self):\n        \"\"\"Compute the first derivative values of reflectance spectra.\n\n        Returns\n        -------\n        a list of pandas dataframes\n            It returns the first derivative values of the reflectance spectra inside dataframes where each column corresponds to a single spectra.\n        \"\"\"\n\n        sp = self.get_data(data='sp')                    \n\n        sp_derivation = [pd.DataFrame(pd.concat([pd.DataFrame(np.gradient(x.iloc[:,:], axis=0), index=pd.Series(x.index), columns=x.columns)], axis=1),index=pd.Series(x.index), columns=x.columns) for x in sp]\n\n        return sp_derivation\n\n\n    def get_spectra(self, wl_range:Union[int, float, list, tuple] = 'all', dose_unit:Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', spectral_mode:Optional[str] = 'rfl', smoothing:Optional[list] = [1,0]):\n        \"\"\"Retrieve the reflectance spectra related to the input files.\n\n        Parameters\n        ----------\n        wl_range : Union[int, float, list, tuple], optional\n            Select the wavelengths for which the spectral values should be given with a two-values tuple corresponding to the lowest and highest wavelength values, by default 'all'\n            When 'all', it will returned all the available wavelengths contained in the datasets.\n            A single wavelength value (an integer or a float number) can be entered.\n            A list of specific wavelength values as integer or float can also be entered.\n            A tuple of two or three values (min, max, step) will take the range values between these two first values. By default the step is equal to 1.\n\n        dose_unit : string, optional\n            Unit of the light energy dose, by default 'He'\n            Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec).\n\n        dose_values : Union[int, float, list, tuple], optional\n            Dose values for which the reflectance values will be returned, by default 'all'\n            When 'all', it returns the reflectance values for all the dose values available in the given input data files.\n            A single dose value (an integer or a float number) can be entered.\n            A list of dose values, as integer or float, can also be entered.\n            A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n        spectral_mode : string, optional\n            When 'rfl', it returns the reflectance spectra\n            When 'abs', it returns the absorption spectra using the following equation: A = -log(R)\n\n        smoothing : list of two integers, optional\n            Whether to smooth the reflectance data using the Savitzky-Golay filter from the Scipy package, by default [1,0]\n            The first integer corresponds to the window length and should be less than or equal to the size of a reflectance spectrum. The second integer corresponds to the polyorder parameter which is used to fit the samples. The polyorder value must be less than the value of the window length.\n\n\n        Returns\n        -------\n        A list of pandas dataframes\n            It returns a list of pandas dataframes where the columns correspond to the dose values and the rows correspond to the wavelengths.\n        \"\"\"\n\n        data_sp = []\n        files = self.read_files(sheets=['spectra', 'CIELAB'])   \n\n        dose_units = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't':'t_sec'}     \n\n        for file in files:\n            df_sp = file[0]            \n\n            # whether to compute the absorption spectra\n            if spectral_mode == 'abs':\n                df_sp = np.log(df_sp) * (-1)\n\n\n            # Set the dose unit\n            if dose_unit == 'Hv':\n                Hv = file[1]['Hv_Mlxh','value'].values\n                df_sp.columns = df_sp.columns.set_levels(Hv, level=0)                \n                #df_sp.index.name = 'wl-nm_Hv-Mlxh'\n\n            elif dose_unit =='t':\n                t = file[1]['t_sec','value'].values\n                df_sp.columns = df_sp.columns.set_levels(t, level=0)\n                #df_sp.index.name = 'wl-nm_t-sec'\n\n\n            # Set the wavelengths\n            if isinstance(wl_range, tuple):\n                if len(wl_range) == 2:\n                    wl_range = (wl_range[0],wl_range[1],1)\n\n                wavelengths = np.arange(wl_range[0], wl_range[1], wl_range[2])                               \n\n            elif isinstance(wl_range, list):\n                wavelengths = wl_range                               \n\n            elif isinstance(wl_range, int):\n                wl_range = [wl_range]\n                wavelengths = wl_range  \n\n            else:\n                wavelengths = df_sp.index          \n\n            df_sp = df_sp.loc[wavelengths]\n\n\n            # Smooth the data\n            doses = df_sp.columns\n            df_sp = pd.DataFrame(savgol_filter(df_sp.T.values, window_length=smoothing[0], polyorder=smoothing[1]).T, columns=doses, index=wavelengths)\n\n            # Set the dose values \n            if isinstance(dose_values, tuple):\n                if len(dose_values) == 2:\n                    dose_values = (dose_values[0],dose_values[1],1)\n\n                wanted_doses = np.arange(dose_values[0], dose_values[1], dose_values[2])\n\n            elif isinstance(dose_values, int) or isinstance(dose_values, float):            \n                wanted_doses = [dose_values]\n\n            elif isinstance(dose_values, list):\n                wanted_doses = dose_values\n\n            else:\n                wanted_doses = sorted(set(df_sp.columns.get_level_values(0)))\n\n\n            def multiindex_2Dinterpolation(df, dose_unit, wanted_x, wanted_y, level_name='value'):\n                interpolator = RegularGridInterpolator((df.index, df.columns.get_level_values(0)), df.values, method='linear')\n\n                # Create a meshgrid of the new points\n                new_wv_grid, new_ev_grid = np.meshgrid(wanted_y, wanted_x, indexing='ij')\n\n                # Flatten the grid arrays and combine them into coordinate pairs\n                new_points = np.array([new_wv_grid.ravel(), new_ev_grid.ravel()]).T\n\n                # Interpolate the data at the new points\n                interpolated_values = interpolator(new_points)\n\n                # Reshape the interpolated values to match the new grid shape\n                interpolated_values = interpolated_values.reshape(len(wanted_y), len(wanted_x))\n\n                # Create a new DataFrame with the interpolated data\n                new_columns = pd.MultiIndex.from_product([wanted_x, [level_name]], names=[dose_units[dose_unit], 'value'])\n                interpolated_df = pd.DataFrame(interpolated_values, index=wanted_y, columns=new_columns)\n\n                interpolated_df.index.name = 'wavelength_nm'\n\n                return interpolated_df\n\n            if sorted(set(df_sp.columns.get_level_values(1))) == ['mean', 'std']:\n                df_sp_n = df_sp.xs(key='mean', axis=1, level=1)\n                df_sp_s = df_sp.xs(key='std', axis=1, level=1)\n\n                interpolated_df_sp_n = multiindex_2Dinterpolation(df_sp_n, dose_unit, wanted_doses, df_sp.index, 'mean')   #.T[::2].T\n                interpolated_df_sp_s = multiindex_2Dinterpolation(df_sp_s, dose_unit, wanted_doses, df_sp.index, 'std')    #.T[::2].T\n                interpolated_df_sp = pd.concat([interpolated_df_sp_n,interpolated_df_sp_s], axis=1).sort_index(axis=1)                \n\n\n            else:\n                interpolated_df_sp = multiindex_2Dinterpolation(df_sp, dose_unit, wanted_doses, df_sp.index)\n\n            # append the spectral data\n            data_sp.append(interpolated_df_sp) \n\n        return data_sp\n\n\n    def get_cielab(self, coordinates:Optional[list] = ['dE00'], dose_unit:Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', index:Optional[bool] = True):\n        \"\"\"Retrieve the colourimetric values for one or multiple light dose values.\n\n        Parameters\n        ----------\n        coordinates : Optional[list], optional\n            Select the desired colorimetric coordinates from the following list: ['L*', 'a*','b*', 'C*', 'h', 'dL*', 'da*','db*', 'dC*', 'dh', 'dE76', 'dE00', 'dR_vis'], by default ['dE00']\n            When 'all', it returns all the colorimetric coordinates.\n\n        dose_unit : Optional[str], optional\n            Unit of the light dose energy, by default ['He']\n            Any of the following units can be added to the list: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        dose_values : Union[int, float, list, tuple], optional\n            Dose values for which the colourimetric values will be returned, by default 'all'\n            When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n            A single dose value (an integer or a float number) can be entered.\n            A list of dose values, as integer or float, can also be entered.\n            A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n        index : Optional[bool], optional\n            Whether to set the index of the returned dataframes, by default False\n\n        Returns\n        -------\n        A list of pandas dataframes\n            It returns the values of the wanted colour coordinates inside dataframes where each coordinate corresponds to a column.\n        \"\"\"\n\n        # Create a dictionary to store the light dose units\n        dose_units = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't': 't_sec'}\n\n\n        # Retrieve the range light dose values\n        if isinstance(dose_values, (float, int)):\n            dose_values = [dose_values]\n\n        elif isinstance(dose_values, tuple):\n            dose_values = np.arange(dose_values[0], dose_values[1], dose_values[2])\n\n        elif isinstance(dose_values, list):\n            dose_values = dose_values        \n\n\n        # Retrieve the data        \n        cielab_data = self.read_files(sheets=['CIELAB'])\n        cielab_data = [x[0] for x in cielab_data]\n\n        # Create an empty list with all the colorimetric data\n        all_data = []\n\n        # Compute the delta LabCh values and add the data into the list all_data  \n        for data in cielab_data:\n\n            # for data with std values\n            if sorted(set(data.columns.get_level_values(1))) == ['mean', 'std']:\n                data_dLabCh = delta_coord = [unumpy.uarray(d[coord, 'mean'], d[coord, 'std']) - unumpy.uarray(d[coord, 'mean'], d[coord, 'std'])[0] for coord in ['L*', 'a*', 'b*', 'C*', 'h'] for d in [data]]\n\n                delta_means = [unumpy.nominal_values(x) for x in delta_coord]\n                delta_stds = [unumpy.std_devs(x) for x in delta_coord]\n\n                delta_coord_mean = [(f'd{coord}', 'mean') for coord in ['L*', 'a*', 'b*', 'C*', 'h']]\n                delta_coord_std = [(f'd{coord}', 'std') for coord in ['L*', 'a*', 'b*', 'C*', 'h']]\n\n                for coord_mean,delta_mean,coord_std,delta_std in zip(delta_coord_mean,delta_means, delta_coord_std,delta_stds):                    \n                    data[coord_mean] = delta_mean\n                    data[coord_std] = delta_std\n\n                    all_data.append(data)          \n\n            # for data without std values\n            else:\n                data_LabCh = data[['L*','a*','b*','C*','h']]\n                data_dLabCh = data_LabCh - data_LabCh.iloc[0,:]\n                data_dLabCh = data_dLabCh.rename(columns={'L*': 'dL*', 'a*': 'da*' ,'b*': 'db*','C*': 'dC*','h': 'dh'}, level=0)\n                all_data.append(pd.concat([data,data_dLabCh], axis=1))\n\n\n        # Select the wanted dose_unit and coordinate\n        if coordinates == 'all':\n            wanted_data = all_data\n            wanted_data = [x.set_index((dose_units[dose_unit],'value')) for x in wanted_data]\n        else:       \n            wanted_data = [x[[dose_units[dose_unit]] + coordinates] for x in all_data]       \n            wanted_data = [x.set_index(x.columns[0]) for x in wanted_data]        \n\n        if isinstance(dose_values, str):\n            if dose_values == 'all':\n                interpolated_data = [x.reset_index() for x in wanted_data]\n\n        else:\n\n            # Interpolation function, assuming linear interpolation\n            interp_functions = lambda x, y: interp1d(x, y, kind='linear', bounds_error=False)\n\n\n            # Double comprehension list to interpolate each dataframe in wanted_data\n            interpolated_data = [\n                pd.DataFrame({\n                    col: interp_functions(df.index, df[col])(dose_values)\n                    for col in df.columns\n                }, index=dose_values)\n                .rename_axis(dose_units[dose_unit])\n                .reset_index()\n                for df in wanted_data\n            ]\n\n\n        # Whether to set the index\n        if index:\n            interpolated_data = [x.set_index(x.columns[0]) for x in interpolated_data]\n\n        return interpolated_data       \n\n\n    def get_illuminant(self, illuminant:Optional[str] = 'D65', observer:Optional[str] = '10'):\n        \"\"\"Set the illuminant values\n\n        Parameters\n        ----------\n        illuminant : Optional[str], optional\n            Select the illuminant, by default 'D65'\n            It can be any value within the following list: ['A', 'B', 'C', 'D50', 'D55', 'D60', 'D65', 'D75', 'E', 'FL1', 'FL2', 'FL3', 'FL4', 'FL5', 'FL6', 'FL7', 'FL8', 'FL9', 'FL10', 'FL11', 'FL12', 'FL3.1', 'FL3.2', 'FL3.3', 'FL3.4', 'FL3.5', 'FL3.6', 'FL3.7', 'FL3.8', 'FL3.9', 'FL3.10', 'FL3.11', 'FL3.12', 'FL3.13', 'FL3.14', 'FL3.15', 'HP1', 'HP2', 'HP3', 'HP4', 'HP5', 'LED-B1', 'LED-B2', 'LED-B3', 'LED-B4', 'LED-B5', 'LED-BH1', 'LED-RGB1', 'LED-V1', 'LED-V2', 'ID65', 'ID50', 'ISO 7589 Photographic Daylight', 'ISO 7589 Sensitometric Daylight', 'ISO 7589 Studio Tungsten', 'ISO 7589 Sensitometric Studio Tungsten', 'ISO 7589 Photoflood', 'ISO 7589 Sensitometric Photoflood', 'ISO 7589 Sensitometric Printer']\n\n        observer : Optional[str], optional\n            Standard observer in degree, by default '10'\n            It can be either '2' or '10'\n\n        Returns\n        -------\n        tuple\n            It returns a tuple with two set of values: the chromaticity coordinates of the illuminants (CCS) and the spectral distribution of the illuminants (SDS).\n        \"\"\"\n\n        observers = {\n            '10': \"cie_10_1964\",\n            '2' : \"cie_2_1931\"\n        }\n\n        CCS = colour.CCS_ILLUMINANTS[observers[observer]][illuminant]\n        SDS = colour.SDS_ILLUMINANTS[illuminant]\n\n        return CCS, SDS\n\n\n    def get_observer(self, observer:Optional[str] = '10'):\n        \"\"\"Set the observer.\n\n        Parameters\n        ----------\n        observer : Optional[str], optional\n            Standard observer in degree, by default '10'\n            It can be either '2' or '10'\n\n        Returns\n        -------        \n            Returns the x_bar,  y_bar, z_bar spectra between 360 and 830 nm.\n        \"\"\"\n\n        observers = {\n            '10': \"CIE 1964 10 Degree Standard Observer\",\n            '2' : \"CIE 1931 2 Degree Standard Observer\"\n        }\n\n        return colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[observers[observer]]   \n\n\n    def get_data(self, data:Union[str, list] = 'all', xarray:Optional[bool] = False):\n        \"\"\"Retrieve the microfading data.\n\n        Parameters\n        ----------\n        data : str|list, optional\n            Possibility to select the type of data, by default 'all'.\n            When 'all', it returns all the data (spectral and colorimetric).\n            When 'sp', it only returns the spectral data.\n            When 'cl', it only returns the colorimetric data.  \n            When 'Lab', it returns the CIE L*a*b* values.\n            A list of strings can be entered to select specific colourimetric data among the following: ['dE76,'dE00','dR_vis', 'L*', 'a*', 'b*', 'C*', 'h'].\n\n        xarray : bool, optional\n            When True, the data are returned as an xarray.Dataset object, else as pandas dataframe object, by default False.\n\n        Returns\n        -------\n        It returns a list of pandas dataframes or xarray.Dataset objects\n        \"\"\"\n\n        all_files = self.read_files(sheets=['spectra','CIELAB'])\n        all_data = []\n        data_sp = [] \n        data_cl = [] \n\n        for data_file in all_files:\n\n            df_sp = data_file[0]\n            df_cl = data_file[1]\n\n            if sorted(set(df_sp.columns.get_level_values(1))) == ['mean', 'std']:\n                sp_n = df_sp.xs('mean', level=1, axis=1).values\n                sp_s = df_sp.xs('std', level=1, axis=1).values\n\n                L_n = df_cl[\"L*\",\"mean\"].values\n                a_n = df_cl[\"a*\",\"mean\"].values\n                b_n = df_cl[\"b*\",\"mean\"].values\n                C_n = df_cl[\"C*\",\"mean\"].values\n                h_n = df_cl[\"h\",\"mean\"].values\n                dE76_n = df_cl[\"dE76\",\"mean\"].values\n                dE00_n = df_cl[\"dE00\",\"mean\"].values\n                dR_vis_n = df_cl[\"dR_vis\",\"mean\"].values\n\n                L_s = df_cl[\"L*\",\"std\"].values\n                a_s = df_cl[\"a*\",\"std\"].values\n                b_s = df_cl[\"b*\",\"std\"].values\n                C_s = df_cl[\"C*\",\"std\"].values\n                h_s = df_cl[\"h\",\"std\"].values\n                dE76_s = df_cl[\"dE76\",\"std\"].values\n                dE00_s = df_cl[\"dE00\",\"std\"].values\n                dR_vis_s = df_cl[\"dR_vis\",\"std\"].values\n\n            else:\n                sp_n = df_sp.xs('value', level=1, axis=1).values\n                sp_s = df_sp.xs('value', level=1, axis=1)\n                sp_s.loc[:,:] = 0\n                sp_s = sp_s.values\n\n                L_n = df_cl[\"L*\",\"value\"].values\n                a_n = df_cl[\"a*\",\"value\"].values\n                b_n = df_cl[\"b*\",\"value\"].values\n                C_n = df_cl[\"C*\",\"value\"].values\n                h_n = df_cl[\"h\",\"value\"].values\n                dE76_n = df_cl[\"dE76\",\"value\"].values\n                dE00_n = df_cl[\"dE00\",\"value\"].values\n                dR_vis_n = df_cl[\"dR_vis\",\"value\"].values\n\n                L_s = np.zeros(len(L_n))\n                a_s = np.zeros(len(a_n))\n                b_s = np.zeros(len(b_n))\n                C_s = np.zeros(len(C_n))\n                h_s = np.zeros(len(h_n))\n                dE76_s = np.zeros(len(dE76_n))\n                dE00_s = np.zeros(len(dE00_n))\n                dR_vis_s = np.zeros(len(dR_vis_n))\n\n            wl = data_file[0].iloc[:,0].values\n            He = data_file[1]['He_MJ/m2','value'].values\n            Hv = data_file[1]['Hv_Mlxh','value'].values\n            t = data_file[1]['t_sec','value'].values\n\n            spectral_data = xr.Dataset(\n                {\n                    'sp': (['wavelength','dose'], sp_n),\n                    'sp_s': (['wavelength','dose'], sp_s)                \n                },\n                coords={\n                    'wavelength': wl,   \n                    'dose': He,\n                    'He': ('dose', He),\n                    'Hv': ('dose', Hv),  # Match radiant energy\n                    't': ('dose', t)  # Match radiant energy\n                }\n            )\n\n            color_data = xr.Dataset(\n                {\n                    'L*': (['dose'], L_n),\n                    'a*': (['dose'], a_n),\n                    'b*': (['dose'], b_n),\n                    'C*': (['dose'], C_n),\n                    'h': (['dose'], h_n),\n                    'dE76': (['dose'], dE76_n),\n                    'dE00': (['dose'], dE00_n),\n                    'dR_vis': (['dose'], dR_vis_n),\n                    'L*_s': (['dose'], L_s),\n                    'a*_s': (['dose'], a_s),\n                    'b*_s': (['dose'], b_s),\n                    'C*_s': (['dose'], C_s),\n                    'h_s': (['dose'], h_s),\n                    'dE76_s': (['dose'], dE76_s),\n                    'dE00_s': (['dose'], dE00_s),\n                    'dR_vis_s': (['dose'], dR_vis_s),\n                },\n                coords={                    \n                    'He': ('dose',He),\n                    'Hv': ('dose',Hv),\n                    't': ('dose',t),\n                }\n            )                \n\n            sp = spectral_data.set_xindex([\"He\",\"Hv\",\"t\"])\n            cl = color_data.set_xindex([\"He\",\"Hv\",\"t\"])\n            combined_data = xr.merge([sp, cl])\n\n        all_data.append(combined_data)            \n\n\n        if data == 'all':\n            if xarray == False:                \n                [data_sp.append(x[0]) for x in all_files]\n                [data_cl.append(x[1]) for x in all_files]\n                return data_sp, data_cl\n\n            else:\n                return all_data\n\n        elif data == 'sp':\n            if xarray == False:                \n                [data_sp.append(x[0]) for x in all_files]                                           \n            else:                \n                data_sp = [x.sp for x in all_data]\n\n\n            return data_sp\n\n        elif data == 'cl':\n            if xarray == False:\n                [data_cl.append(x[1]) for x in all_files]\n            else:\n                data_cl = [x[['L*','a*','b*','C*','h','dE76','dE00','dR_vis']] for x in all_data]\n\n            return data_cl\n\n        elif data == 'Lab':\n            if xarray == False:\n                [data_cl.append(x[1][['L*','a*','b*']]) for x in all_files]\n            else:\n                data_cl = [x[['L*','a*','b*']] for x in all_data]\n\n            return data_cl\n\n        elif isinstance(data,list):\n            if xarray == False:\n                dic_doses = {'He': 'He_MJ/m2', 'Hv':'Hv_Mlxh', 't':'t_sec'}\n                data = [dic_doses[x] if x in dic_doses.keys() else x for x in data]\n                [data_cl.append(x[1][data]) for x in all_files]\n\n            else:\n                data = [elem for elem in data if elem not in ['Hv','He','t']]\n                data_cl = [x[data] for x in all_data]\n\n            return data_cl\n\n        else:\n            print(\"Enter a valid data parameter. It can either be a string ('sp', 'cl', 'Lab', 'all') or a list of strings ['dE00','dE76', 'L*', 'a*', 'b*', 'C*', 'h']\")\n            return None\n\n\n    def get_metadata(self, labels:Optional[list] = 'all'):\n        \"\"\"Retrieve the metadata.\n\n        Parameters\n        ----------\n        labels : Optional[list], optional\n            A list of strings corresponding to the wanted metadata labels, by default 'all'\n            The metadata labels can be found in the 'info' sheet of microfading excel files.\n            When 'all', it returns all the metadata\n\n        Returns\n        -------\n        pandas dataframe\n            It returns the metadata inside a pandas dataframe where each column corresponds to a single file.\n        \"\"\"\n\n        df = self.read_files()\n        metadata = [x[0] for x in df]\n\n        df_metadata = pd.DataFrame(index = metadata[0].set_index('parameter').index)\n\n        for m in metadata:\n            m = m.set_index('parameter')\n            Id = m.loc['meas_id']['value']\n\n            df_metadata[Id] = m['value']\n\n        if labels == 'all':\n            return df_metadata\n\n        else:            \n            return df_metadata.loc[labels]     \n\n\n    def get_Lab(self, illuminant:Optional[str] = 'default', observer:Optional[str] = 'default', dose_unit: Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all'):\n        \"\"\"\n        Retrieve the CIE L*a*b* values.\n\n        Parameters\n        ----------\n        illuminant : (str, optional)  \n            Reference *illuminant* ('D65', or 'D50'). by default 'default'.\n            When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.\n\n        observer : (str|int, optional)\n            Reference *observer* in degree ('10' or '2'). by default 'default'.\n            When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.\n\n        dose_unit : Optional[str], optional\n            Unit of the light dose energy, by default ['He']\n            Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        dose_values : Union[int, float, list, tuple], optional\n            Dose values for which the colourimetric values will be returned, by default 'all'\n            When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n            A single dose value (an integer or a float number) can be entered.\n            A list of dose values, as integer or float, can also be entered.\n            A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n\n        Returns\n        -------\n        pandas dataframe\n            It returns the L*a*b* values inside a dataframe where each column corresponds to a single file.\n        \"\"\"    \n        DB = databases.DB()\n\n\n        # Set the observer value\n        if observer == 'default':\n            if len(DB.get_colorimetry_info()) == 0:\n                observer = '10deg'\n            else:\n                observer = DB.get_colorimetry_info().loc['observer']['value']\n\n        else:\n            observer = f'{str(observer)}deg'\n\n\n        # Set the illuminant value\n        if illuminant == 'default':\n            if len(DB.get_colorimetry_info()) == 0:\n                illuminant = 'D65'\n            else:\n                illuminant = DB.get_colorimetry_info().loc['illuminant']['value']\n\n\n        # Get colorimetric data related to the standard observer\n        observers = {\n            '10deg': 'cie_10_1964',\n            '2deg' : 'cie_2_1931',\n        }\n        cmfs_observers = {\n            '10deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1964 10 Degree Standard Observer\"],\n            '2deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1931 2 Degree Standard Observer\"] \n            }\n\n        ccs_ill = colour.CCS_ILLUMINANTS[observers[observer]][illuminant]\n\n\n        meas_ids = self.get_meas_ids               \n        df_sp = self.get_spectra(dose_unit=dose_unit, dose_values=dose_values)   \n        df_sp_nominal = [\n            df.loc[:, pd.IndexSlice[:, 'mean']] if 'mean' in df.columns.get_level_values(1)\n            else df.loc[:, pd.IndexSlice[:, 'value']]\n            for df in df_sp\n        ]\n\n        df_Lab = []\n\n        for df, meas_id in zip(df_sp_nominal, meas_ids):   \n\n            Lab_values = pd.DataFrame(index=['L*','a*','b*']).T           \n\n            for col in df.columns:\n\n                sp = df[col]\n                wl = df.index\n                sd = colour.SpectralDistribution(sp,wl)                \n\n                XYZ = colour.sd_to_XYZ(sd,cmfs_observers[observer], illuminant=colour.SDS_ILLUMINANTS[illuminant])        \n                Lab = np.round(colour.XYZ_to_Lab(XYZ/100,ccs_ill),3)               \n                Lab_values = pd.concat([Lab_values, pd.DataFrame(Lab, index=['L*','a*','b*']).T], axis=0)\n                Lab_values.index = np.arange(0,Lab_values.shape[0])\n\n            Lab_values.columns = pd.MultiIndex.from_product([[meas_id], Lab_values.columns])  \n            df_Lab.append(Lab_values)\n\n        return pd.concat(df_Lab, axis=1)           \n\n\n    def get_doses(self, dose_unit:Union[str,list] = 'all', max_doses:Optional[bool] = False):\n        \"\"\"Retrieve the light energy doses related to each microfading measurement.\n\n        Parameters\n        ----------\n        dose_unit : Union[str,list], optional\n            Unit of the light dose energy, by default 'all'\n            Any of the following units can be added to the list: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec). When a single unit is requested, it can be given as a string value ('He', 'Hv', or 't').\n\n        max_doses : bool, optional\n            Whether to return the maximum light dose values, by default False.\n\n        Returns\n        -------\n        list of pandas dataframes\n            _description_\n        \"\"\"\n\n        data = self.get_data(data='cl')\n\n        if dose_unit == 'all':\n            doses = [x[['He_MJ/m2', 'Hv_Mlxh', 't_sec']] for x in data]\n\n        else:\n            doses_dic = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't':'t_sec'}\n\n            if isinstance(dose_unit, list):\n                dose_unit = [doses_dic[x] for x in dose_unit] \n                doses = [x[dose_unit] for x in data]\n\n            else:\n                doses = [x[doses_dic[dose_unit]] for x in data]\n\n        if max_doses:\n            doses = [pd.DataFrame(x).iloc[-1,:] for x in doses]\n\n\n        return doses\n\n\n    @property\n    def get_meas_ids(self):\n        \"\"\"Return the measurement id numbers corresponding to the input files.\n        \"\"\"\n        info = self.get_metadata()        \n        return info.loc['meas_id'].values\n\n    @property\n    def get_objects(self):\n        \"\"\"Return the object id numbers corresponding to the input files.\n        \"\"\"\n\n        metadata_parameters = self.get_metadata().index\n\n        if 'object_id' in metadata_parameters:\n\n            df_info = self.get_metadata(labels=['object_id'])\n            objects = sorted(set(df_info.values[0]))\n\n            return objects\n\n        else:\n            print(f'The info tab of the microfading interim file(s) {self.files} does not contain an object_id parameter.')\n            return None\n\n\n    def get_sRGB(self, illuminant='default', observer='default', dose_unit: Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', clip:Optional[bool] = True):\n        \"\"\"Compute the sRGB values. \n\n        Parameters\n        ----------\n        illuminant : (str, optional)  \n            Reference *illuminant* ('D65', or 'D50'). by default 'default'.\n            When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.\n\n        observer : (str|int, optional)\n            Reference *observer* in degree ('10' or '2'). by default 'default'.\n            When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.\n\n        dose_unit : Optional[str], optional\n            Unit of the light dose energy, by default ['He']\n            Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        dose_values : Union[int, float, list, tuple], optional\n            Dose values for which the colourimetric values will be returned, by default 'all'\n            When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n            A single dose value (an integer or a float number) can be entered.\n            A list of dose values, as integer or float, can also be entered.\n            A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n        clip : Optional[bool], optional\n            Whether to constraint the srgb values between 0 and 1.\n\n        Returns\n        -------\n        pandas dataframe\n            It returns the sRGB values inside a dataframe where each column corresponds to a single file.\n        \"\"\"\n\n        DB = databases.DB()\n\n\n        # Set the observer value\n        if observer == 'default':\n            if len(DB.get_colorimetry_info()) == 0:\n                observer = '10deg'\n            else:\n                observer = DB.get_colorimetry_info().loc['observer']['value']\n\n        else:\n            observer = f'{str(observer)}deg'\n\n        # Set the illuminant value\n        if illuminant == 'default':\n            if len(DB.get_colorimetry_info()) == 0:\n                illuminant = 'D65'\n            else:\n                illuminant = DB.get_colorimetry_info().loc['illuminant']['value']\n\n\n        # Get colorimetric data related to the standard observer\n        observers = {\n            '10deg': 'cie_10_1964',\n            '2deg' : 'cie_2_1931',\n        }\n        cmfs_observers = {\n            '10deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1964 10 Degree Standard Observer\"],\n            '2deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1931 2 Degree Standard Observer\"] \n            }\n\n        ccs_ill = colour.CCS_ILLUMINANTS[observers[observer]][illuminant]\n\n        meas_ids = self.get_meas_ids \n\n        df_sp = self.get_spectra(dose_unit=dose_unit, dose_values=dose_values)   \n        df_sp_nominal = [\n            df.loc[:, pd.IndexSlice[:, 'mean']] if 'mean' in df.columns.get_level_values(1)\n            else df.loc[:, pd.IndexSlice[:, 'value']]\n            for df in df_sp\n        ] \n\n        df_srgb = []\n\n\n        for df, meas_id in zip(df_sp_nominal, meas_ids):\n\n            srgb_values = pd.DataFrame(index=['R','G','B']).T            \n\n            for col in df.columns:\n\n                sp = df[col]\n                wl = df.index\n                sd = colour.SpectralDistribution(sp,wl)                \n\n                XYZ = colour.sd_to_XYZ(sd,cmfs_observers[observer], illuminant=colour.SDS_ILLUMINANTS[illuminant]) \n                srgb = np.round(colour.XYZ_to_sRGB(XYZ / 100, illuminant=ccs_ill), 4)                        \n                srgb_values = pd.concat([srgb_values, pd.DataFrame(srgb, index=['R','G','B']).T], axis=0)\n                srgb_values.index = np.arange(0,srgb_values.shape[0])\n\n            srgb_values.columns = pd.MultiIndex.from_product([[meas_id], srgb_values.columns])\n\n            if clip:\n                srgb_values = srgb_values.clip(0,1)\n\n            df_srgb.append(srgb_values)\n\n\n        return pd.concat(df_srgb, axis=1)\n\n\n    @property\n    def get_wavelength(self):\n        \"\"\"Return the wavelength range of the microfading measurements.\n        \"\"\"\n        data = self.get_data(data='sp')\n\n        wavelengths = pd.concat([pd.Series(x.index.values) for x in data], axis=1)\n        wavelengths.columns = self.get_meas_ids\n\n        return wavelengths\n\n\n    def get_XYZ(self, illuminant:Optional[str] = 'default', observer:Union[str,int] = 'default', dose_unit: Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all'):\n        \"\"\"Compute the XYZ values. \n\n        Parameters\n        ----------\n        illuminant : (str, optional)  \n            Reference *illuminant* ('D65', or 'D50'). by default 'default'.\n            When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.\n\n        observer : (str|int, optional)\n            Reference *observer* in degree ('10' or '2'). by default 'default'.\n            When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.\n\n        dose_unit : Optional[str], optional\n            Unit of the light dose energy, by default ['He']\n            Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        dose_values : Union[int, float, list, tuple], optional\n            Dose values for which the colourimetric values will be returned, by default 'all'\n            When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n            A single dose value (an integer or a float number) can be entered.\n            A list of dose values, as integer or float, can also be entered.\n            A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n        Returns\n        -------\n        pandas dataframe\n            It returns the XYZ values inside a dataframe where each column corresponds to a single file.\n        \"\"\"\n\n        DB = databases.DB()\n\n        # Set the observer value\n        if observer == 'default':\n            if len(DB.get_colorimetry_info()) == 0:\n                observer = '10deg'\n            else:\n                observer = DB.get_colorimetry_info().loc['observer']['value']\n\n        else:\n            observer = f'{str(observer)}deg'\n\n\n        # Set the illuminant value\n        if illuminant == 'default':\n            if len(DB.get_colorimetry_info()) == 0:\n                illuminant = 'D65'\n            else:\n                illuminant = DB.get_colorimetry_info().loc['illuminant']['value']               \n\n\n        # Get colorimetric data related to the standard observer\n        cmfs_observers = {\n            '10deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1964 10 Degree Standard Observer\"],\n            '2deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1931 2 Degree Standard Observer\"] \n            } \n\n        meas_ids = self.get_meas_ids                \n        df_sp = self.get_spectra(dose_unit=dose_unit, dose_values=dose_values)   \n        df_sp_nominal = [\n            df.loc[:, pd.IndexSlice[:, 'mean']] if 'mean' in df.columns.get_level_values(1)\n            else df.loc[:, pd.IndexSlice[:, 'value']]\n            for df in df_sp\n        ] \n\n        df_XYZ = []\n\n\n        for df, meas_id in zip(df_sp_nominal, meas_ids):\n\n            XYZ_values = pd.DataFrame(index=['X','Y','Z']).T\n\n            for col in df.columns:\n\n                sp = df[col]\n                wl = df.index\n                sd = colour.SpectralDistribution(sp,wl)                \n\n                XYZ = np.round(colour.sd_to_XYZ(sd,cmfs_observers[observer], illuminant=colour.SDS_ILLUMINANTS[illuminant]),3)\n                XYZ_values = pd.concat([XYZ_values, pd.DataFrame(XYZ, index=['X','Y','Z']).T], axis=0)\n                XYZ_values.index = np.arange(0,XYZ_values.shape[0])\n\n            XYZ_values.columns = pd.MultiIndex.from_product([[meas_id], XYZ_values.columns])\n            df_XYZ.append(XYZ_values)\n\n        return pd.concat(df_XYZ, axis=1)\n\n\n    def get_xy(self, illuminant:Optional[str] = 'default', observer:Union[str, int] = 'default', dose_unit: Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all'):\n        \"\"\"Compute the xy values. \n\n        Parameters\n        ----------\n        illuminant : (str, optional)  \n            Reference *illuminant* ('D65', or 'D50'). by default 'default'.\n            When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.\n\n        observer : (str|int, optional)\n            Reference *observer* in degree ('10' or '2'). by default 'default'.\n            When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.\n\n        dose_unit : Optional[str], optional\n            Unit of the light dose energy, by default ['He']\n            Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        dose_values : Union[int, float, list, tuple], optional\n            Dose values for which the colourimetric values will be returned, by default 'all'\n            When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n            A single dose value (an integer or a float number) can be entered.\n            A list of dose values, as integer or float, can also be entered.\n            A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n        Returns\n        -------\n        pandas dataframe\n            It returns the xy values inside a dataframe where each column corresponds to a single file.\n        \"\"\"\n        DB = databases.DB()\n\n        # Set the observer value\n        if observer == 'default':\n            if len(DB.get_colorimetry_info()) == 0:\n                observer = '10deg'\n            else:\n                observer = DB.get_colorimetry_info().loc['observer']['value']\n\n        else:\n            observer = f'{str(observer)}deg'\n\n\n        # Set the illuminant value\n        if illuminant == 'default':\n            if len(DB.get_colorimetry_info()) == 0:\n                illuminant = 'D65'\n            else:\n                illuminant = DB.get_colorimetry_info().loc['illuminant']['value']               \n\n\n        # Get colorimetric data related to the standard observer\n        cmfs_observers = {\n            '10deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1964 10 Degree Standard Observer\"],\n            '2deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1931 2 Degree Standard Observer\"] \n            }       \n\n\n        meas_ids = self.get_meas_ids                \n        df_sp = self.get_spectra(dose_unit=dose_unit, dose_values=dose_values)   \n        df_sp_nominal = [\n            df.loc[:, pd.IndexSlice[:, 'mean']] if 'mean' in df.columns.get_level_values(1)\n            else df.loc[:, pd.IndexSlice[:, 'value']]\n            for df in df_sp\n        ]     \n        df_xy = []\n\n\n        for df, meas_id in zip(df_sp_nominal, meas_ids):\n\n            xy_values = pd.DataFrame(index=['x','y']).T           \n\n            for col in df.columns:\n\n                sp = df[col]\n                wl = df.index\n                sd = colour.SpectralDistribution(sp,wl)                \n\n                XYZ = colour.sd_to_XYZ(sd,cmfs_observers[observer], illuminant=colour.SDS_ILLUMINANTS[illuminant])\n                xy = np.round(colour.XYZ_to_xy(XYZ),4)\n                xy_values = pd.concat([xy_values, pd.DataFrame(xy, index=['x','y']).T], axis=0)\n                xy_values.index = np.arange(0,xy_values.shape[0])\n\n            xy_values.columns = pd.MultiIndex.from_product([[meas_id], xy_values.columns])\n            df_xy.append(xy_values)\n\n        return pd.concat(df_xy, axis=1)\n\n\n    def plots(self, plots=['CIELAB', 'SP', 'SW', 'dE', 'dLab']):\n        \"\"\"Create plots\n\n        Parameters\n        ----------\n        plots : list, optional\n            _description_, by default ['CIELAB', 'SP', 'SW', 'dE', 'dLab']\n        \"\"\"\n\n        for plot in plots:\n            if plot == 'CIELAB':\n                self.plot_CIELAB(legend_labels='default', legend_fontsize=18)\n\n            elif plot == 'SP':\n                self.plot_sp(spectra='i+f')\n\n            elif plot == 'SW':\n                self.plot_swatches_circle()\n\n            elif plot == 'dE':\n                self.plot_delta()\n\n\n    def plot_bars(self, BWS_lines:Optional[bool] = True, coordinate:Optional[str] = 'dE00', dose_unit:Optional[str] = 'Hv', dose_value:Union[int, float] = 0.5, xlabels:Union[str, list] = 'default', group_objects:Optional[bool] = False, fontsize:Optional[int] = 24, rotate_xlabels:Optional[int] = 0, position_xlabels:Optional[str] = 'center', position_text:Optional[tuple] = (0.03,0.92), colors:Union[str,float,list]=None, save:Optional[bool] = False, path_fig:Optional[str] = 'cwd'):\n        \"\"\"Plot a bar graph of a given colorimetric coordinate for a given light dose value.\n\n        Parameters\n        ----------\n        BWS_lines : Optional[bool], optional\n            Whether to display the blue wool standard values as horizontal lines or as bars, by default True\n\n        coordinate : Optional[str], optional\n            Colorimetric coordinate to be displayed, by default 'dE00'\n            It can be any coordinates among the following list : ['L*','a*','b*','C*','h','dL*','da*','db*','dC*','dh','dE76','dE00','dR_vis'].\n\n        dose_unit : Optional[str], optional\n            Unit of the light energy dose, by default 'Hv'\n            Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        dose_value : Union[int, float], optional\n            Values of the light dose energy, by default 0.5\n\n        xlabels : Union[str, list], optional\n            Values of the labels on the x-axis (one label per bar), by default 'default'\n            When 'default', it takes the measurement id as label.\n\n        fontsize : Optional[int], optional\n            Fontsize of the plot (title, ticks, and labels), by default 24\n\n        rotate_xlabels : Optional[int], optional\n            Whether to rotate the labels on the x-axis, by default 0\n            It can be any integer value between 0 and 360.\n\n        position_xlabels : Optional[str], optional\n            Position of the labels according to each bar ('center', 'left', 'right'), by default 'center'\n\n        position_text : Optional[tuple], optional\n            Position (x,y) of the text with the exposure dose value, by default (0.03,0.92)\n\n        colors : Union[str,float,list], optional\n            Colors of the bar, by default None\n            When 'sample', the color of each bar will be based on srgb values computed from the reflectance values. \n            A single string or float value can also be used to define the color of all the bars (see matplotlib colour values). \n            A list string can also be given, in that case, the number of element in the list should be equal to the number of bars. \n\n        save : bool, optional\n            Whether to save the figure, by default False\n\n        path_fig : str, optional\n            Absolute path required to save the figure, by default 'cwd'\n            When 'cwd', it will save the figure in the current working directory.\n        \"\"\"\n\n        # ['L*','a*','b*','C*','h','dL*','da*','db*','dC*','dh','dE76','dE00','dR_vis']\n\n        # Define the light dose value      \n        doses_dic = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't':'t_sec'}\n        max_doses = [x.values[0] for x in self.get_doses(dose_unit=dose_unit, max_doses=True)]\n\n        if dose_value &gt; np.min(max_doses):\n            print(f'The choosen dose_value ({dose_value} {doses_dic[dose_unit].split(\"_\")[1]}) is bigger than one of the final dose values. Thus the dose_value has been set to {np.min(max_doses)} {doses_dic[dose_unit].split(\"_\")[1]}, which is the lowest final dose value.')\n            dose_value = np.min(max_doses)\n\n\n        # Define the labels on the x-axis\n        if xlabels == 'default':\n            xlabels = self.get_meas_ids\n\n        elif xlabels == 'meas_nb':\n            xlabels = [x.split('.')[-1] for x in self.get_meas_ids]\n\n        elif xlabels in [x for x in self.get_metadata().index if '[' not in x]:\n            xlabels = self.get_metadata(labels=xlabels).values\n\n\n        # Define the colour of the bars\n        if colors == 'sample':\n            colors = [x for x in self.get_sRGB(dose_values=0).values.reshape(len(self.files),-1)]\n\n        elif isinstance(colors, str):\n            colors = [colors] * len(self.files)\n\n        elif isinstance(colors, float):\n            colors = [str(colors)] * len(self.files)\n\n        # Define the objects ID\n        object_ids = self.get_metadata(labels='object_id').values\n\n        # Define the object name\n        object_names = self.get_metadata(labels='object_name').values\n\n        # Gather the data and relevant info inside a dataframe\n        all_data = self.get_cielab(coordinates=[coordinate], dose_unit=dose_unit, dose_values=dose_value)\n        cl_data = [x.iloc[0].values[0] for x in all_data]\n        cl_data_std = [x.iloc[0].values[1] if 'std' in x.columns.get_level_values(1) else 0 for x in all_data]\n\n        plot_data = {\n            'y': cl_data,\n            'y_std': cl_data_std, \n            'xlabels': xlabels,\n            'type': self.get_metadata(labels='object_type').values,\n            'name': object_ids,\n            'objectID':self.get_metadata(['object_id']).values[0],\n            'colors': colors\n        }\n\n        df_data = pd.DataFrame.from_dict(plot_data)        \n\n\n        # Create the plot\n        sns.set_theme(font='serif')\n        fig, ax = plt.subplots(1,1, figsize=(15,8))\n\n        if BWS_lines == True:         \n\n            df_BWS = df_data[df_data['type'] == 'BWS']\n            df_data = df_data[df_data['type'] != 'BWS']\n            object_ids = df_data['objectID'].values\n\n            ls_dic = {'BW1':'-','BW2':'--','BW3':'-.','BW4':':', 'BWS0028':'-','BWS0029':'--','BWS0030':'-.','BWS0031':':'}\n\n            for col in df_BWS.T.columns:\n                data_BWS = df_BWS.T[col]\n\n                ax.axhline(data_BWS['y'], color='blue', ls =ls_dic[data_BWS['name']], label=data_BWS['name'])\n                ax.axhspan(ymin=data_BWS['y']-data_BWS['y_std'], ymax=data_BWS['y']+data_BWS['y_std'], alpha=0.5, color='0.75', ec='none')        \n\n\n        x = np.arange(0,len(df_data))\n\n\n        if colors == None:\n            colors = None\n        else:\n            colors = df_data['colors']\n\n        if not group_objects: \n            ax.bar(x=x, height=df_data['y'], yerr=df_data['y_std'], capsize=5, color=colors, edgecolor='none')\n\n        else:\n\n            i = 1\n            x_ticks = []\n            labels = []\n\n\n            for obj in sorted(set(object_ids)):\n\n                df_obj = df_data.query(f'objectID == \"{obj}\"')\n\n\n                y_values = df_obj['y'].values\n                meas_ids = df_obj['xlabels'].values\n                srgb_values = df_obj['colors'].values\n\n                labels_obj = []\n                N = len(meas_ids)    \n                obj_tick = str(int(np.cumsum(np.arange(1,1+N))[-1] / N)).zfill(2)\n\n                for ID, value, srgb in zip(meas_ids, y_values, srgb_values):\n\n                    ax.bar(i, value, width=1, color=srgb, ec=\"none\")\n\n                    labels_obj.append(str(ID.split('.')[2]))\n                    x_ticks.append(i)\n                    i = i + 1\n\n\n                labels_obj = list(map(lambda x: x.replace((obj_tick), f'{obj_tick}\\n{obj}'), labels_obj))\n\n                labels.append(labels_obj)\n\n                ax.bar(i, 0)\n                labels.append([''])\n                i = i + 1    \n                x_ticks.append(i)\n\n            # Define the labels for x-axis ticks\n            labels = [x for xs in labels for x in xs]\n\n            # Set the x-ticks and xlabels\n            ax.set_xticks(x_ticks)\n            ax.set_xticklabels(labels)\n\n            # Display the legend\n            handles, labels = ax.get_legend_handles_labels()\n            unique = [(h, l) for i, (h, l) in enumerate(zip(handles, labels)) if l not in labels[:i]]\n            ax.legend(*zip(*unique),fontsize=fontsize-4)\n\n\n\n\n        ax.xaxis.set_tick_params(labelsize=fontsize)\n        ax.yaxis.set_tick_params(labelsize=fontsize)\n\n        ax.xaxis.grid() # horizontal lines only\n\n        ax.set_xlabel('Microfading analyses numbers', fontsize=fontsize)\n        ax.set_ylabel(labels_eq[coordinate], fontsize=fontsize)\n\n\n        #ax.set_xticks(x)\n        #ax.set_xticklabels(df_data['xlabels'], rotation=rotate_xlabels, ha=position_xlabels)\n\n        ax.text(x=position_text[0], y=position_text[1], s=f'Light dose = {dose_value} {doses_dic[dose_unit].split(\"_\")[1]}', fontsize=fontsize-6, transform=ax.transAxes, ha='left', va='top')\n\n        if BWS_lines == True:\n            ax.legend(fontsize=fontsize-4)\n\n        plt.tight_layout()\n\n        if save == True:\n            if path_fig == 'cwd':\n                path_fig = f'{os.getcwd()}/{coordinate}-bar.png'                    \n\n            fig.savefig(path_fig,dpi=300, facecolor='white') \n\n        plt.show()     \n\n\n    def plot_bwse(self, frequency:Optional[bool] = False, bins:Optional[list] = [1,2,3,4,5], colors:Union[str,float,list]=None, figsize:Optional[tuple] = (10,10), rotate_xlabels:Optional[int] = 0, position_xlabels:Optional[str] = 'center', fontsize:Optional[int] = 24, title_fontsize:Optional[int] = 24, title:Optional[str] = None, save:Optional[bool] = False, path_fig:Optional[str] = 'cwd'):\n\n        bwse_df = self.get_metadata(labels=['BWSE']).loc['BWSE']\n        bwse_values = bwse_df.values\n        labels = bwse_df.index\n\n        wanted_data = [labels,bwse_values]\n\n        if colors == 'sample':\n            colors = self.get_sRGB(dose_values=0).values.reshape(len(self.files),-1)\n\n\n        plotting.BWSE(data=wanted_data, frequency=frequency, bins=bins, figsize=figsize, colors=colors, fontsize=fontsize, title=title, title_fontsize=title_fontsize, rotate_xlabels=rotate_xlabels, position_xlabels=position_xlabels,  save=save, path_fig=path_fig)\n\n\n    def plot_CIELAB(self, stds=[], dose_unit:Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', colors:Union[str,list] = None, title:Optional[str] = None, fontsize:Optional[int] = 20, legend_labels:Union[str,list] = 'default', legend_position:Optional[str] = 'in', legend_fontsize:Optional[int] = 20, legend_title:Optional[str] = None, dE:Optional[bool] = False, obs_ill:Optional[bool] = True, save:Optional[bool] = False, path_fig:Optional[str] = 'cwd', report:Optional[bool] = False):\n        \"\"\"Plot the Lab values related to input the microfading files.\n\n        Parameters\n        ----------\n        stds : list, optional\n            A list of standard variation values respective to each element given in the data parameter, by default []\n\n        dose_unit : str, optional\n            Unit of the light energy dose, by default 'He'\n            Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        dose_values : [int, float, list, tuple], optional        \n            Values of the light dose energy, by default 'all'\n            A single value (integer or float number), a list of multiple numerical values, or range values with a tuple (start, end, step) can be entered.\n            When 'all', it takes the values found in the data.   \n\n        colors : [str, list], optional\n            Define the colors of the data points, by default None\n            When 'sample', the color of each points will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) or a list of matplotlib colour values can be used.     \n\n        title : str, optional\n            Whether to add a title to the plot, by default None\n\n        fontsize : int, optional\n            Fontsize of the plot (title, ticks, and labels), by default 24\n\n        legend_labels : [str, list], optional\n            A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default'\n            When 'default', each label will composed of the Id number of the number followed by a short description\n\n        legend_position : str, optional\n            Position of the legend, by default 'in'\n            The legend can either be inside the figure ('in') or outside ('out')\n\n        legend_fontsize : int, optional\n            Fontsize of the legend, by default 24\n\n        legend_title : str, optional\n            Add a title above the legend, by default ''\n\n        dE : bool, optional\n            Whether to display the dE00 curves in the bottom left suplots instead of the CIELAB 2D space, by default False\n            NOT IMPLEMENTED YET ! LEAVE PARAMETER TO FALSE\n\n        obs_ill : bool, optional\n            Whether to display the observer and illuminant values, by default True\n\n        save : bool, optional\n            Whether to save the figure, by default False\n\n        path_fig : str, optional\n            Absolute path required to save the figure, by default 'cwd'\n            When 'cwd', it will save the figure in the current working directory.\n\n        Returns\n        -------\n        png file\n            It returns a figure with 4 subplots that can be saved as a png file.\n        \"\"\"\n\n        data_Lab = self.get_cielab(coordinates=['L*', 'a*', 'b*'], dose_unit=dose_unit, dose_values=dose_values)\n        data_Lab = [x.T.values for x in data_Lab]\n\n\n        # Retrieve the metadata\n        info = self.get_metadata()\n        ids = [x for x in self.get_meas_ids if 'BW' not in x] \n\n        if 'group_description' in info.index:                \n            group_descriptions = info.loc['group_description'].values\n\n        else:\n            group_descriptions = [''] * len(self.files)\n\n\n\n        # Define the colour of the curves\n        if colors == 'sample':\n            pass           \n\n        elif isinstance(colors, str):\n            colors = [colors] * len(self.files)\n\n        elif colors == None:\n            colors = [None] * len(self.files)\n\n        # Define the labels\n        if legend_labels == 'default':\n            legend_labels = [f'{x}-{y}' for x,y in zip(self.get_meas_ids,group_descriptions)]\n            legend_title = 'Measurement $n^o$'\n\n        # Whether to plot the observer and illuminant info\n        if obs_ill:\n            DB = databases.DB()\n            if len(DB.get_colorimetry_info()) == 0:\n                observer = '10deg'\n                illuminant = 'D65'\n            else:\n                observer = DB.get_colorimetry_info().loc['observer']['value']\n                illuminant = DB.get_colorimetry_info().loc['illuminant']['value']\n\n            dic_obs = {'10deg':'$\\mathrm{10^o}$', '2deg':'$\\mathrm{2^o}$'}            \n            obs_ill = f'{dic_obs[observer]}-{illuminant}'\n\n        else:\n            obs_ill = None\n\n        return plotting.CIELAB(data=data_Lab, legend_labels=legend_labels, colors=colors, title=title, fontsize=fontsize, legend_fontsize=legend_fontsize, legend_position=legend_position, legend_title=legend_title, dE=dE, obs_ill=obs_ill, save=save, path_fig=path_fig)\n\n\n    def plot_swatches_circle(self, orientation:Optional[str] = 'horizontal', light_doses:Optional[list] = [0,0.5,1,2,5,15], JND:Optional[list] = [1,2,3,5,10], dose_unit:Union[str,tuple] = 'Hv', dE:Optional[bool] = True, fontsize:Optional[int] = 24, equation:Optional[str] = 'power_3p', initial_params:Optional[List[float]] = 'auto', bounds:Optional[list] = (-np.inf, np.inf), save:Optional[bool] = False, path_fig:Optional[str] = 'cwd', title:Optional[str] = None, report:Optional[bool] = False): \n        \"\"\"Plot the microfading data with circular colored patches. \n\n        Parameters\n        ----------\n\n        light_doses : list, optional\n            Light doses in Mlxh for which a coloured patches will be created, by default [0,0.5,1,2,5,1]\n            There has been at least two numerical values in the list. The first value corresponds to the color background of the plot and is usually set to 0. The other values will be plotted as circular patches.\n\n        JND : list, optional\n            Whether to plot circular patches of just noticeable differences, by default [1,2,3,5,10]\n            NOT YET IMPLEMENTED\n\n        dose_unit : [str, tuple], optional\n            Unit of the light energy dose, by default 'Hv'\n            Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (hours) (exh,50,10,365)\n\n        dE : bool, optional\n            Whether to include the dE00 value between the background and each circular patche, by default True\n\n        fontsize : int, optional\n            Fontsize of the plot (title, ticks, and labels), by default 24        \n\n        equation : str, optional\n            Mathematical equation used to fit the coordinate values, by default 'c0*(x**c1) + c2'.\n            Any others mathematical can be given. The following equation can also be used for fitting microfading data: '((x) / (c0 + (c1*x)))'.\n\n        initial_params : List[float], optional\n            Initial guesses of the 'c' parameters given in the equation (c0, c1, c2, etc.), by default [0.1, 0.0]\n            In the default values, only c0 and c1 are provided ; c2 is retrieved from the initial value of each colorimetric coordinate plot.\n\n        save : bool, optional\n            Whether to save the figure, by default False\n\n        path_fig : str, optional\n            Absolute path required to save the figure, by default 'cwd'\n            When 'cwd', it will save the figure in the current working directory.\n\n        title : str, optional\n            Whether to add a title to the plot, by default None, by default None        \n\n        report : bool, optional\n            _description_, by default False\n\n        Returns\n        -------\n        _type_\n            _description_\n        \"\"\"\n\n        # Define the title\n        if title == 'default':\n            title = list(self.get_meas_ids)\n\n\n        # Compute the extrapolated Lab values\n        list_extrapolated_Lab = []\n\n        for coord in ['L*','a*','b*']:            \n\n            fitted_coord = self.compute_fitting(coordinate=coord, plot=False, return_data=True, dose_unit=dose_unit, equation=equation,initial_params=initial_params, bounds=bounds,x_range=(light_doses[0], light_doses[-1]+1, 0.1))[1].loc[light_doses]\n\n            list_extrapolated_Lab.append(fitted_coord.T.values)\n\n\n        # Run the plotting function for each filehow to b\n        for i in range(0, len(self.files)):\n            wanted_Lab = pd.DataFrame([x[i] for x in list_extrapolated_Lab]).T.values\n\n            plotting.swatches_circle(data=[wanted_Lab], data_type='Lab', orientation=orientation, light_doses=light_doses, dose_unit=dose_unit, dE=dE, fontsize=fontsize, save=save, title=title, path_fig=path_fig)        \n\n\n    def plot_swatches_rectangle(self, swatches:Optional[tuple] = ('i',1), labels:Optional[list] = 'default', bottom_scale:Optional[str] = 'JND', top_label:Optional[str] = 'Hv', colorbar:Optional[bool] = False, fontsize:Optional[int] = 24, title:Optional[str] = None, save:Optional[bool] = False, path_fig:Optional[str] = 'cwd'):\n\n        # Adapt bottom scale for JND\n        if bottom_scale == 'JND' and isinstance(swatches[1], (int,float)):\n            bottom_scale = 'dE00'\n            swatches = (swatches[0], np.round(swatches[1]*1.3,2))\n\n        # Doses dic\n        doses_dic = {'He': 'MJ/m2', 'Hv':'Mlxh'}\n\n\n        # Define the dose_unit\n        if bottom_scale == 'He' or bottom_scale == 'Hv':\n            dose_unit = bottom_scale\n\n        elif top_label == 'He' or top_label == 'Hv':\n            dose_unit = top_label\n\n\n        # Retrieve the analyses light dose values\n        doses = [x['value'] for x in self.get_doses(dose_unit=dose_unit, max_doses=True)]\n        dose_min = np.min(doses)\n\n\n        # Define the Lab values for the top colour swatches\n        if swatches[0] == 'i':\n            dose_value_top = 0\n            top_text = 'Initial'\n\n        elif isinstance(swatches[0], (int, float)):\n            if swatches[0] &gt; dose_min:\n                print(f'Please, choose an initial dose value lower or equal to the final experimental light dose ({np.round(dose_min,2)} {doses_dic[dose_unit]}).')\n                return\n            else:\n                dose_value_top = swatches[0] \n                top_text = f'{swatches[0]} {doses_dic[dose_unit]}'  \n        else:\n            print('Enter valid values for the swatches parameter, ie. a tuple of integer or float.')\n            return\n\n        Lab_top = [x.values[0] for x in self.get_cielab(coordinates=['L*','a*', 'b*'], dose_unit=dose_unit, dose_values=dose_value_top)]\n\n\n        # Define the Lab values for the bottom colour swatches\n\n        if swatches[1] == 'f':                          # Select last measured values\n            Lab_bottom = [x.iloc[-1].values for x in self.get_cielab(coordinates=['L*','a*', 'b*'], dose_unit=dose_unit)]\n            bottom_text = 'Final'\n            wanted_dose = [x['value'] for x in self.get_doses(dose_unit=dose_unit, max_doses=True)]\n\n        elif isinstance(swatches[1], (int,float)):      # Select the values according to a dE or H value\n\n            Lab_bottom = []\n\n            if bottom_scale in ['He','Hv']:             # According to a dose value (He or Hv)\n\n                for coord in ['L*','a*', 'b*']:               \n\n                    coord_bottom = self.compute_fitting(plot=False, return_data=True,coordinate=coord,dose_unit=dose_unit, x_range=(0,swatches[1]+1,0.1))[1].loc[swatches[1]].values\n                    Lab_bottom.append(coord_bottom) \n\n                Lab_bottom = pd.DataFrame(Lab_bottom).T.values  \n\n\n            elif bottom_scale in ['dE76','dE00','dR_vis']:    # According to a dE or dR value\n\n                max_doses = {'He':2000.1, 'Hv':200.1}\n                dE_fitted = self.compute_fitting(plot=False, return_data=True,coordinate=bottom_scale,dose_unit=dose_unit, x_range=(0,max_doses[dose_unit],0.1))[1]                \n\n                wanted_doses = []\n                for col in dE_fitted.columns:\n\n                    dE_data = dE_fitted[col]\n\n\n                    if dE_data.values[-1] &gt; swatches[1]:\n                        wanted_doses.append(interp1d(dE_data.values, dE_data.index)([swatches[1]])[0])\n\n                    else:\n                        wanted_doses.append(dE_data.index[-1])\n\n                for i, wanted_dose in enumerate(wanted_doses):\n                    for coord in ['L*','a*', 'b*']:\n                        coord_bottom = self.compute_fitting(plot=False, return_data=True,coordinate=coord,dose_unit=dose_unit, x_range=(0,wanted_dose+0.1,0.1))[1].values[-1][i]\n\n\n                        Lab_bottom.append(coord_bottom)\n\n                Lab_bottom = pd.DataFrame(Lab_bottom).T.values[0]\n                Lab_bottom = Lab_bottom.reshape(len(wanted_doses),-1)\n\n\n            bottom_text = f'{swatches[1]} {labels_eq[bottom_scale]}'\n\n        else:\n            print('Enter valid values for the swatches parameter, ie. a tuple of integer or float.')\n            return\n\n\n        # Pair the top and bottom Lab values\n        wanted_data = [(x,y) for x,y in zip(Lab_top,Lab_bottom)]\n\n\n        # Define the labels\n        if labels == 'default':\n            labels = list(self.get_metadata('meas_id').values)\n\n        elif labels == 'none':\n            labels = []\n\n\n        # Define the top label values\n        if top_label in ['He','Hv']:           \n\n            top_labels = {top_label: np.round(wanted_doses,3)}\n\n        if top_label in ['dE76','dE94','dE00']:\n            methods_dE = {'dE76': 'CIE 1976', 'dE94': 'CIE 1994', 'dE00': 'CIE 2000'}\n            top_label_values = [np.round(colour.delta_E(x[0],x[1], method=methods_dE[top_label]),2) for x in wanted_data]\n            top_labels = {top_label:top_label_values}\n\n\n        # Define the side annotations\n        side_annotations = (top_text, bottom_text)\n\n        # Whether to save the figure\n        if save == True:\n            if path_fig == 'cwd':\n                path_fig = f'{os.getcwd()}/MFT_{\"-\".join(self.get_meas_ids)}_SW-rect.png'  \n\n\n        # Run the plotting function\n        plotting.swatches_rectangle(data=wanted_data, data_type='Lab', labels=labels, bottom_scale=bottom_scale, top_labels=top_labels, fontsize=fontsize, side_annotations=side_annotations, colorbar=colorbar, title=title, save=save, path_fig=path_fig)\n\n\n    def plot_delta(self, stds:Optional[bool] = True, coordinates:Optional[list] = ['dE00'], dose_unit:Optional[str] = 'He', legend_labels:Union[str, list] = 'default', initial_values:Optional[bool] = False, figsize:Optional[tuple] = (15,9), colors:Union[str,list] = None, lw:Union[int,list] = 'default', title:Optional[str] = None, fontsize:Optional[int] = 24, legend_fontsize:Optional[int] = 24, legend_title:Optional[str] = None, xlim:Optional[tuple] = None, save:Optional[bool] = False, path_fig:Optional[str] = 'cwd'):\n        \"\"\"Plot the delta values of choosen colorimetric coordinates related to the microfading analyses.\n\n        Parameters\n        ----------\n        stds : bool, optional\n            Whether to show the standard deviation values if any, by default True.\n\n        coordinates : list, optional\n            List of colorimetric coordinates, by default ['dE00']\n            Any of the following coordinates can be added to the list: 'dE76', 'dE00', 'dR_vis' , 'L*', 'a*', 'b*', 'C*', 'h'.\n\n        dose_unit : str, optional\n            Unit of the light energy dose, by default 'He'\n            Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n        legend_labels : Union[str, list], optional\n            A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default'\n            When 'default', each label will composed of the Id number of the number followed by a short description\n\n        colors : Union[str, list], optional\n            Define the colors of the curves, by default None\n            When 'sample', the color of each line will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) and will be applied to all the lines. Or a list of matplotlib colour values can be used. With a single coordinate, the list should have the same length as measurement files. With multiple coordinates, the list should have the same length as coordinates.\n\n        lw : Union[int,list], optional\n            Width of the lines, by default 'default'\n            When 'default', it attributes a given a width according to each coordinates, otherwise it gives a value of 2.\n            A single value (an integer) can be entered and applied to all the lines.\n            A list of integers can also be entered. With a single coordinate, the list should have the same length as measurement files. With multiple coordinates, the list should have the same length as coordinates.\n\n        title : str, optional\n            Whether to add a title to the plot, by default None\n\n        fontsize : int, optional\n            Fontsize of the plot (title, ticks, and labels), by default 24\n\n        legend_fontsize : int, optional\n            Fontsize of the legend, by default 24\n\n        legend_title : str, optional\n            Add a title above the legend, by default ''\n\n        xlim : tuple, optional\n            A tuple of two integers that define the left and right limits of the x-axis , by default None.\n\n        save : bool, optional\n            Whether to save the figure, by default False\n\n        path_fig : str, optional\n            Absolute path required to save the figure, by default 'cwd'\n            When 'cwd', it will save the figure in the current working directory.\n        \"\"\"\n\n        # Retrieve the data\n        if xlim == None:\n            dose_values = 'all'\n        elif isinstance(xlim, tuple):\n            dose_values = (xlim[0], xlim[1], 0.05)\n\n        all_data = self.compute_delta(coordinates=coordinates, dose_unit=dose_unit, dose_values=dose_values)\n        nominal_data = []\n        stdev_data = []\n\n        for data in all_data:\n\n            if sorted(set(data.columns.get_level_values(1))) == ['mean', 'std']:\n                nominal = data.xs(key='mean', axis=1, level=1)\n                if stds:\n                    stdev = data.xs(key='std', axis=1, level=1)   \n                else:\n                    stdev = nominal.copy()   \n                    stdev.iloc[:,:] = 0         \n\n            else:\n\n                nominal = data\n                stdev = data.copy()\n                stdev.iloc[:,:] = 0\n\n\n            nominal_data.append(nominal.reset_index().T.values)\n            stdev_data.append(stdev.T.values)\n\n\n\n        # Retrieve the metadata\n        info = self.get_metadata()\n        ids = [x for x in self.get_meas_ids]\n        meas_nbs = [x.split('.')[-1] for x in ids]\n\n        if 'spot_description' in info.index:                \n            group_descriptions = info.loc['spot_description'].values\n\n        else:\n            group_descriptions = [''] * len(self.files)\n\n\n        # Set the labels values\n        if legend_labels == 'default':                       \n            legend_labels = [f'{x}-{y}' for x,y in zip(ids, group_descriptions)] \n\n        elif legend_labels == '':\n            legend_labels = []\n\n        elif isinstance(legend_labels, list):\n            legend_labels = legend_labels\n            '''\n            labels_list = []\n            for i,Id in enumerate(self.get_meas_ids):\n                label = Id.split('.')[-1]\n                for el in labels:\n                    label = label + f'-{self.get_metadata().loc[el].values[i]}'\n                labels_list.append(label)\n\n            labels = labels_list\n            '''\n\n        # Add the initial values of the colorimetric coordinates\n\n        if initial_values:  \n            initial_values = {}          \n            for coord in coordinates:\n                if coord in ['dL*', 'da*', 'db*', 'dC*', 'dh']:\n                    initial_value = self.get_cielab(coordinates=[coord[1:]])[0][coord[1:]].iloc[0,:].values[0]\n                    initial_values[coord[1:]] = initial_value\n        else:\n            initial_values = {}  \n\n        if len(meas_nbs) &gt; 1:\n            initial_values = {}\n\n        # Set the color of the lines according to the sample\n        if colors == 'sample':\n            colors = list(self.get_sRGB(dose_values=0).values.reshape(len(meas_nbs),-1))\n            colors = colors * len(coordinates)\n\n        # Whether to add a title or not\n        if title == 'default':\n            title = 'MFT'            \n        elif title == 'none':\n            title = None\n        else:\n            title = title \n\n        # Define the saving folder in case the figure should be saved\n        filename = ''\n        if save:\n            if path_fig == 'default':\n                path_fig = self.get_dir(folder_type='figures') / filename                \n\n            if path_fig == 'cwd':\n                path_fig = f'{os.getcwd()}/{filename}' \n\n\n        plotting.delta(data=nominal_data, yerr=stdev_data, dose_unit=[dose_unit], coordinates=coordinates, initial_values=initial_values, figsize=figsize, colors=colors, lw=lw, title=title, fontsize=fontsize, legend_labels=legend_labels, legend_fontsize=legend_fontsize, legend_title=legend_title, save=save, path_fig=path_fig)\n\n\n    def plot_sp(self, stdev:Optional[bool] = False, spectra:Optional[str] = 'i', dose_unit:Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', spectral_mode:Optional[str] = 'R', legend_labels:Union[str,list] = 'default', title:Optional[str] = None, fontsize:Optional[int] = 24, fontsize_legend:Optional[int] = 24, legend_title='', wl_range:Optional[tuple] = None, colors:Union[str,list] = None, lw:Union[int, list] = 2, ls:Union[str, list] = '-', text_xy:Optional[tuple] = (0.02,0.03), save=False, path_fig='cwd', derivation=False, smoothing=(1,0), report:Optional[bool] = False):\n        \"\"\"Plot the reflectance spectra corresponding to the associated microfading analyses.\n\n        Parameters\n        ----------\n        stdev : bool, optional\n            Whether to show the standard deviation values, by default False\n\n        spectra : Optional[str], optional\n            Define which spectra to display, by default 'i'\n            'i' for initial spectral, \n            'f' for final spectra,\n            'i+f' for initial and final spectra, \n            'all' for all the spectra, \n            'doses' for spectra at different dose values indicated by the dose_unit and dose_values parameters\n\n        dose_unit : str, optional\n            Unit of the light energy dose, by default 'He'\n            Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec). It only works if the 'spectra' parameters has been set to 'doses'.\n\n        dose_values : Union[int, float, list, tuple], optional\n            Values of the light dose energy, by default 'all'\n            A single value (integer or float number), a list of multiple numerical values, or range values with a tuple (start, end, step) can be entered.\n            When 'all', it takes the values found in the data. It only works if the 'spectra' parameters has been set to 'doses'.\n\n        spectral_mode : string, optional\n            When 'R', it returns the reflectance spectra            \n            When 'A', it returns the absorption spectra using the following equation: A = -log(R)\n\n        legend_labels : Union[str, list], optional\n            A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default'\n            When 'default', each label will composed of the Id number of the number followed by a short description\n\n        title : str, optional\n            Whether to add a title to the plot, by default None\n\n        fontsize : int, optional\n            Fontsize of the plot (title, ticks, and labels), by default 24\n\n        fontsize_legend : int, optional\n            Fontsize of the legend, by default 24\n\n        legend_title : str, optional\n            Add a title above the legend, by default ''\n\n        wl_range : tuple, optional\n            Define the wavelength range with a two-values tuple corresponding to the lowest and highest wavelength values, by default None\n\n        colors : Union[str, list], optional\n            Define the colors of the reflectance curves, by default None\n            When 'sample', the color of each line will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) or a list of matplotlib colour values can be used. \n\n        lw : Union[int, list], optional\n            Define the width of the plot lines, by default 2\n            It can be a single integer value that will apply to all the curves. Or a list of integers can be used where the number of integer elements should match the number of reflectance curves.\n\n        ls : Union[str, list], optional\n            Define the line style of the plot lines, by default '-'\n            It can be a string ('-', '--', ':', '-.') that will apply to all the curves. Or a list of string can be used where the number of string elements should match the number of reflectance curves.\n\n        save : bool, optional\n            Whether to save the figure, by default False\n\n        path_fig : str, optional\n            Absolute path required to save the figure, by default 'cwd'\n            When 'cwd', it will save the figure in the current working directory.\n\n        derivation : bool, optional\n            Wether to compute and display the first derivative values of the spectra, by default False\n\n        smooth : bool, optional\n            Whether to smooth the reflectance curves, by default False\n\n        smooth_params : list, optional\n            Parameters related to the Savitzky-Golay filter, by default [10,1]\n            Enter a list of two integers where the first value corresponds to the window_length and the second to the polyorder value. \n\n        report : Optional[bool], optional\n            Configure some aspects of the figure for use in a report, by default False\n\n        Returns\n        -------\n        _type_\n            It returns a figure that can be save as a png file.\n        \"\"\"\n\n        # Apply the report characteristics\n\n        if report:\n            save = True\n            colors = 'sample'\n            spectra = 'i+f'\n            fontsize = 30\n\n        # Retrieve the metadata\n        info = self.get_metadata()\n\n        if 'spot_description' in info.index:                \n            spot_descriptions = info.loc['spot_description'].values\n\n        else:\n            spot_descriptions = [''] * len(self.files)\n\n\n        # Define the colour of the curves\n        if colors == 'sample':\n            colors = self.get_sRGB().iloc[0,:].values.clip(0,1).reshape(len(self.files),-1)\n\n        elif isinstance(colors, str):\n            colors = [colors] * len(self.files)\n\n        elif colors == None:\n            colors = [None] * len(self.files)\n\n        # Define the labels\n        if legend_labels == 'default':\n            legend_labels = [f'{x}-{y}' for x,y in zip(self.get_meas_ids,spot_descriptions)]\n            legend_title = 'Measurement $n^o$'\n\n        # Select the spectral data\n        if spectra == 'i':            \n            data_sp_all = self.get_spectra(wl_range=wl_range, smoothing=smoothing)\n            data_sp = [x[x.columns.get_level_values(0)[0]] for x in data_sp_all]            \n\n            text = 'Initial spectra'\n\n        elif spectra == 'f':\n            data_sp_all = self.get_spectra(wl_range=wl_range, smoothing=smoothing)\n            data_sp =[x[x.columns.get_level_values(0)[-1]] for x in data_sp_all] \n\n            text = 'Final spectra'\n\n        elif spectra == 'i+f':\n            data_sp_all = self.get_spectra(wl_range=wl_range, smoothing=smoothing)\n            data_sp = [x[x.columns.get_level_values(0)[[0]+[-1]]] for x in data_sp_all]            \n\n            ls = ['-', '--'] * len(data_sp)\n            lw = [3,2] * len(data_sp)\n            black_lines = ['k'] * len(data_sp)            \n            colors = list(itertools.chain.from_iterable(zip(colors, black_lines)))            \n\n\n            if legend_labels == 'default':\n                meas_labels = [f'{x}-{y}' for x,y in zip(self.get_meas_ids,spot_descriptions)]\n            else:\n                meas_labels = legend_labels\n            none_labels = [None] * len(meas_labels)\n            legend_labels = [item for pair in zip(meas_labels, none_labels) for item in pair]\n\n            text = 'Initial and final spectra (black dashed lines)'\n\n        elif spectra == 'doses':\n            data_sp = self.get_spectra(wl_range=wl_range, dose_unit=dose_unit,dose_values=dose_values, smoothing=smoothing)\n\n\n            dose_units = {'He': 'MJ/m2', 'Hv': 'Mlxh', 't': 'sec'}\n            legend_title = f'Light dose values'\n            legend_labels = [f'{str(x)} {dose_units[dose_unit]}' for x in dose_values] * len(data_sp)\n\n            text = ''\n\n            ls_list = ['-','--','-.',':','-','--','-.',':','-','--','-.',':',]\n            ls = ls_list[:len(dose_values)] * len(data_sp)        \n            srgb_i = self.get_sRGB().iloc[0,:].values.reshape(-1, 3)            \n            colors = np.repeat(srgb_i, data_sp[0].shape[1], axis=0).clip(0,1)          \n\n        else:\n            print(f'\"{spectra}\" is not an adequate value. Enter a value for the parameter \"spectra\" among the following list: \"i\", \"f\", \"i+f\", \"doses\".')\n            return           \n\n        # whether to compute the absorption spectra\n        if spectral_mode == 'abs':\n            data_sp = [np.log(x) * (-1) for x in data_sp]\n\n        # Reset the index\n        data = [x.reset_index() for x in data_sp]\n\n        # Whether to compute the first derivative\n        if derivation:\n            data = [pd.concat([x.iloc[:,0], pd.DataFrame(np.gradient(x.iloc[:,1:], axis=0))], axis=1) for x in data]\n\n        # Compile the spectra to plot inside a list\n        wanted_data = []  \n        wanted_std = []\n\n        # Set the wavelength column as index\n        data = [x.set_index(x.columns.get_level_values(0)[0]) for x in data]          \n\n        # Add the std values\n        if stdev:            \n            try:     \n\n                values_data = [x.T.iloc[::2].values for x in data]\n                values_wl = [x.index for x in data]\n                for el1, wl in zip(values_data, values_wl):\n                    for el2 in el1:\n                        wanted_data.append((wl,el2))\n\n                values_std = [x.T.iloc[1::2].values for x in data]                \n                for el1 in values_std:\n                    for el2 in el1:\n                        wanted_std.append(el2)\n            except IndexError:\n                wanted_std = []\n\n        else:\n            for el in data:                \n                data_values = [ (el.index,x) for x in el.T.values]\n                wanted_data = wanted_data + data_values \n            wanted_std = []\n\n\n        return plotting.spectra(data=wanted_data, stds=wanted_std, spectral_mode=spectral_mode, legend_labels=legend_labels, title=title, fontsize=fontsize, fontsize_legend=fontsize_legend, legend_title=legend_title, x_range=wl_range, colors=colors, lw=lw, ls=ls, text=text, text_xy=text_xy, save=save, path_fig=path_fig, derivation=derivation)\n\n\n    def plot_sp_delta(self,spectra:Optional[tuple] = ('i','f'), dose_unit:Optional[str] = 'Hv', legend_labels:Union[str,list] = 'default', title:Optional[str] = None, fontsize:Optional[int] = 24, legend_fontsize:Optional[int] = 24, legend_title='', wl_range:Union[int,float,list,tuple] = 'default', colors:Union[str,list] = None, spectral_mode:Optional[str] = 'dR', derivation=False, smoothing=(1,0), report:Optional[bool] = False):\n\n        # Set the wavelength range       \n        if wl_range == 'default':\n\n            device_info = sorted(set(self.get_metadata('device')))\n\n            if len(device_info) == 1:                \n                device_id = device_info[0].split('_')[0]\n\n            if device_id in list(get_DB_config()['devices'].keys()):\n                wl_range = get_DB_config()['devices'][device_id] ['wl_range']\n\n                if wl_range != None:\n                    wl_range = tuple(wl_range)\n\n            else:\n                wl_ranges = []\n\n                wl_range = tuple(np.min(wl_ranges), np.max(wl_ranges))\n\n\n        # Set the report parameters\n        if report:\n            pass\n\n        if spectra == ('i','f'):\n\n            sp_data = [x.iloc[:,[0,-1]] for x in self.get_spectra(wl_range=wl_range, spectral_mode=spectral_mode)]\n            sp_delta = [x.iloc[:,1] - x.iloc[:,0] for x in sp_data]\n            wanted_data = [(x.index, x.values) for x in sp_delta]\n\n        elif spectra[0] == 'i':\n\n            sp1 = [x.iloc[:,0] for x in self.get_spectra(wl_range=wl_range, spectral_mode=spectral_mode)]\n            sp2 = [x.values.flatten() for x in self.get_spectra(dose_unit=dose_unit, dose_values=float(spectra[1]),wl_range=wl_range, spectral_mode=spectral_mode)]\n\n            wanted_data = [(x.index,np.array(y)-np.array(x)) for x,y in zip(sp1,sp2)]\n\n        elif spectra[1] == 'f':\n\n            sp1 = [x.values.flatten() for x in self.get_spectra(dose_unit=dose_unit, dose_values=float(spectra[0]), wl_range=wl_range, spectral_mode=spectral_mode)]            \n            sp2 = [x.iloc[:,-1] for x in self.get_spectra(wl_range=wl_range, spectral_mode=spectral_mode)]            \n\n            wanted_data = [(y.index,np.array(y)-np.array(x)) for x,y in zip(sp1,sp2)]\n\n        else:\n\n            wavelengths = self.get_wavelength.T.values\n            sp1 = [x.values.flatten() for x in self.get_spectra(dose_unit=dose_unit, dose_values=float(spectra[0]),wl_range=wl_range, spectral_mode=spectral_mode)]\n            sp2 = [x.values.flatten() for x in self.get_spectra(dose_unit=dose_unit, dose_values=float(spectra[1]),wl_range=wl_range, spectral_mode=spectral_mode)]\n\n            wanted_data = [(w,np.array(y)-np.array(x)) for w,x,y in zip(wavelengths,sp1,sp2)]   \n\n        # Retrieve the metadata\n        info = self.get_metadata()\n\n        if 'group_description' in info.index:                \n            group_descriptions = info.loc['group_description'].values\n\n        else:\n            group_descriptions = [''] * len(self.files)        \n\n\n        # Define the colour of the curves\n        if colors == 'sample':\n            colors = self.get_sRGB().iloc[0,:].values.clip(0,1).reshape(len(self.files),-1)\n\n        elif isinstance(colors, str):\n            colors = [colors] * len(self.files)\n\n        elif colors == None:\n            colors = [None] * len(self.files)\n\n        # Define the labels\n        if legend_labels == 'default':\n            legend_labels = [f'{x}-{y}' for x,y in zip(self.get_meas_ids,group_descriptions)]\n            legend_title = 'Measurement $n^o$'\n\n        # Whether to compute the first derivative\n        if derivation:\n            pass  # to implement in future versions\n            #wanted_data = [x.reset_index() for x in wanted_data]\n            #wanted_data = [pd.concat([x.iloc[:,0], pd.DataFrame(np.gradient(x.iloc[:,1:], axis=0))], axis=1) for x in wanted_data]\n            #wanted_data = [x.set_index(x.columns.get_level_values(0)[0]) for x in wanted_data] \n\n\n        #return wanted_data\n        plotting.spectra(data=wanted_data, spectral_mode=spectral_mode, x_range=wl_range, colors=colors, fontsize_legend=legend_fontsize, legend_labels=legend_labels, legend_title=legend_title, title=title, fontsize=fontsize, derivation=derivation)\n\n\n    def make_report(self, folder_figures, folder_report:Optional[str] = 'cwd', type:Optional[str] = 'single', authors:Optional[str] = 'default'):\n\n\n        all_figure_files = os.listdir(folder_figures)   \n\n        # Define the folder where the report should be saved\n        if folder_report == 'cwd':\n            folder_report = Path(os.getcwd())  \n        else:\n            if not Path(folder_report).exists():\n                print(f'The folder report you entered ({folder_report}) is not valid.')\n                return  \n            else:\n                folder_report = Path(folder_report) \n\n        # Define some functions\n        def generate_latex_table(df):\n            table_rows = []\n            for _, row in df.iterrows():\n                table_rows.append(' &amp; '.join(map(str, row.values)) + ' \\\\\\\\ ') \n            return '\\n'.join(table_rows)\n\n\n        def combine_images(sp_report_path, swv_circles_report_path, dlch_report_path, output_path):\n\n            # Open the images\n            sp_report = Image.open(sp_report_path)\n            swv_circles_report = Image.open(swv_circles_report_path)\n            dlch_report = Image.open(dlch_report_path)\n\n            # Define the desired width for the images in the left column\n            desired_width_left = 1100  # Adjust as needed\n            desired_width_right = 400  # Adjust as needed\n\n            # Calculate the scaling factors\n            sp_scaling_factor = desired_width_left / sp_report.width\n            swv_scaling_factor = desired_width_right / swv_circles_report.width\n            dlch_scaling_factor = desired_width_left / dlch_report.width\n\n            # Calculate the new sizes while maintaining aspect ratio\n            sp_new_size = (int(sp_report.width * sp_scaling_factor), int(sp_report.height * sp_scaling_factor))\n            swv_new_size = (int(swv_circles_report.width * swv_scaling_factor), int(swv_circles_report.height * swv_scaling_factor))\n            dlch_new_size = (int(dlch_report.width * dlch_scaling_factor), int(dlch_report.height * dlch_scaling_factor))\n\n            # Resize the images\n            sp_report_resized = sp_report.resize(sp_new_size, Image.LANCZOS)\n            swv_circles_report_resized = swv_circles_report.resize(swv_new_size, Image.LANCZOS)\n            dlch_report_resized = dlch_report.resize(dlch_new_size, Image.LANCZOS)\n\n            # Calculate the total width and height for the combined image\n            total_width = desired_width_left + desired_width_right            \n            total_height = sp_new_size[1] + dlch_new_size[1]            \n\n            # Create a new blank image with white background\n            combined_image = Image.new('RGB', (total_width, total_height), 'white')\n\n            # Paste the resized images into the combined image\n            combined_image.paste(sp_report_resized, (0, 0))\n            combined_image.paste(swv_circles_report_resized, (desired_width_left, 0))            \n            combined_image.paste(dlch_report_resized, (0, sp_new_size[1]))\n\n            # Save the combined image\n            combined_image.save(output_path)\n\n\n\n\n        if type == 'single':\n\n            for file, id in zip(self.files, self.get_meas_ids):\n\n\n                figure1 = [file for file in all_figure_files if id in file and 'CIELAB-report' in file][0]                \n                figure_SP = [f'{folder_figures}/{file}' for file in all_figure_files if f'{id}' in file and 'SP-report' in file][0]\n                figure_dLCh = [f'{folder_figures}/{file}' for file in all_figure_files if f'{id}' in file and 'dLCh-report' in file][0]\n                figure_SW = [f'{folder_figures}/{file}' for file in all_figure_files if f'{id}' in file and 'SWVcircles-report' in file][0]\n                im_combined_path = Path(folder_figures) / f'{id}_report_SP-dLCh-SW.png'\n\n                # Combine the images\n                combine_images(figure_SP, figure_SW, figure_dLCh, im_combined_path)\n\n                metadata = self.get_metadata()[id]\n\n                if authors == 'default':\n                    authors = metadata['authors'].replace('_','-')\n\n                host_institution = metadata['host_institution']\n                if '_' in host_institution:\n                    host_institution_name = host_institution.split('_')[0]\n                    host_institution_department = host_institution.split('_')[1]\n\n                else:\n                    host_institution_name = host_institution\n                    host_institution_department = ''\n\n\n                BWSE = metadata['BWSE']\n                if np.isnan(BWSE):\n                    BWSE = 'undefined'\n                else:\n                    BWSE = str(BWSE)\n\n                spot_materials = metadata['spot_components']\n\n                if np.isnan(spot_materials):\n                    spot_materials = 'undefined'                    \n\n                elif '_' in spot_materials:\n                    spot_materials = spot_materials.replace('_','-')\n\n\n                info_object = \"\"\"\n                    \\\\textbf{Analysis ID} &amp; [analysisId] \\\\\\\\\n                    \\\\textbf{Analysis date} &amp; [analysisDate] \\\\\\\\\n                    \\\\textbf{Object ID} &amp; [objectId] \\\\\\\\                \n                    \\\\textbf{Institution} &amp; [institution] \\\\\\\\\n                    \\\\textbf{Name object} &amp; [objectName] \\\\\\\\\n                    \\\\textbf{Artist} &amp; [artist] \\\\\\\\\n                    \\\\textbf{Date} &amp; [objectDate] \\\\\\\\\n                    \\\\textbf{Techniques} &amp; [techniques] \\\\\\\\                                    \n                    \\\\textbf{MFT group} &amp; [MFTgroup] \\\\\\\\\n                    \\\\textbf{MFT spot} &amp; [spot_description] \\\\\\\\\n                    \\\\textbf{Materials} &amp; [spot_materials] \\\\\\\\\n                    \\\\textbf{BWSE} &amp; [BWSE] \\\\\\\\\n                    &amp; \\\\\\\\\n                    \\\\textbf{MFT device} &amp; [device] \\\\\\\\\n                    \\\\textbf{MFT lamp} &amp; [lamp] \\\\\\\\\n                    \\\\textbf{MFT spot size} &amp; [spotSize] \\\\\\\\\n                    \\\\textbf{Illuminance} &amp; [ill] \\\\\\\\\n                    \\\\textbf{Irradiance} &amp; [irr] \\\\\\\\\n                    \\\\textbf{Exposure dose} &amp; [Hv] \\\\\\\\\n                    \\\\textbf{Radiant energy} &amp; [He] \\\\\\\\\n                    \\\\textbf{Duration} &amp; [duration] \\\\\\\\                 \n                \"\"\"\n\n\n                # define the mapping table\n                mapping_table_object = {\n                    '[analysisId]': id,\n                    '[analysisDate]': str(metadata['date_time']),\n                    '[objectId]': metadata['object_id'],                \n                    '[institution]': metadata['institution'],\n                    '[objectName]': metadata['object_name'], \n                    '[artist]' : metadata['object_creator'],   \n                    '[objectDate]': str(metadata['object_date']),\n                    '[techniques]' : metadata['object_technique'].replace('_','-'),\n                    '[spot_materials]': spot_materials,\n                    '[NbAnalyses]': str(metadata['measurements_N']),  \n                    '[MFTgroup]': metadata['spot_group'], \n                    '[ill]': f'{metadata[\"illuminance_Ev_Mlx\"]} Mlx',\n                    '[irr]': f'{metadata[\"irradiance_Ee_W/m^2\"]} W/m2',\n                    '[Hv]': f'{metadata[\"exposureDose_Hv_Mlxh\"]} Mlxh',\n                    '[He]': f'{metadata[\"radiantExposure_He_MJ/m^2\"]} MJ/m2',\n                    '[duration]': f'{np.int32(metadata[\"duration_min\"])} min', \n                    '[device]' : metadata['device'].replace('_','-'),\n                    '[lamp]': str(metadata['lamp_fading']),\n                    '[spot_description]': metadata['spot_description'],      \n                    '[spotSize]': f'{metadata[\"FWHM_micron\"]} microns',\n                    '[BWSE]': BWSE,\n                    }\n                #print(mapping_table_object).values()\n                for x in mapping_table_object.keys():                                 \n                    info_object = info_object.replace(x, mapping_table_object[x])            \n\n\n                table_data = {'info_object': info_object}\n\n                figure_paths = {\n                    'figure1': folder_figures / figure1,\n                    'figure2': im_combined_path,                                 \n                }\n\n                with open(Path(__file__).parent / 'report_templates' / 'MFT_report_single.tex', 'r') as template_file:\n                    template = template_file.read()\n\n                # Fill in placeholders with actual values\n                filled_template = template.replace('[PROJECTID]',metadata['project_id'])\n                filled_template = filled_template.replace('[ANALYSISID]', id)\n                filled_template = filled_template.replace('[INSTITUTION]', host_institution_name)\n                #filled_template = filled_template.replace('[DEPARTMENT]', host_institution_department)\n                filled_template = filled_template.replace('[YOURNAME]', authors)\n                filled_template = filled_template.replace('[TABLE1DATA]', table_data['info_object'])            \n                filled_template = filled_template.replace('[FIGURE1PATH]', str(figure_paths['figure1']))\n                filled_template = filled_template.replace('[FIGURE2PATH]', str(figure_paths['figure2']))                \n\n\n                # Write filled template to .tex file\n                with open('temp_report.tex', 'w') as temp_file:\n                    temp_file.write(filled_template)\n\n                # Compile .tex file into PDF\n                subprocess.run(['pdflatex', 'temp_report.tex'])\n\n                # Move generated PDF to output file                \n                subprocess.run(['mv', 'temp_report.pdf', f'{folder_report}/{metadata[\"project_id\"]}_MFT_rapport-analysis_{id}.pdf'])\n\n                # Clean up temporary .tex and auxiliary files\n                subprocess.run(['rm', 'temp_report.tex', 'temp_report.aux', 'temp_report.log'])\n\n\n        if type == 'object':\n\n            object_ids = sorted(set(list(self.get_metadata('object_id').values)))\n            metadata = self.get_metadata()\n\n            print(object_ids)\n            for object_id in object_ids:\n\n\n                figure_spots = [f'{folder_figures}/{file}' for file in all_figure_files if object_id in file and 'MFT-spots' in file][0]                \n                figure_dE = [f'{folder_figures}/{file}' for file in all_figure_files if f'{object_id}' in file and 'dE-curves-report' in file][0]\n                figure_SW = [f'{folder_figures}/{file}' for file in all_figure_files if f'{object_id}' in file and 'SW-rect-report' in file][0]\n\n\n                metadata_object = metadata.loc[:, metadata.loc['object_id'] == object_id]\n\n                if authors == 'default':\n                    authors = metadata['authors'].replace('_','-')\n\n                host_institution = metadata.loc['host_institution'][0].replace('_','-')\n\n                info_object = \"\"\"\n                    \\\\textbf{Object ID} &amp; [objectId] \\\\\\\\                \n                    \\\\textbf{Institution} &amp; [institution] \\\\\\\\\n                    \\\\textbf{Object name} &amp; [objectName] \\\\\\\\\n                    \\\\textbf{Artist} &amp; [artist] \\\\\\\\\n                    \\\\textbf{Date} &amp; [objectDate] \\\\\\\\\n                    \\\\textbf{Techniques} &amp; [technique] \\\\\\\\\n                    \\\\textbf{Materials} &amp; [objectMaterial] \\\\\\\\\n                    &amp; \\\\\\\\\n                    \\\\textbf{N\\\\textsuperscript{o} MFT analyses} &amp; [NbAnalyses] \\\\\\\\\n                    \\\\textbf{N\\\\textsuperscript{o} MFT groups} &amp; [NbGroups] \\\\\\\\\n                    \\\\textbf{Illuminance} &amp; [ill] \\\\\\\\\n                    \\\\textbf{Exposure dose} &amp; [Hv] \\\\\\\\\n                    \\\\textbf{Duration} &amp; [duration] \\\\\\\\                 \n                \"\"\"\n\n\n                BWSE = \"\"\"                \n                    [nb01] &amp; [BWSE01] \\\\\\\\\n                    [nb02]  &amp; [BWSE02] \\\\\\\\  \n                    [nb03] &amp; [BWSE03] \\\\\\\\                                   \n                \"\"\"\n\n\n\n\n                #table_data2 = generate_latex_table(df)\n\n                nb_analyses = str(metadata_object.shape[1])\n                nb_groups = str(len(set(metadata_object.loc['spot_group'].values)))\n                ill = np.round(np.mean(metadata_object.loc['illuminance_Ev_Mlx'].values),2)\n                Hv = np.round(np.mean(metadata_object.loc['exposureDose_Hv_Mlxh'].values),2)\n\n                object_materials = list(set(metadata.loc['object_material'].values))[0]\n                if \"_\" in object_materials:\n                    object_materials = object_materials.replace(\"_\",', ')\n\n                # define the mapping table\n                mapping_table_object = {\n                    '[objectId]': object_id,                \n                    '[institution]': list(set(metadata.loc['institution'].values))[0],\n                    '[objectName]': list(set(metadata.loc['object_name'].values))[0], \n                    '[artist]' : list(set(metadata.loc['object_creator'].values))[0],   \n                    '[objectDate]': list(set(metadata.loc['object_date'].values))[0],\n                    '[technique]' : list(set(metadata.loc['object_technique'].values))[0],\n                    '[objectMaterial]': object_materials,\n                    '[NbAnalyses]': nb_analyses,  \n                    '[NbGroups]': nb_groups, \n                    '[ill]': f'{ill} Mlx (Avg)',\n                    '[Hv]': f'{Hv} Mlxh (Avg)',\n                    '[duration]': '15 min' # f'{(metadata.loc[\"duration_min\"].values)} min',            \n                    }           \n                #print(mapping_table_object) \n\n                for x in mapping_table_object.keys():\n                    info_object = info_object.replace(x, mapping_table_object[x])    \n\n\n                table_data = {'info_object': info_object, 'BWSE': BWSE}\n\n\n                figure_paths = {\n                    'figure1': folder_figures / figure_spots,\n                    'figure2': folder_figures / figure_dE,\n                    'figure3': folder_figures / figure_SW,                                 \n                }\n\n                BWSE = metadata_object.loc['BWSE'].values\n                print(BWSE)\n                simplified_BWSE = []\n\n                for i in BWSE:\n                    i = float(i)\n\n                    if i &gt;0.8 and i&lt;=1.2:\n                        new_i = '1'\n                    if i &gt;1.2 and i&lt;=1.8:\n                        new_i = '1-2'\n                    if i &gt;1.8 and i&lt;=2.2:\n                        new_i = '2'\n                    if i &gt;2.2 and i&lt;=2.8:\n                        new_i = '2-3'\n                    if i &gt;2.8 and i&lt;=3.2:\n                        new_i = '3'\n                    if i &gt;3.2 and i&lt;=3.8:\n                        new_i = '3'\n                    if i &gt;3.8 and i&lt;=4.2:\n                        new_i = '4'\n                    if i &gt;4.2 and i&lt;=4.8:\n                        new_i = '4-5'\n                    if i &gt;0.8 and i&lt;=1.2:\n                        new_i = '1'\n                    if i &gt;5.2 and i&lt;=5.8:\n                        new_i = '5-6'\n                    if i &gt;5.8 and i&lt;=6.2:\n                        new_i = '6'\n                    if i &gt;6.2 and i&lt;=6.8:\n                        new_i = '6-7'\n                    if i &gt;6.8 and i&lt;=7.2:\n                        new_i = '7'\n\n                    if math.isnan(i):\n                        pass\n                    else:\n                        simplified_BWSE.append(new_i)\n\n\n                nb_MFT = [x.split('.')[2] for x in metadata_object.loc['meas_id'].values]\n\n                df = pd.DataFrame(data={\n                    #'Description':group_description,\n                    #'Groups': group,\n                    'MFT': nb_MFT,\n                    'BWSE': simplified_BWSE,\n                })\n\n                table_data2 = generate_latex_table(df)\n\n                print(df)\n                print(nb_MFT)\n                print(simplified_BWSE)\n\n\n\n                with open(Path(__file__).parent / 'report_templates' / 'MFT_report_object.tex', 'r') as template_file:\n                    template = template_file.read()\n\n                # Fill in placeholders with actual values\n                filled_template = template.replace('[PROJECTID]',list(set(metadata.loc['project_id'].values))[0])\n                filled_template = filled_template.replace('[OBJECTID]', object_id)\n                filled_template = filled_template.replace('[LABORATORY]', host_institution)\n                filled_template = filled_template.replace('[YOURNAME]', authors)\n                filled_template = filled_template.replace('[TABLE1DATA]', table_data['info_object'])  \n                #filled_template = filled_template.replace('[TABLE_DATA2]', table_data['BWSE'])            \n                filled_template = filled_template.replace('[FIGURE1PATH]', str(figure_paths['figure1']))\n                filled_template = filled_template.replace('[FIGURE2PATH]', str(figure_paths['figure2'])) \n                filled_template = filled_template.replace('[FIGURE3PATH]', str(figure_paths['figure3'])) \n                filled_template = filled_template.replace('% TABLE_DATA2', table_data2)\n\n\n                # Write filled template to .tex file\n                with open('temp_report.tex', 'w') as temp_file:\n                    temp_file.write(filled_template)\n\n                # Compile .tex file into PDF\n                subprocess.run(['pdflatex', 'temp_report.tex'])\n\n                # Move generated PDF to output file                \n                subprocess.run(['mv', 'temp_report.pdf', f'{folder_report}/MFT_rapport-object_{object_id}.pdf'])\n\n                # Clean up temporary .tex and auxiliary files\n                subprocess.run(['rm', 'temp_report.tex', 'temp_report.aux', 'temp_report.log'])\n\n\n\n        if type == 'project':\n\n            all_metadata = self.get_metadata()\n            project_ids = all_metadata.loc['project_id'].values\n            db_projects = get_DB('projects').set_index('project_id')\n            db_users = get_persons().set_index('initials')\n\n\n\n            for project_id in sorted(set(project_ids)):\n\n                metadata = all_metadata.loc[:,all_metadata.loc['project_id'] == project_id]\n                project_info = db_projects.loc[project_id]\n\n                project_leader_initials = project_info['project_leader']\n                project_leader_info = db_users.loc[project_leader_initials]\n                project_leader_name = ' '.join(project_leader_info[['name','surname']].values)\n\n                start_date = project_info['start_date']\n\n                institution = project_info['institution']\n\n                host_institution = metadata.loc['host_institution'].values[0]\n\n\n                keywords = project_info['keywords']\n\n                methods = project_info['methods']\n                if \"_\" in methods:\n                    methods = methods.replace('_','-')\n\n                device = sorted(set(metadata.loc['device'].values))[0]\n                if \"_\" in device:\n                    device = device.replace('_', '-')\n\n                lamp = sorted(set(metadata.loc['lamp_fading'].values))[0]\n                nb_analyses = str(metadata.shape[1])\n                nb_objects = str(len(sorted(set(metadata.loc['object_id'].values))))\n\n\n\n                figure_BWSE_hist = [f'{folder_figures}/{file}' for file in all_figure_files if project_id in file and 'BWSE-hist-report' in file][0]                \n                figure_BWSE_bars = [f'{folder_figures}/{file}' for file in all_figure_files if project_id in file and 'BWSE-bars-report' in file]\n\n                if len(figure_BWSE_hist) == 0:\n                    print(f'The BWSE histogram figure cannot be found in the folder {folder_figures}.')\n                    print(f'Make sure that the filename of the BWSE histogram figure contains the project ID ({project_id}) and the expression \"BWSE-hist-report\".')\n                    return\n\n\n                if len(figure_BWSE_bars) == 0:\n                    print(f'The BWSE bars figure cannot be found in the folder {folder_figures}.')\n                    print(f'Make sure that the filename of the BWSE bars figures contain the project ID ({project_id}) and the expression \"BWSE-bars-report\".')\n                    return\n\n                elif len(figure_BWSE_bars) == 1:\n                    figure_BWSE_bars_01 = figure_BWSE_bars[0]\n\n                elif len(figure_BWSE_bars) == 2:\n                    figure_BWSE_bars_01 = figure_BWSE_bars[0]\n                    figure_BWSE_bars_02 = figure_BWSE_bars[1]\n\n\n\n                info_project = \"\"\"\n                    \\\\textbf{Project id} &amp; [projectId] \\\\\\\\\n                    \\\\textbf{Project leader} &amp; [projectLeader] \\\\\\\\\n                    \\\\textbf{Institution} &amp; [institution] \\\\\\\\   \n                    \\\\textbf{Start date} &amp; [startDate] \\\\\\\\             \n                    \\\\textbf{Keywords} &amp; [keywords] \\\\\\\\\n                    &amp; \\\\\\\\\n                    \\\\textbf{MFT device} &amp; [MFTdevice] \\\\\\\\\n                    \\\\textbf{MFT lamp} &amp; [MFTlamp] \\\\\\\\\n                    \\\\textbf{N\\\\textsuperscript{o} of analyses} &amp; [NbAnalyses] \\\\\\\\\n                    \\\\textbf{N\\\\textsuperscript{o} of objects} &amp; [NbObjects] \\\\\\\\ \n                \"\"\"\n                info_analysis = \"\"\"\n                    \\\\textbf{MFT device} &amp; [MFTdevice] \\\\\\\\\n                    \\\\textbf{N\\\\textsuperscript{o} of analyses} &amp; [NbAnalyses] \\\\\\\\\n                    \\\\textbf{N\\\\textsuperscript{o} of objects} &amp; [NbObjects] \\\\\\\\                \n                \"\"\"\n\n                # define the mapping table\n                mapping_table_project = {\n                    '[projectId]': project_id,\n                    '[projectLeader]': project_leader_name,\n                    '[institution]': institution,                \n                    '[keywords]' : keywords,  \n                    '[methods]' : methods, \n                    '[startDate]' : start_date,\n                    '[MFTdevice]': device,\n                    '[MFTlamp]' : lamp,\n                    '[NbAnalyses]': nb_analyses,\n                    '[NbObjects]': nb_objects,             \n                    }\n                print(mapping_table_project)\n\n                mapping_table_analyses = {\n                    '[MFTdevice]': device,\n                    '[NbAnalyses]': nb_analyses,\n                    '[NbObjects]': nb_objects,                                \n                    }\n\n\n\n                for x in mapping_table_project.keys():\n                    info_project = info_project.replace(x, mapping_table_project[x])    \n\n                for x in mapping_table_analyses.keys():\n                    info_analysis = info_analysis.replace(x, mapping_table_analyses[x])         \n\n\n                table_data = {'info_project': info_project, 'info_analysis': info_analysis}\n\n                if len(figure_BWSE_bars) == 1:                \n                    figure_paths = {\n                        'figure1': figure_BWSE_hist,\n                        'figure2': figure_BWSE_bars_01,\n                        'figure3': ''                    \n                    }\n\n                else: \n                    figure_paths = {\n                        'figure1': figure_BWSE_hist,\n                        'figure2': figure_BWSE_bars_01,  \n                        'figure3': figure_BWSE_bars_02,                  \n                    }\n\n\n                with open(Path(__file__).parent / 'report_templates' / 'MFT_report_project.tex', 'r') as template_file:\n                    template = template_file.read()\n\n                # Fill in placeholders with actual values\n                filled_template = template.replace('[PROJECTID]', project_id)\n                filled_template = filled_template.replace('[INSTITUTION]', host_institution)\n                filled_template = filled_template.replace('[YOURNAME]', authors)\n                filled_template = filled_template.replace('[TABLE1DATA]', table_data['info_project'])\n                #filled_template = filled_template.replace('[TABLE2DATA]', table_data['info_analysis'])\n                filled_template = filled_template.replace('[FIGURE1PATH]', str(figure_paths['figure1']))\n                filled_template = filled_template.replace('[FIGURE2PATH]', str(figure_paths['figure2']))\n\n                if len(figure_BWSE_bars) == 2:                \n                    filled_template = filled_template.replace('[FIGURE3PATH]', str(figure_paths['figure3']))\n\n                # Write filled template to .tex file\n                with open('temp_report.tex', 'w') as temp_file:\n                    temp_file.write(filled_template)\n\n                # Compile .tex file into PDF\n                subprocess.run(['pdflatex', 'temp_report.tex'])\n\n                # Move generated PDF to output file                \n                subprocess.run(['mv', 'temp_report.pdf', f'{folder_report}/MFT_rapport-project_{project_id}.pdf'])                \n\n                # Clean up temporary .tex and auxiliary files\n                subprocess.run(['rm', 'temp_report.tex', 'temp_report.aux', 'temp_report.log'])\n\n\n\n\n\n\n    def make_table(self, parameters:Optional[list] = ['BWSE'], sort_by:Optional[str] = 'meas_id', title:Optional[str] = None, subtitle:Optional[str] = None):\n\n        wanted_parameters = ['meas_id'] + parameters\n\n        df_info = self.get_metadata(wanted_parameters).T.sort_values(by=[sort_by])\n\n        my_table = (\n        GT(df_info)\n        .tab_header(\n            title=title,\n            subtitle=subtitle,            \n        )\n        .tab_style(\n            style=style.text(weight='bold', size='18px'),\n            locations=loc.column_header(),\n        ) \n        .cols_align(align='center')      \n        )\n\n        return my_table\n\n\n    def read_files(self, sheets:Optional[list] = ['info', 'CIELAB', 'spectra']):\n        \"\"\"Read the data files given as argument when defining the instance of the MFT class.\n\n        Parameters\n        ----------\n        sheets : Optional[list], optional\n            Name of the excel sheets to be selected, by default ['info', 'CIELAB', 'spectra']\n\n        Returns\n        -------\n        A list of list of pandas dataframes\n            The content of each input data file is returned as a list pandas dataframes (3 dataframes maximum, one dataframe per sheet). Ultimately, the function returns a list of list, so that when there are several input data files, each list - related a single file - corresponds to a single element of a list.            \n        \"\"\"\n\n        files = []        \n\n        for file in self.files:\n\n            df_info = pd.read_excel(file, sheet_name='info')\n            df_sp = pd.read_excel(file, sheet_name='spectra', header=[0,1], index_col=0)\n            df_cl = pd.read_excel(file, sheet_name='CIELAB', header=[0,1])                      \n\n\n            if sheets == ['info', 'CIELAB', 'spectra']:\n                files.append([df_info, df_cl, df_sp])\n\n            elif sheets == ['info']:\n                files.append([df_info])\n\n            elif sheets == ['CIELAB']:\n                files.append([df_cl])\n\n            elif sheets == ['spectra']:\n                files.append([df_sp])\n\n            elif sheets == ['spectra', 'CIELAB']:\n                files.append([df_sp, df_cl])\n\n            elif sheets == ['CIELAB','spectra']:\n                files.append([df_cl, df_sp])\n\n            elif sheets == ['info','CIELAB']:\n                files.append([df_info, df_cl])\n\n            elif sheets == ['info','spectra']:\n                files.append([df_info, df_sp])\n\n        return files\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_meas_ids","title":"<code>get_meas_ids</code>  <code>property</code>","text":"<p>Return the measurement id numbers corresponding to the input files.</p>"},{"location":"references/#microfading.microfading.MFT.get_objects","title":"<code>get_objects</code>  <code>property</code>","text":"<p>Return the object id numbers corresponding to the input files.</p>"},{"location":"references/#microfading.microfading.MFT.get_wavelength","title":"<code>get_wavelength</code>  <code>property</code>","text":"<p>Return the wavelength range of the microfading measurements.</p>"},{"location":"references/#microfading.microfading.MFT.__init__","title":"<code>__init__(files, BWS=True)</code>","text":"<p>Instantiate a Microfading (MFT) class object in order to manipulate and visualize microfading analysis data.</p>"},{"location":"references/#microfading.microfading.MFT.__init__--parameters","title":"Parameters","text":"<p>files : list     A list of string, where each string corresponds to the absolute path of text or csv file that contains the data and metadata of a single microfading measurement. The content of the file requires a specific structure, for which an example can be found in \"datasets\" folder of the microfading package folder (Use the get_datasets function to retrieve the precise location of such example files). If the file structure is not respected, the script will not be able to properly read the file and access its content.</p> bool, optional <p>When False, it ignores the measurements performed on BWS samples if included.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def __init__(self, files:list, BWS:Optional[bool] = True) -&gt; None:\n    \"\"\"Instantiate a Microfading (MFT) class object in order to manipulate and visualize microfading analysis data.\n\n    Parameters\n    ----------\n    files : list\n        A list of string, where each string corresponds to the absolute path of text or csv file that contains the data and metadata of a single microfading measurement. The content of the file requires a specific structure, for which an example can be found in \"datasets\" folder of the microfading package folder (Use the get_datasets function to retrieve the precise location of such example files). If the file structure is not respected, the script will not be able to properly read the file and access its content.\n\n    BWS : bool, optional\n        When False, it ignores the measurements performed on BWS samples if included. \n\n    \"\"\"\n    self.files = files\n    self.BWS = BWS        \n\n    if self.BWS == False:\n        self.files = [x for x in self.files if 'BW' not in x.name]\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.compute_JND","title":"<code>compute_JND(dose_unit='Hv', JND_dE=1.5, light_intensity=50, daily_exposure=10, yearly_exposure=365, fitting=True)</code>","text":"<p>Compute the just noticeable difference (JND) corresponding to each input data file.</p>"},{"location":"references/#microfading.microfading.MFT.compute_JND--parameters","title":"Parameters","text":"<p>dose_unit : Optional[str], optional     Unit of the light dose energy, by default 'Hv'     Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> float, optional <p>The dE00 value corresponding to one JND, by default 1.5</p> int, optional <p>The illuminance or the irradiance value of the intended light source, by default 50</p> Optional[int], optional <p>Amount of exposure hours per day, by default 10</p> Optional[int], optional <p>Amount of exposure days per year, by default 365</p> bool, optional <p>Whether to fit the microfading data necessary to compute the JND value, by default True</p>"},{"location":"references/#microfading.microfading.MFT.compute_JND--returns","title":"Returns","text":"<p>A list of numerical values as string (uncertainty string with a nominal and standard deviation value)     It returns a list of numerical values corresponding to the amount of years necessary to reach one JND.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def compute_JND(self, dose_unit:Optional[str] = 'Hv', JND_dE = 1.5, light_intensity=50, daily_exposure:Optional[int] = 10, yearly_exposure:Optional[int] = 365, fitting = True):\n    \"\"\"Compute the just noticeable difference (JND) corresponding to each input data file.\n\n    Parameters\n    ----------\n    dose_unit : Optional[str], optional\n        Unit of the light dose energy, by default 'Hv'\n        Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    JND_dE : float, optional\n        The dE00 value corresponding to one JND, by default 1.5\n\n    light_intensity : int, optional\n        The illuminance or the irradiance value of the intended light source, by default 50\n\n    daily_exposure : Optional[int], optional\n        Amount of exposure hours per day, by default 10\n\n    yearly_exposure : Optional[int], optional\n        Amount of exposure days per year, by default 365\n\n    fitting : bool, optional\n        Whether to fit the microfading data necessary to compute the JND value, by default True\n\n    Returns\n    -------\n    A list of numerical values as string (uncertainty string with a nominal and standard deviation value)\n        It returns a list of numerical values corresponding to the amount of years necessary to reach one JND. \n    \"\"\"\n\n    H_step = 0.01\n    dE_fitted = self.compute_fitting(dose_unit='Hv', x_range=(0,5.1,H_step), return_data=True, plot=False)[1]\n    dE_rate = np.gradient(dE_fitted.T.values, H_step, axis=1)\n    dE_rate_mean = [np.mean(x[-20:]) for x in dE_rate]\n    dE_rate_std = [np.std(x[-20:]) for x in dE_rate]\n\n    rates = [ufloat(x, y) for x,y in zip(dE_rate_mean, dE_rate_std)]\n\n    times_years = []\n\n    for rate in rates:\n\n        if dose_unit == 'Hv':\n\n            JND_dose = (JND_dE / rate) * 1e6                     # in lxh\n            time_hours = JND_dose / light_intensity\n            time_years = time_hours / (daily_exposure * yearly_exposure)            \n\n        if dose_unit == 'He':\n            JND_dose = (JND_dE / rate) * 1e6                     # in J/m\u00b2\n            time_sec = JND_dose / light_intensity\n            time_hours = time_sec / 3600\n            time_years = time_hours / (daily_exposure * yearly_exposure)\n\n        times_years.append(time_years)\n\n    return times_years\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.compute_delta","title":"<code>compute_delta(coordinates=['dE00'], dose_unit='He', dose_values='all', derivation=False)</code>","text":"<p>Retrieve the CIE delta values for a given set of colorimetric coordinates corresponding to the given microfading analyses.</p>"},{"location":"references/#microfading.microfading.MFT.compute_delta--parameters","title":"Parameters","text":"<p>coordinates : list, optional     List of colorimetric coordinates, by default ['dE00']     Any of the following coordinates can be added to the list: 'dE76', 'dE00', 'dR_vis' , 'L', 'a', 'b', 'C', 'h'.</p> str, optional <p>Define the light energy dose, by default 'He' Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> Union[int, float, list, tuple], optional <p>Dose values for which the colourimetric values will be returned, by default 'all' When 'all', it returns the colourimetric values for all the dose values available in the given input data files. A single dose value (an integer or a float number) can be entered. A list of dose values, as integer or float, can also be entered. A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. </p> bool, optional <p>Whether to return the first derivative values of the desired coordinates, by default False</p>"},{"location":"references/#microfading.microfading.MFT.compute_delta--returns","title":"Returns","text":"<p>A list of pandas dataframes     It returns a a list of pandas dataframes where each column corresponds to a light energy dose or a desired coordinate.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def compute_delta(self, coordinates:Optional[list] = ['dE00'], dose_unit:Optional[list] = 'He', dose_values:Union[int, float, list, tuple] = 'all', derivation:Optional[bool] = False):\n    \"\"\"Retrieve the CIE delta values for a given set of colorimetric coordinates corresponding to the given microfading analyses.\n\n    Parameters\n    ----------\n    coordinates : list, optional\n        List of colorimetric coordinates, by default ['dE00']\n        Any of the following coordinates can be added to the list: 'dE76', 'dE00', 'dR_vis' , 'L*', 'a*', 'b*', 'C*', 'h'.\n\n    dose_unit : str, optional\n        Define the light energy dose, by default 'He'\n        Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    dose_values : Union[int, float, list, tuple], optional\n        Dose values for which the colourimetric values will be returned, by default 'all'\n        When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n        A single dose value (an integer or a float number) can be entered.\n        A list of dose values, as integer or float, can also be entered.\n        A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n    derivation : bool, optional\n        Whether to return the first derivative values of the desired coordinates, by default False\n\n    Returns\n    -------\n    A list of pandas dataframes\n        It returns a a list of pandas dataframes where each column corresponds to a light energy dose or a desired coordinate.\n    \"\"\"          \n\n    # Retrieve the data        \n    cielab_data = self.read_files(sheets=['CIELAB'])\n    cielab_data = [x[0] for x in cielab_data]       \n\n    # Rename the LabCh coordinates to dL*, da*, db*, dC*, dh\n    coordinates = [f'd{x}' if x in ['L*','a*','b*','C*','h'] else x for x in coordinates]\n\n    # Compute the delta values\n    deltas = self.get_cielab(coordinates=coordinates, dose_unit=dose_unit, dose_values=dose_values)\n\n    # Whether to compute the first derivation \n    if derivation:\n        deltas = [pd.DataFrame(np.gradient(x.T.values, x.index, axis=1).T, columns=x.columns, index=x.index) for x in deltas]\n\n    return deltas     \n</code></pre>"},{"location":"references/#microfading.microfading.MFT.compute_fitting","title":"<code>compute_fitting(plot=True, return_data=False, dose_unit='Hv', coordinate='dE00', equation='power_3p', initial_params='auto', bounds=(-np.inf, np.inf), x_range=(0, 5.1, 0.1), save=False, path_fig='cwd')</code>","text":"<p>Fit the values of a given colourimetric coordinates. </p>"},{"location":"references/#microfading.microfading.MFT.compute_fitting--parameters","title":"Parameters","text":"<p>plot : bool, optional     Whether to show the fitted data, by default True</p> bool, optional <p>Whether to return the fitted data, by default False</p> string, optional <p>Unit of the light energy dose, by default 'He' Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> string, optional <p>Select the desired colourimetric coordinate from the following list: ['L', 'a','b', 'C', 'h', 'dL', 'da','db', 'dC', 'dh', 'dE76', 'dE00', 'dR_vis'], by default 'dE00'</p> str, optional <p>Mathematical equation used to fit the coordinate values, by default 'c0(xc1)'. Any others mathematical can be given. The following equation is often relevant for fitting microfading data: '((x) / (c0 + (c1x))) + c2'.</p> Optional[List[float]], optional <p>Initial guesses of the 'c' parameters given in the equation (c0, c1, c2, etc.), by default [0.1, 0.0]</p> Optional[Tuple[int]], optional <p>Values along which the fitted values should be computed (start, end, step), by default (0, 1001, 1)</p> Optional[bool], optional <p>Whether to save the plot, by default False</p> Optional[str], optional <p>Absolute path of the figure to be saved, by default 'default'</p>"},{"location":"references/#microfading.microfading.MFT.compute_fitting--returns","title":"Returns","text":"<p>Union[None, Tuple[np.ndarray, np.ndarray]]     description</p> Source code in <code>microfading/microfading.py</code> <pre><code>def compute_fitting(self, plot:Optional[bool] = True, return_data:Optional[bool] = False, dose_unit:Optional[str] = 'Hv', coordinate:Optional[str] = 'dE00', equation:Optional[str] = 'power_3p', initial_params:Optional[List[float]] = 'auto', bounds:Optional[list] = (-np.inf, np.inf), x_range:Optional[Tuple[int]] = (0,5.1,0.1), save: Optional[bool] = False, path_fig: Optional[str] = 'cwd') -&gt; Union[None, Tuple[np.ndarray, np.ndarray]]:\n    \"\"\"Fit the values of a given colourimetric coordinates. \n\n    Parameters\n    ----------\n    plot : bool, optional\n        Whether to show the fitted data, by default True\n\n    return_data : bool, optional\n        Whether to return the fitted data, by default False\n\n    dose_unit : string, optional\n        Unit of the light energy dose, by default 'He'\n        Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    coordinate : string, optional\n        Select the desired colourimetric coordinate from the following list: ['L*', 'a*','b*', 'C*', 'h', 'dL*', 'da*','db*', 'dC*', 'dh', 'dE76', 'dE00', 'dR_vis'], by default 'dE00'\n\n    equation : str, optional\n        Mathematical equation used to fit the coordinate values, by default 'c0*(x**c1)'.\n        Any others mathematical can be given. The following equation is often relevant for fitting microfading data: '((x) / (c0 + (c1*x))) + c2'.\n\n    initial_params : Optional[List[float]], optional\n        Initial guesses of the 'c' parameters given in the equation (c0, c1, c2, etc.), by default [0.1, 0.0]\n\n    x_range : Optional[Tuple[int]], optional\n        Values along which the fitted values should be computed (start, end, step), by default (0, 1001, 1)\n\n    save : Optional[bool], optional\n        Whether to save the plot, by default False\n\n    path_fig : Optional[str], optional\n        Absolute path of the figure to be saved, by default 'default'\n\n    Returns\n    -------\n    Union[None, Tuple[np.ndarray, np.ndarray]]\n        _description_\n    \"\"\"\n\n    # Retrieve the range light dose values\n    doses = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't': 't_sec'}  \n    x_model = np.arange(*x_range)\n\n    # Retrieve the data        \n    all_data = []\n\n    for data in self.get_data(data='cl'):\n        if 'mean' in data.columns.get_level_values(1):\n            cl_mean_data = data.xs(key='mean', axis=1, level=1)  # the mean colorimetric data\n            doses_data = data.xs(key='value', axis=1, level=1)   # the light energy data\n\n            all_data.append(pd.concat([doses_data, cl_mean_data], axis=1))\n\n        else:\n            all_data.append(data.xs(key='value', axis=1, level=1))                \n\n    # Added the delta LabCh values to the data dataframes\n    coordinates = ['L*', 'a*', 'b*', 'C*', 'h']\n    data = [d.assign(**{f'd{coord}': d[coord] - d[coord].values[0] for coord in coordinates}) for d in all_data]\n\n    # Select the wanted dose_unit and coordinate\n    selected_data = [x[[doses[dose_unit], coordinate]] for x in data]\n    selected_data = [x.set_index(x.columns[0]) for x in selected_data]\n\n    # Define the fitting equation and bounds\n    config_functions = get_DB_config()['functions']\n    existing_equations = list(config_functions.keys())\n\n    if equation in existing_equations:\n        bounds = eval(config_functions[equation]['bounds'])\n        equation = config_functions[equation]['expression']           \n\n    # Define the function to fit\n    def fit_function(x, *params):\n        param_dict = {f'c{i}': param for i, param in enumerate(params)}\n        param_dict['x'] = x\n        return eval(equation, globals(), param_dict)        \n\n    # Create an empty dataframe for the fitted data\n    fitted_data = pd.DataFrame(index=pd.Series(x_model))\n\n    # Empty list to store the labels\n    fitted_labels = []\n\n    # Emtpy list to store the optimized parameters\n    fitted_parameters = []\n\n    if initial_params == 'auto':\n        initial_params = ['auto']\n\n    initial_params = initial_params * len(self.files)\n\n\n    for d, p in zip(selected_data,initial_params):\n\n        # retrieve the x(light dose) and y(coordinate) values\n        x_data, y_data = d.index, d.iloc[:,0].values\n\n        # estimate the initial parameters\n        if p == 'auto':  \n\n            y_diff = y_data[-1] - y_data[0]\n\n            if equation == \"c0*x\":\n                if y_diff &lt; 0:\n                    p = [-0.1]\n                elif y_diff &gt; 0:\n                    p = [0.1]\n                elif y_diff == 0:\n                    p  = [0]\n\n            elif equation == \"c0*x+c1\":                    \n\n                if y_diff &lt; 0:\n                    c0 = -0.1\n                elif y_diff &gt; 0:\n                    c0 = 0.1\n                elif y_diff == 0:\n                    c0  = 0\n\n                c1 = y_data[0]\n                p = [c0,c1]\n\n            elif equation == \"c0*(x**c1)\":                    \n\n                if y_diff &lt; 0:\n                    c0 = -0.1\n                elif y_diff &gt; 0:\n                    c0 = 0.1\n                elif y_diff == 0:\n                    c0  = 0\n\n                p = [c0,0.1]\n\n            elif equation == \"c0*(x**c1)+c2\":                    \n\n                if y_diff &lt; 0:\n                    c0 = -0.1\n                elif y_diff &gt; 0:\n                    c0 = 0.1\n                elif y_diff == 0:\n                    c0  = 0\n\n                c2 = y_data[0]\n                p = [c0,0.1,c2]\n\n\n            elif equation == \"(c0/(1+np.exp(c1*x)))\":                    \n\n                if y_diff &lt; 0:\n                    c0 = -0.1\n                elif y_diff &gt; 0:\n                    c0 = 0.1\n                elif y_diff == 0:\n                    c0  = 0\n\n                p = [c0,-0.1]\n\n\n            elif equation == \"(c0/(1+np.exp(c1*x)))+c2\":                    \n\n                if y_diff &lt; 0:\n                    c0 = -0.1\n                elif y_diff &gt; 0:\n                    c0 = 0.1\n                elif y_diff == 0:\n                    c0  = 0                    \n\n                c2 = y_data[0]\n                p = [c0,-0.1,c2]\n\n\n        # perform the curve fitting, return the optimized parameters (popt) and the covariance matrix (pcov)\n        popt, pcov = curve_fit(fit_function, x_data, y_data, p0=p, bounds=bounds)\n\n        # generate fitted y data\n        fitted_y = fit_function(x_model, *popt)\n\n        # append it to the fitted_data dataframe\n        fitted_data = pd.concat([fitted_data, pd.DataFrame(fitted_y, index=pd.Series(x_model))], axis=1)\n\n        # Calculate R-squared value\n        residuals = y_data - fit_function(x_data, *popt)\n        ss_res, ss_tot = np.sum(residuals**2), np.sum((y_data - np.mean(y_data))**2)        \n        r_squared = np.round(1 - (ss_res / ss_tot), 3)\n\n        # Create a string representation of the equation with optimized parameters\n        optimized_equation = equation\n        for i, param in enumerate(popt):\n            optimized_equation = optimized_equation.replace(f'c{i}', str(np.round(param,2)))\n\n        fitted_labels.append(f'{optimized_equation}, $R^2$ = {r_squared}')\n        fitted_parameters.append(popt)\n\n    fitted_data.columns = [f'{x.split(\".\")[-1]}, $y$ = {y}' for x,y in zip(self.get_meas_ids, fitted_labels)]         \n\n    # Plot the data\n    if plot:            \n\n        labels_H = {\n            'Hv': 'Exposure dose $H_v$ (Mlxh)',\n            'He': 'Radiant Exposure $H_e$ (MJ/m\u00b2)',\n            't' : 'Exposure duration (seconds)'\n        }\n\n        sns.set_theme(context='paper', font='serif', palette='colorblind')\n        fig, ax = plt.subplots(1,1, figsize=(10,6))\n        fs = 24\n\n\n        pd.concat(selected_data, axis=1).plot(ax=ax, color='0.7', ls='-', lw=5, legend=False)\n        fitted_data.plot(ax=ax, lw=2, ls='--')\n\n        ax.set_xlabel(labels_H[dose_unit], fontsize=fs)\n        ax.set_ylabel(labels_eq[coordinate],fontsize=fs)\n\n        ax.set_xlim(0)    \n\n        ax.xaxis.set_tick_params(labelsize=fs)\n        ax.yaxis.set_tick_params(labelsize=fs)   \n\n        plt.tight_layout()    \n\n\n        # Whether to save the figure\n        if save:\n\n            filename = f'MFT_{coordinate}-fitted.png'\n\n            if save:      \n\n                if path_fig == 'cwd':\n                    path_fig = f'{os.getcwd()}/{filename}' \n\n                plt.savefig(path_fig, dpi=300, facecolor='white')\n\n        plt.show()\n\n    if return_data:\n        return fitted_parameters, fitted_data, pcov, r_squared   \n</code></pre>"},{"location":"references/#microfading.microfading.MFT.compute_mean","title":"<code>compute_mean(return_data=True, criterion='spot_group', dose_unit='He', save=False, folder='.', filename='default')</code>","text":"<p>Compute mean and standard deviation values of several microfading measurements.</p>"},{"location":"references/#microfading.microfading.MFT.compute_mean--parameters","title":"Parameters","text":"<p>return_data : Optional[bool], optional     Whether to return the data, by default True        </p> Optional[str], optional <p>description, by default 'group'            </p> Optional[bool], optional <p>Whether to save the average data as an excel file, by default False</p> Optional[str], optional <p>Folder where the excel file will be saved, by default 'default' When 'default', the file will be saved in the same folder as the input files When '.', the file will be saved in the current working directory One can also enter a valid path as a string.</p> Optional[str], optional <p>Filename of the excel file containing the average values, by default 'default' When 'default', it will use the filename of the first input file One can also enter a filename, but without a filename extension.</p>"},{"location":"references/#microfading.microfading.MFT.compute_mean--returns","title":"Returns","text":"<p>tuple, excel file     It returns a tuple composed of three elements (info, CIELAB data, spectral data). When 'save' is set to True, an excel is created to stored the tuple inside three distinct excel sheet (info, CIELAB, spectra).</p>"},{"location":"references/#microfading.microfading.MFT.compute_mean--raises","title":"Raises","text":"<p>RuntimeError     description</p> Source code in <code>microfading/microfading.py</code> <pre><code>def compute_mean(self, return_data:Optional[bool] = True, criterion:Optional[str] = 'spot_group', dose_unit:Optional[str] = 'He', save:Optional[bool] = False, folder:Optional[str] = '.', filename:Optional[str] = 'default'):\n    \"\"\"Compute mean and standard deviation values of several microfading measurements.\n\n    Parameters\n    ----------\n    return_data : Optional[bool], optional\n        Whether to return the data, by default True        \n\n    criterion : Optional[str], optional\n        _description_, by default 'group'            \n\n    save : Optional[bool], optional\n        Whether to save the average data as an excel file, by default False\n\n    folder : Optional[str], optional\n        Folder where the excel file will be saved, by default 'default'\n        When 'default', the file will be saved in the same folder as the input files\n        When '.', the file will be saved in the current working directory\n        One can also enter a valid path as a string.\n\n    filename : Optional[str], optional\n        Filename of the excel file containing the average values, by default 'default'\n        When 'default', it will use the filename of the first input file\n        One can also enter a filename, but without a filename extension.\n\n    Returns\n    -------\n    tuple, excel file\n        It returns a tuple composed of three elements (info, CIELAB data, spectral data). When 'save' is set to True, an excel is created to stored the tuple inside three distinct excel sheet (info, CIELAB, spectra).\n\n    Raises\n    ------\n    RuntimeError\n        _description_\n    \"\"\"\n\n    if len(self.files) &lt; 2:        \n        raise RuntimeError('Not enough files. At least two measurement files are required to compute the average values.')\n\n\n    def mean_std_with_nan(arrays):\n        '''Compute the mean of several numpy arrays of different shapes.'''\n\n        # Find the maximum shape\n        max_shape = np.max([arr.shape for arr in arrays], axis=0)\n\n        # Create arrays with NaN values\n        nan_arrays = [np.full(max_shape, np.nan) for _ in range(len(arrays))]\n\n        # Fill NaN arrays with actual values\n        for i, arr in enumerate(arrays):\n            nan_arrays[i][:arr.shape[0], :arr.shape[1]] = arr\n\n        # Calculate mean\n        mean_array = np.nanmean(np.stack(nan_arrays), axis=0)\n\n        # Calculate std\n        std_array = np.nanstd(np.stack(nan_arrays), axis=0)\n\n        return mean_array, std_array\n\n\n    def to_float(x):\n        try:\n            return float(x)\n        except ValueError:\n            return x\n\n\n    ###### SPECTRAL DATA #######\n\n    data_sp = self.get_data(data='sp')\n\n    # Get the energy dose step\n    #H_values = [x.columns.astype(float) for x in data_sp]       \n    H_values = [x.values.flatten() for x in self.get_doses(dose_unit=dose_unit)]\n    step_H = sorted(set([x[2] - x[1] for x in H_values]))[0]\n    highest_He = np.max([x[-1] for x in H_values])\n\n    # Average the spectral data\n    sp = mean_std_with_nan(data_sp)\n    sp_mean = sp[0]\n    sp_std = sp[1] \n\n\n    # Wanted energy dose values          \n    wanted_H = np.round(np.arange(0,highest_He+step_H,step_H),2)  \n\n    if len(wanted_H) != sp_mean.shape[1]:            \n        wanted_H = np.linspace(0,highest_He,sp_mean.shape[1])\n\n    # Retrieve the wavelength range\n    wl = self.get_wavelength.iloc[:,0]\n\n\n    # Create a multi-index pandas DataFrame\n    doses_dict = {'He': 'He_MJ/m2', 'Hv': 'Hv_Mlxh', 't': 't_sec'}\n    H_tuples = [(dose, measurement) for dose in wanted_H for measurement in ['mean', 'std']]\n    multiindex_cols = pd.MultiIndex.from_tuples(H_tuples, names=[doses_dict[dose_unit], 'Measurement'])\n\n    data_df_sp = np.empty((len(wl), len(wanted_H) * 2))       \n    data_df_sp[:, 0::2] = sp_mean\n    data_df_sp[:, 1::2] = sp_std\n    df_sp_final = pd.DataFrame(data_df_sp,columns=multiindex_cols, index=wl)\n    df_sp_final.index.name = 'wavelength_nm'\n\n\n\n    ###### COLORIMETRIC DATA #######\n\n    data_cl = self.get_data(data='cl')\n    columns_cl = data_cl[0].columns.get_level_values(0)\n\n    # Average the colorimetric data    \n    cl = mean_std_with_nan(data_cl)\n    cl_mean = cl[0]\n    cl_std = cl[1]\n\n    # Create a multi-index pandas DataFrame\n    cl_tuples = [(x, measurement) for x in data_cl[0].columns.get_level_values(0) for measurement in ['mean', 'std']]\n    multiindex_cols = pd.MultiIndex.from_tuples(cl_tuples, names=['coordinates', 'Measurement'])\n\n    data_df_cl = np.empty((cl_mean.shape[0], cl_mean.shape[1] * 2))       \n    data_df_cl[:, 0::2] = cl_mean\n    data_df_cl[:, 1::2] = cl_std\n    df_cl_final = pd.DataFrame(data_df_cl,columns=multiindex_cols, )\n\n    df_cl_final.drop([('He_MJ/m2','std'), ('Hv_Mlxh','std'), ('t_sec','std')], axis=1, inplace=True)\n\n    mapper = {('He_MJ/m2', 'mean'): ('He_MJ/m2', 'value'), ('Hv_Mlxh', 'mean'): ('Hv_Mlxh', 'value'), ('t_sec', 'mean'): ('t_sec', 'value')}\n    df_cl_final.columns = pd.MultiIndex.from_tuples([mapper.get(x, x) for x in df_cl_final.columns])\n\n\n    cl_cols = df_cl_final.columns\n    cl_cols_level1 = [x[0] for x in cl_cols]\n    cl_cols_level2 = [x[1] for x in cl_cols]\n    df_cl_final.columns = np.arange(0,df_cl_final.shape[1])\n\n    df_cl_final = pd.concat([pd.DataFrame(data=np.array([cl_cols_level2])), df_cl_final])\n    df_cl_final.columns = cl_cols_level1\n    df_cl_final = df_cl_final.set_index(df_cl_final.columns[0])\n\n\n    ###### INFO #######\n\n    data_info = self.get_metadata().fillna('none')\n\n    # Select the first column as a template\n    df_info = data_info.iloc[:,0]\n\n\n    # Rename title file\n    df_info.rename({'[SINGLE MICROFADING ANALYSIS]': '[MEAN MICROFADING ANALYSES]'}, inplace=True)\n\n    # Date time\n    most_recent_dt = max(data_info.loc['date_time'])\n    df_info.loc['date_time'] = most_recent_dt\n\n    # Project data info\n    df_info.loc['project_id'] = '_'.join(sorted(set(data_info.loc['project_id'].values)))\n    df_info.loc['project_leader'] = '_'.join(sorted(set(data_info.loc['project_leader'].values)))\n    df_info.loc['co-researchers'] = '_'.join(sorted(set(data_info.loc['co-researchers'].values)))\n    df_info.loc['start_date'] = '_'.join(sorted(set(data_info.loc['start_date'].values)))\n    df_info.loc['end_date'] = '_'.join(sorted(set(data_info.loc['end_date'].values)))\n    df_info.loc['keywords'] = '_'.join(sorted(set(data_info.loc['keywords'].values)))\n\n    # Object data info\n    if len(set([x.split('_')[0] for x in data_info.loc['institution'].values])) &gt; 1:\n        df_info.loc['institution'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['institution'].values])))\n\n    df_info.loc['object_id'] = '_'.join(sorted(set(data_info.loc['object_id'].values)))\n    df_info.loc['object_category'] = '_'.join(sorted(set(data_info.loc['object_category'].values)))\n    df_info.loc['object_type'] = '_'.join(sorted(set(data_info.loc['object_type'].values)))\n    df_info.loc['object_technique'] = '_'.join(sorted(set(data_info.loc['object_technique'].values)))\n    df_info.loc['object_title'] = '_'.join(sorted(set(data_info.loc['object_title'].values)))\n    df_info.loc['object_name'] = '_'.join(sorted(set(data_info.loc['object_name'].values)))\n    df_info.loc['object_creator'] = '_'.join(sorted(set(data_info.loc['object_creator'].values)))\n    df_info.loc['object_date'] = '_'.join(sorted(set(data_info.loc['object_date'].values)))\n    df_info.loc['object_material'] = '_'.join(sorted(set(data_info.loc['object_material'].values)))\n    df_info.loc['color'] = '_'.join(sorted(set(data_info.loc['color'].values)))\n    df_info.loc['colorants'] = '_'.join(sorted(set(data_info.loc['colorants'].values)))\n    df_info.loc['colorants_name'] = '_'.join(sorted(set(data_info.loc['colorants_name'].values)))\n    df_info.loc['binding'] = '_'.join(sorted(set(data_info.loc['binding'].values)))\n    df_info.loc['ratio'] = '_'.join(sorted(set(data_info.loc['ratio'].values)))\n    df_info.loc['thickness_um'] = '_'.join(sorted(set(data_info.loc['thickness_um'].values)))\n    df_info.loc['status'] = '_'.join(sorted(set(data_info.loc['status'].values)))\n\n    # Device data info\n    if len(set(data_info.loc['device'].values)) &gt; 1:\n        df_info.loc['device'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['device'].values])))\n\n    df_info.loc['measurement_mode'] = '_'.join(sorted(set(data_info.loc['measurement_mode'].values)))\n    df_info.loc['zoom'] = '_'.join(sorted(set(data_info.loc['zoom'].values)))\n    df_info.loc['iris'] =  '_'.join(set([str(x) if f'{x}'.isnumeric() else x for x in list(data_info.loc['iris'].values)]))\n    df_info.loc['geometry'] = '_'.join(sorted(set(data_info.loc['geometry'].values)))\n    df_info.loc['distance_ill_mm'] = '_'.join(set([str(x) if f'{x}'.isnumeric() else x for x in list(data_info.loc['distance_ill_mm'].values)]))\n    df_info.loc['distance_coll_mm'] = '_'.join(set([str(x) if f'{x}'.isnumeric() else x for x in list(data_info.loc['distance_coll_mm'].values)]))\n\n\n    if len(set(data_info.loc['fiber_fading'].values)) &gt; 1:\n        df_info.loc['fiber_fading'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['fiber_fading'].values])))\n\n    if len(set(data_info.loc['fiber_ill'].values)) &gt; 1:\n        df_info.loc['fiber_ill'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['fiber_ill'].values])))\n\n    if len(set(data_info.loc['fiber_coll'].values)) &gt; 1:\n        df_info.loc['fiber_coll'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['fiber_coll'].values])))\n\n    if len(set(data_info.loc['lamp_fading'].values)) &gt; 1:\n        df_info.loc['lamp_fading'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['lamp_fading'].values])))\n\n    if len(set(data_info.loc['lamp_ill'].values)) &gt; 1:\n        df_info.loc['lamp_ill'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['lamp_ill'].values])))\n\n    if len(set(data_info.loc['filter_fading'].values)) &gt; 1:\n        df_info.loc['filter_fading'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['filter_fading'].values])))\n\n    if len(set(data_info.loc['filter_ill'].values)) &gt; 1:\n        df_info.loc['filter_ill'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['filter_ill'].values])))\n\n    if len(set(data_info.loc['white_standard'].values)) &gt; 1:\n        df_info.loc['white_standard'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['white_standard'].values])))\n\n\n    # Analysis data info\n\n    criterion_value = df_info.loc[criterion]\n    object_id = df_info.loc['object_id']\n    if criterion == 'group':            \n        df_info.loc['meas_id'] = f'MF.{object_id}.{criterion_value}'\n    elif criterion == 'object' or criterion == 'project':\n         df_info.loc['meas_id'] = f'MF.{criterion_value}'\n    else:\n        print('Choose one of the following options for the criterion parameter: [\"group\", \"object\", \"project\"]')\n\n    meas_nbs = '-'.join([x.split('.')[-1] for x in self.get_meas_ids])\n    df_info.loc['spot_group'] = f'{\"-\".join(sorted(set(data_info.loc[\"spot_group\"].values)))}_{meas_nbs}'    \n    df_info.loc['spot_description'] = '_'.join(sorted(set(data_info.loc['spot_description'].values)))\n    df_info.loc['background'] = '_'.join(sorted(set(data_info.loc['background'].values)))  \n\n    if len(set(data_info.loc['specular_component'].values)) &gt; 1:\n        df_info.loc['specular_component'] = '_'.join(sorted(set([x.split('_')[0] for x in data_info.loc['specular_component'].values]))) \n\n\n    df_info.loc['integration_time_sample_ms'] = np.round(np.mean(data_info.loc['integration_time_sample_ms'].astype(float).values),1)\n    df_info.loc['integration_time_whitestandard_ms'] = np.round(np.mean(data_info.loc['integration_time_whitestandard_ms'].astype(float).values),1)\n    df_info.loc['average'] = '_'.join([str(x) for x in sorted(set(data_info.loc['average'].astype(str).values))]) \n    df_info.loc['duration_min'] = np.round(np.mean(data_info.loc['duration_min'].values),1)\n    df_info.loc['interval_sec'] = '_'.join([str(x) for x in sorted(set(data_info.loc['interval_sec'].values))])\n    df_info.loc['measurements_N'] = '_'.join([str(x) for x in sorted(set(data_info.loc['measurements_N'].astype(str).values))])\n    df_info.loc['illuminant'] = '_'.join(sorted(set(data_info.loc['illuminant'].values)))\n    df_info.loc['observer'] = '_'.join(sorted(set(data_info.loc['observer'].values)))\n\n\n    # Beam data info\n\n    df_info.loc['beam_photo'] = '_'.join(sorted(set(data_info.loc['beam_photo'].values)))\n    df_info.loc['resolution_micron/pixel'] = '_'.join(set([str(x) if f'{x}'.isnumeric() else x for x in list(data_info.loc['resolution_micron/pixel'].values)]))\n\n    fwhm = data_info.loc['FWHM_micron']\n    fwhm_avg = np.mean([i for i in [to_float(x) for x in fwhm] if isinstance(i, (int, float))])\n    df_info.loc['FWHM_micron'] = fwhm_avg\n\n    power_infos = data_info.loc['radiantFlux_mW'].values\n    power_values = []\n\n    for power_info in power_infos:\n        if \"_\" in str(power_info):\n            power_value = ufloat_fromstr(power_info.split('_')[0])\n            power_values.append(power_value)                            \n\n        else: \n            power_values.append(power_info)               \n\n    power_mean = np.round(np.mean(power_values),3)\n    power_std = np.round(np.std(power_values),3)\n    df_info.loc['radiantFlux_mW'] = f'{ufloat(power_mean,power_std)}'    \n\n\n    irr_values = [str(ufloat(x,0)) if isinstance(x, int) else x for x in data_info.loc['irradiance_Ee_W/m^2'] ] \n    irr_mean = np.int32(np.mean([unumpy.nominal_values(ufloat_fromstr(x)) for x in irr_values]))\n    irr_std = np.int32(np.std([unumpy.nominal_values(ufloat_fromstr(x)) for x in irr_values]))\n    irr_avg = ufloat(irr_mean, irr_std)    \n    df_info.loc['irradiance_Ee_W/m^2'] = irr_avg\n\n    lm = [x for x in data_info.loc['luminuousFlux_lm'].values]\n    lm_avg = np.round(np.mean(lm),3)\n    df_info.loc['luminuousFlux_lm'] = lm_avg\n\n    ill = [x for x in data_info.loc['illuminance_Ev_Mlx']]\n    ill_avg = np.round(np.mean(ill),3)\n    df_info.loc['illuminance_Ev_Mlx'] = ill_avg\n\n\n    # Results data info\n    df_info.loc['radiantExposure_He_MJ/m^2'] = df_cl_final.index.values[-1]\n    df_info.loc['exposureDose_Hv_Mlxh'] = np.round(df_cl_final['Hv_Mlxh'].values[-1],4)\n\n\n    # Rename the column\n    df_info.name = 'value'\n\n\n    ###### SAVE THE MEAN DATAFRAMES #######\n\n    if save:  \n\n        # set the folder\n        if folder == \".\":\n            folder = Path('.')  \n\n        elif folder == 'default':\n            folder = Path(self.files[0]).parent\n\n        else:\n            if Path(folder).exists():\n                folder = Path(folder)         \n\n        # set the filename\n        if filename == 'default':\n            filename = f'{Path(self.files[0]).stem}_MEAN{Path(self.files[0]).suffix}'\n\n        else:\n            filename = f'{filename}.xlsx'\n\n\n        # create a excel writer object\n        with pd.ExcelWriter(folder / filename) as writer:\n\n            df_info.to_excel(writer, sheet_name='info', index=True)\n            df_cl_final.to_excel(writer, sheet_name=\"CIELAB\", index=True)\n            df_sp_final.to_excel(writer, sheet_name='spectra', index=True)\n\n        print(f'{folder / filename} successfully created.')\n\n\n    ###### RETURN THE MEAN DATAFRAMES #######\n\n    if return_data:\n        return df_info, df_cl_final, df_sp_final\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.compute_sp_derivate","title":"<code>compute_sp_derivate()</code>","text":"<p>Compute the first derivative values of reflectance spectra.</p>"},{"location":"references/#microfading.microfading.MFT.compute_sp_derivate--returns","title":"Returns","text":"<p>a list of pandas dataframes     It returns the first derivative values of the reflectance spectra inside dataframes where each column corresponds to a single spectra.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def compute_sp_derivate(self):\n    \"\"\"Compute the first derivative values of reflectance spectra.\n\n    Returns\n    -------\n    a list of pandas dataframes\n        It returns the first derivative values of the reflectance spectra inside dataframes where each column corresponds to a single spectra.\n    \"\"\"\n\n    sp = self.get_data(data='sp')                    \n\n    sp_derivation = [pd.DataFrame(pd.concat([pd.DataFrame(np.gradient(x.iloc[:,:], axis=0), index=pd.Series(x.index), columns=x.columns)], axis=1),index=pd.Series(x.index), columns=x.columns) for x in sp]\n\n    return sp_derivation\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_Lab","title":"<code>get_Lab(illuminant='default', observer='default', dose_unit='He', dose_values='all')</code>","text":"<p>Retrieve the CIE Lab* values.</p>"},{"location":"references/#microfading.microfading.MFT.get_Lab--parameters","title":"Parameters","text":"<p>illuminant : (str, optional)     Reference illuminant ('D65', or 'D50'). by default 'default'.     When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.</p> (str|int, optional) <p>Reference observer in degree ('10' or '2'). by default 'default'. When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.</p> Optional[str], optional <p>Unit of the light dose energy, by default ['He'] Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> Union[int, float, list, tuple], optional <p>Dose values for which the colourimetric values will be returned, by default 'all' When 'all', it returns the colourimetric values for all the dose values available in the given input data files. A single dose value (an integer or a float number) can be entered. A list of dose values, as integer or float, can also be entered. A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. </p>"},{"location":"references/#microfading.microfading.MFT.get_Lab--returns","title":"Returns","text":"<p>pandas dataframe     It returns the Lab* values inside a dataframe where each column corresponds to a single file.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_Lab(self, illuminant:Optional[str] = 'default', observer:Optional[str] = 'default', dose_unit: Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all'):\n    \"\"\"\n    Retrieve the CIE L*a*b* values.\n\n    Parameters\n    ----------\n    illuminant : (str, optional)  \n        Reference *illuminant* ('D65', or 'D50'). by default 'default'.\n        When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.\n\n    observer : (str|int, optional)\n        Reference *observer* in degree ('10' or '2'). by default 'default'.\n        When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.\n\n    dose_unit : Optional[str], optional\n        Unit of the light dose energy, by default ['He']\n        Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    dose_values : Union[int, float, list, tuple], optional\n        Dose values for which the colourimetric values will be returned, by default 'all'\n        When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n        A single dose value (an integer or a float number) can be entered.\n        A list of dose values, as integer or float, can also be entered.\n        A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n\n    Returns\n    -------\n    pandas dataframe\n        It returns the L*a*b* values inside a dataframe where each column corresponds to a single file.\n    \"\"\"    \n    DB = databases.DB()\n\n\n    # Set the observer value\n    if observer == 'default':\n        if len(DB.get_colorimetry_info()) == 0:\n            observer = '10deg'\n        else:\n            observer = DB.get_colorimetry_info().loc['observer']['value']\n\n    else:\n        observer = f'{str(observer)}deg'\n\n\n    # Set the illuminant value\n    if illuminant == 'default':\n        if len(DB.get_colorimetry_info()) == 0:\n            illuminant = 'D65'\n        else:\n            illuminant = DB.get_colorimetry_info().loc['illuminant']['value']\n\n\n    # Get colorimetric data related to the standard observer\n    observers = {\n        '10deg': 'cie_10_1964',\n        '2deg' : 'cie_2_1931',\n    }\n    cmfs_observers = {\n        '10deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1964 10 Degree Standard Observer\"],\n        '2deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1931 2 Degree Standard Observer\"] \n        }\n\n    ccs_ill = colour.CCS_ILLUMINANTS[observers[observer]][illuminant]\n\n\n    meas_ids = self.get_meas_ids               \n    df_sp = self.get_spectra(dose_unit=dose_unit, dose_values=dose_values)   \n    df_sp_nominal = [\n        df.loc[:, pd.IndexSlice[:, 'mean']] if 'mean' in df.columns.get_level_values(1)\n        else df.loc[:, pd.IndexSlice[:, 'value']]\n        for df in df_sp\n    ]\n\n    df_Lab = []\n\n    for df, meas_id in zip(df_sp_nominal, meas_ids):   \n\n        Lab_values = pd.DataFrame(index=['L*','a*','b*']).T           \n\n        for col in df.columns:\n\n            sp = df[col]\n            wl = df.index\n            sd = colour.SpectralDistribution(sp,wl)                \n\n            XYZ = colour.sd_to_XYZ(sd,cmfs_observers[observer], illuminant=colour.SDS_ILLUMINANTS[illuminant])        \n            Lab = np.round(colour.XYZ_to_Lab(XYZ/100,ccs_ill),3)               \n            Lab_values = pd.concat([Lab_values, pd.DataFrame(Lab, index=['L*','a*','b*']).T], axis=0)\n            Lab_values.index = np.arange(0,Lab_values.shape[0])\n\n        Lab_values.columns = pd.MultiIndex.from_product([[meas_id], Lab_values.columns])  \n        df_Lab.append(Lab_values)\n\n    return pd.concat(df_Lab, axis=1)           \n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_XYZ","title":"<code>get_XYZ(illuminant='default', observer='default', dose_unit='He', dose_values='all')</code>","text":"<p>Compute the XYZ values. </p>"},{"location":"references/#microfading.microfading.MFT.get_XYZ--parameters","title":"Parameters","text":"<p>illuminant : (str, optional)     Reference illuminant ('D65', or 'D50'). by default 'default'.     When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.</p> (str|int, optional) <p>Reference observer in degree ('10' or '2'). by default 'default'. When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.</p> Optional[str], optional <p>Unit of the light dose energy, by default ['He'] Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> Union[int, float, list, tuple], optional <p>Dose values for which the colourimetric values will be returned, by default 'all' When 'all', it returns the colourimetric values for all the dose values available in the given input data files. A single dose value (an integer or a float number) can be entered. A list of dose values, as integer or float, can also be entered. A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. </p>"},{"location":"references/#microfading.microfading.MFT.get_XYZ--returns","title":"Returns","text":"<p>pandas dataframe     It returns the XYZ values inside a dataframe where each column corresponds to a single file.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_XYZ(self, illuminant:Optional[str] = 'default', observer:Union[str,int] = 'default', dose_unit: Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all'):\n    \"\"\"Compute the XYZ values. \n\n    Parameters\n    ----------\n    illuminant : (str, optional)  \n        Reference *illuminant* ('D65', or 'D50'). by default 'default'.\n        When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.\n\n    observer : (str|int, optional)\n        Reference *observer* in degree ('10' or '2'). by default 'default'.\n        When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.\n\n    dose_unit : Optional[str], optional\n        Unit of the light dose energy, by default ['He']\n        Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    dose_values : Union[int, float, list, tuple], optional\n        Dose values for which the colourimetric values will be returned, by default 'all'\n        When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n        A single dose value (an integer or a float number) can be entered.\n        A list of dose values, as integer or float, can also be entered.\n        A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n    Returns\n    -------\n    pandas dataframe\n        It returns the XYZ values inside a dataframe where each column corresponds to a single file.\n    \"\"\"\n\n    DB = databases.DB()\n\n    # Set the observer value\n    if observer == 'default':\n        if len(DB.get_colorimetry_info()) == 0:\n            observer = '10deg'\n        else:\n            observer = DB.get_colorimetry_info().loc['observer']['value']\n\n    else:\n        observer = f'{str(observer)}deg'\n\n\n    # Set the illuminant value\n    if illuminant == 'default':\n        if len(DB.get_colorimetry_info()) == 0:\n            illuminant = 'D65'\n        else:\n            illuminant = DB.get_colorimetry_info().loc['illuminant']['value']               \n\n\n    # Get colorimetric data related to the standard observer\n    cmfs_observers = {\n        '10deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1964 10 Degree Standard Observer\"],\n        '2deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1931 2 Degree Standard Observer\"] \n        } \n\n    meas_ids = self.get_meas_ids                \n    df_sp = self.get_spectra(dose_unit=dose_unit, dose_values=dose_values)   \n    df_sp_nominal = [\n        df.loc[:, pd.IndexSlice[:, 'mean']] if 'mean' in df.columns.get_level_values(1)\n        else df.loc[:, pd.IndexSlice[:, 'value']]\n        for df in df_sp\n    ] \n\n    df_XYZ = []\n\n\n    for df, meas_id in zip(df_sp_nominal, meas_ids):\n\n        XYZ_values = pd.DataFrame(index=['X','Y','Z']).T\n\n        for col in df.columns:\n\n            sp = df[col]\n            wl = df.index\n            sd = colour.SpectralDistribution(sp,wl)                \n\n            XYZ = np.round(colour.sd_to_XYZ(sd,cmfs_observers[observer], illuminant=colour.SDS_ILLUMINANTS[illuminant]),3)\n            XYZ_values = pd.concat([XYZ_values, pd.DataFrame(XYZ, index=['X','Y','Z']).T], axis=0)\n            XYZ_values.index = np.arange(0,XYZ_values.shape[0])\n\n        XYZ_values.columns = pd.MultiIndex.from_product([[meas_id], XYZ_values.columns])\n        df_XYZ.append(XYZ_values)\n\n    return pd.concat(df_XYZ, axis=1)\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_cielab","title":"<code>get_cielab(coordinates=['dE00'], dose_unit='He', dose_values='all', index=True)</code>","text":"<p>Retrieve the colourimetric values for one or multiple light dose values.</p>"},{"location":"references/#microfading.microfading.MFT.get_cielab--parameters","title":"Parameters","text":"<p>coordinates : Optional[list], optional     Select the desired colorimetric coordinates from the following list: ['L', 'a','b', 'C', 'h', 'dL', 'da','db', 'dC', 'dh', 'dE76', 'dE00', 'dR_vis'], by default ['dE00']     When 'all', it returns all the colorimetric coordinates.</p> Optional[str], optional <p>Unit of the light dose energy, by default ['He'] Any of the following units can be added to the list: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> Union[int, float, list, tuple], optional <p>Dose values for which the colourimetric values will be returned, by default 'all' When 'all', it returns the colourimetric values for all the dose values available in the given input data files. A single dose value (an integer or a float number) can be entered. A list of dose values, as integer or float, can also be entered. A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. </p> Optional[bool], optional <p>Whether to set the index of the returned dataframes, by default False</p>"},{"location":"references/#microfading.microfading.MFT.get_cielab--returns","title":"Returns","text":"<p>A list of pandas dataframes     It returns the values of the wanted colour coordinates inside dataframes where each coordinate corresponds to a column.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_cielab(self, coordinates:Optional[list] = ['dE00'], dose_unit:Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', index:Optional[bool] = True):\n    \"\"\"Retrieve the colourimetric values for one or multiple light dose values.\n\n    Parameters\n    ----------\n    coordinates : Optional[list], optional\n        Select the desired colorimetric coordinates from the following list: ['L*', 'a*','b*', 'C*', 'h', 'dL*', 'da*','db*', 'dC*', 'dh', 'dE76', 'dE00', 'dR_vis'], by default ['dE00']\n        When 'all', it returns all the colorimetric coordinates.\n\n    dose_unit : Optional[str], optional\n        Unit of the light dose energy, by default ['He']\n        Any of the following units can be added to the list: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    dose_values : Union[int, float, list, tuple], optional\n        Dose values for which the colourimetric values will be returned, by default 'all'\n        When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n        A single dose value (an integer or a float number) can be entered.\n        A list of dose values, as integer or float, can also be entered.\n        A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n    index : Optional[bool], optional\n        Whether to set the index of the returned dataframes, by default False\n\n    Returns\n    -------\n    A list of pandas dataframes\n        It returns the values of the wanted colour coordinates inside dataframes where each coordinate corresponds to a column.\n    \"\"\"\n\n    # Create a dictionary to store the light dose units\n    dose_units = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't': 't_sec'}\n\n\n    # Retrieve the range light dose values\n    if isinstance(dose_values, (float, int)):\n        dose_values = [dose_values]\n\n    elif isinstance(dose_values, tuple):\n        dose_values = np.arange(dose_values[0], dose_values[1], dose_values[2])\n\n    elif isinstance(dose_values, list):\n        dose_values = dose_values        \n\n\n    # Retrieve the data        \n    cielab_data = self.read_files(sheets=['CIELAB'])\n    cielab_data = [x[0] for x in cielab_data]\n\n    # Create an empty list with all the colorimetric data\n    all_data = []\n\n    # Compute the delta LabCh values and add the data into the list all_data  \n    for data in cielab_data:\n\n        # for data with std values\n        if sorted(set(data.columns.get_level_values(1))) == ['mean', 'std']:\n            data_dLabCh = delta_coord = [unumpy.uarray(d[coord, 'mean'], d[coord, 'std']) - unumpy.uarray(d[coord, 'mean'], d[coord, 'std'])[0] for coord in ['L*', 'a*', 'b*', 'C*', 'h'] for d in [data]]\n\n            delta_means = [unumpy.nominal_values(x) for x in delta_coord]\n            delta_stds = [unumpy.std_devs(x) for x in delta_coord]\n\n            delta_coord_mean = [(f'd{coord}', 'mean') for coord in ['L*', 'a*', 'b*', 'C*', 'h']]\n            delta_coord_std = [(f'd{coord}', 'std') for coord in ['L*', 'a*', 'b*', 'C*', 'h']]\n\n            for coord_mean,delta_mean,coord_std,delta_std in zip(delta_coord_mean,delta_means, delta_coord_std,delta_stds):                    \n                data[coord_mean] = delta_mean\n                data[coord_std] = delta_std\n\n                all_data.append(data)          \n\n        # for data without std values\n        else:\n            data_LabCh = data[['L*','a*','b*','C*','h']]\n            data_dLabCh = data_LabCh - data_LabCh.iloc[0,:]\n            data_dLabCh = data_dLabCh.rename(columns={'L*': 'dL*', 'a*': 'da*' ,'b*': 'db*','C*': 'dC*','h': 'dh'}, level=0)\n            all_data.append(pd.concat([data,data_dLabCh], axis=1))\n\n\n    # Select the wanted dose_unit and coordinate\n    if coordinates == 'all':\n        wanted_data = all_data\n        wanted_data = [x.set_index((dose_units[dose_unit],'value')) for x in wanted_data]\n    else:       \n        wanted_data = [x[[dose_units[dose_unit]] + coordinates] for x in all_data]       \n        wanted_data = [x.set_index(x.columns[0]) for x in wanted_data]        \n\n    if isinstance(dose_values, str):\n        if dose_values == 'all':\n            interpolated_data = [x.reset_index() for x in wanted_data]\n\n    else:\n\n        # Interpolation function, assuming linear interpolation\n        interp_functions = lambda x, y: interp1d(x, y, kind='linear', bounds_error=False)\n\n\n        # Double comprehension list to interpolate each dataframe in wanted_data\n        interpolated_data = [\n            pd.DataFrame({\n                col: interp_functions(df.index, df[col])(dose_values)\n                for col in df.columns\n            }, index=dose_values)\n            .rename_axis(dose_units[dose_unit])\n            .reset_index()\n            for df in wanted_data\n        ]\n\n\n    # Whether to set the index\n    if index:\n        interpolated_data = [x.set_index(x.columns[0]) for x in interpolated_data]\n\n    return interpolated_data       \n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_data","title":"<code>get_data(data='all', xarray=False)</code>","text":"<p>Retrieve the microfading data.</p>"},{"location":"references/#microfading.microfading.MFT.get_data--parameters","title":"Parameters","text":"<p>data : str|list, optional     Possibility to select the type of data, by default 'all'.     When 'all', it returns all the data (spectral and colorimetric).     When 'sp', it only returns the spectral data.     When 'cl', it only returns the colorimetric data.     When 'Lab', it returns the CIE Lab values.     A list of strings can be entered to select specific colourimetric data among the following: ['dE76,'dE00','dR_vis', 'L', 'a', 'b', 'C*', 'h'].</p> bool, optional <p>When True, the data are returned as an xarray.Dataset object, else as pandas dataframe object, by default False.</p>"},{"location":"references/#microfading.microfading.MFT.get_data--returns","title":"Returns","text":"<p>It returns a list of pandas dataframes or xarray.Dataset objects</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_data(self, data:Union[str, list] = 'all', xarray:Optional[bool] = False):\n    \"\"\"Retrieve the microfading data.\n\n    Parameters\n    ----------\n    data : str|list, optional\n        Possibility to select the type of data, by default 'all'.\n        When 'all', it returns all the data (spectral and colorimetric).\n        When 'sp', it only returns the spectral data.\n        When 'cl', it only returns the colorimetric data.  \n        When 'Lab', it returns the CIE L*a*b* values.\n        A list of strings can be entered to select specific colourimetric data among the following: ['dE76,'dE00','dR_vis', 'L*', 'a*', 'b*', 'C*', 'h'].\n\n    xarray : bool, optional\n        When True, the data are returned as an xarray.Dataset object, else as pandas dataframe object, by default False.\n\n    Returns\n    -------\n    It returns a list of pandas dataframes or xarray.Dataset objects\n    \"\"\"\n\n    all_files = self.read_files(sheets=['spectra','CIELAB'])\n    all_data = []\n    data_sp = [] \n    data_cl = [] \n\n    for data_file in all_files:\n\n        df_sp = data_file[0]\n        df_cl = data_file[1]\n\n        if sorted(set(df_sp.columns.get_level_values(1))) == ['mean', 'std']:\n            sp_n = df_sp.xs('mean', level=1, axis=1).values\n            sp_s = df_sp.xs('std', level=1, axis=1).values\n\n            L_n = df_cl[\"L*\",\"mean\"].values\n            a_n = df_cl[\"a*\",\"mean\"].values\n            b_n = df_cl[\"b*\",\"mean\"].values\n            C_n = df_cl[\"C*\",\"mean\"].values\n            h_n = df_cl[\"h\",\"mean\"].values\n            dE76_n = df_cl[\"dE76\",\"mean\"].values\n            dE00_n = df_cl[\"dE00\",\"mean\"].values\n            dR_vis_n = df_cl[\"dR_vis\",\"mean\"].values\n\n            L_s = df_cl[\"L*\",\"std\"].values\n            a_s = df_cl[\"a*\",\"std\"].values\n            b_s = df_cl[\"b*\",\"std\"].values\n            C_s = df_cl[\"C*\",\"std\"].values\n            h_s = df_cl[\"h\",\"std\"].values\n            dE76_s = df_cl[\"dE76\",\"std\"].values\n            dE00_s = df_cl[\"dE00\",\"std\"].values\n            dR_vis_s = df_cl[\"dR_vis\",\"std\"].values\n\n        else:\n            sp_n = df_sp.xs('value', level=1, axis=1).values\n            sp_s = df_sp.xs('value', level=1, axis=1)\n            sp_s.loc[:,:] = 0\n            sp_s = sp_s.values\n\n            L_n = df_cl[\"L*\",\"value\"].values\n            a_n = df_cl[\"a*\",\"value\"].values\n            b_n = df_cl[\"b*\",\"value\"].values\n            C_n = df_cl[\"C*\",\"value\"].values\n            h_n = df_cl[\"h\",\"value\"].values\n            dE76_n = df_cl[\"dE76\",\"value\"].values\n            dE00_n = df_cl[\"dE00\",\"value\"].values\n            dR_vis_n = df_cl[\"dR_vis\",\"value\"].values\n\n            L_s = np.zeros(len(L_n))\n            a_s = np.zeros(len(a_n))\n            b_s = np.zeros(len(b_n))\n            C_s = np.zeros(len(C_n))\n            h_s = np.zeros(len(h_n))\n            dE76_s = np.zeros(len(dE76_n))\n            dE00_s = np.zeros(len(dE00_n))\n            dR_vis_s = np.zeros(len(dR_vis_n))\n\n        wl = data_file[0].iloc[:,0].values\n        He = data_file[1]['He_MJ/m2','value'].values\n        Hv = data_file[1]['Hv_Mlxh','value'].values\n        t = data_file[1]['t_sec','value'].values\n\n        spectral_data = xr.Dataset(\n            {\n                'sp': (['wavelength','dose'], sp_n),\n                'sp_s': (['wavelength','dose'], sp_s)                \n            },\n            coords={\n                'wavelength': wl,   \n                'dose': He,\n                'He': ('dose', He),\n                'Hv': ('dose', Hv),  # Match radiant energy\n                't': ('dose', t)  # Match radiant energy\n            }\n        )\n\n        color_data = xr.Dataset(\n            {\n                'L*': (['dose'], L_n),\n                'a*': (['dose'], a_n),\n                'b*': (['dose'], b_n),\n                'C*': (['dose'], C_n),\n                'h': (['dose'], h_n),\n                'dE76': (['dose'], dE76_n),\n                'dE00': (['dose'], dE00_n),\n                'dR_vis': (['dose'], dR_vis_n),\n                'L*_s': (['dose'], L_s),\n                'a*_s': (['dose'], a_s),\n                'b*_s': (['dose'], b_s),\n                'C*_s': (['dose'], C_s),\n                'h_s': (['dose'], h_s),\n                'dE76_s': (['dose'], dE76_s),\n                'dE00_s': (['dose'], dE00_s),\n                'dR_vis_s': (['dose'], dR_vis_s),\n            },\n            coords={                    \n                'He': ('dose',He),\n                'Hv': ('dose',Hv),\n                't': ('dose',t),\n            }\n        )                \n\n        sp = spectral_data.set_xindex([\"He\",\"Hv\",\"t\"])\n        cl = color_data.set_xindex([\"He\",\"Hv\",\"t\"])\n        combined_data = xr.merge([sp, cl])\n\n    all_data.append(combined_data)            \n\n\n    if data == 'all':\n        if xarray == False:                \n            [data_sp.append(x[0]) for x in all_files]\n            [data_cl.append(x[1]) for x in all_files]\n            return data_sp, data_cl\n\n        else:\n            return all_data\n\n    elif data == 'sp':\n        if xarray == False:                \n            [data_sp.append(x[0]) for x in all_files]                                           \n        else:                \n            data_sp = [x.sp for x in all_data]\n\n\n        return data_sp\n\n    elif data == 'cl':\n        if xarray == False:\n            [data_cl.append(x[1]) for x in all_files]\n        else:\n            data_cl = [x[['L*','a*','b*','C*','h','dE76','dE00','dR_vis']] for x in all_data]\n\n        return data_cl\n\n    elif data == 'Lab':\n        if xarray == False:\n            [data_cl.append(x[1][['L*','a*','b*']]) for x in all_files]\n        else:\n            data_cl = [x[['L*','a*','b*']] for x in all_data]\n\n        return data_cl\n\n    elif isinstance(data,list):\n        if xarray == False:\n            dic_doses = {'He': 'He_MJ/m2', 'Hv':'Hv_Mlxh', 't':'t_sec'}\n            data = [dic_doses[x] if x in dic_doses.keys() else x for x in data]\n            [data_cl.append(x[1][data]) for x in all_files]\n\n        else:\n            data = [elem for elem in data if elem not in ['Hv','He','t']]\n            data_cl = [x[data] for x in all_data]\n\n        return data_cl\n\n    else:\n        print(\"Enter a valid data parameter. It can either be a string ('sp', 'cl', 'Lab', 'all') or a list of strings ['dE00','dE76', 'L*', 'a*', 'b*', 'C*', 'h']\")\n        return None\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_doses","title":"<code>get_doses(dose_unit='all', max_doses=False)</code>","text":"<p>Retrieve the light energy doses related to each microfading measurement.</p>"},{"location":"references/#microfading.microfading.MFT.get_doses--parameters","title":"Parameters","text":"<p>dose_unit : Union[str,list], optional     Unit of the light dose energy, by default 'all'     Any of the following units can be added to the list: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec). When a single unit is requested, it can be given as a string value ('He', 'Hv', or 't').</p> bool, optional <p>Whether to return the maximum light dose values, by default False.</p>"},{"location":"references/#microfading.microfading.MFT.get_doses--returns","title":"Returns","text":"<p>list of pandas dataframes     description</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_doses(self, dose_unit:Union[str,list] = 'all', max_doses:Optional[bool] = False):\n    \"\"\"Retrieve the light energy doses related to each microfading measurement.\n\n    Parameters\n    ----------\n    dose_unit : Union[str,list], optional\n        Unit of the light dose energy, by default 'all'\n        Any of the following units can be added to the list: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec). When a single unit is requested, it can be given as a string value ('He', 'Hv', or 't').\n\n    max_doses : bool, optional\n        Whether to return the maximum light dose values, by default False.\n\n    Returns\n    -------\n    list of pandas dataframes\n        _description_\n    \"\"\"\n\n    data = self.get_data(data='cl')\n\n    if dose_unit == 'all':\n        doses = [x[['He_MJ/m2', 'Hv_Mlxh', 't_sec']] for x in data]\n\n    else:\n        doses_dic = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't':'t_sec'}\n\n        if isinstance(dose_unit, list):\n            dose_unit = [doses_dic[x] for x in dose_unit] \n            doses = [x[dose_unit] for x in data]\n\n        else:\n            doses = [x[doses_dic[dose_unit]] for x in data]\n\n    if max_doses:\n        doses = [pd.DataFrame(x).iloc[-1,:] for x in doses]\n\n\n    return doses\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_illuminant","title":"<code>get_illuminant(illuminant='D65', observer='10')</code>","text":"<p>Set the illuminant values</p>"},{"location":"references/#microfading.microfading.MFT.get_illuminant--parameters","title":"Parameters","text":"<p>illuminant : Optional[str], optional     Select the illuminant, by default 'D65'     It can be any value within the following list: ['A', 'B', 'C', 'D50', 'D55', 'D60', 'D65', 'D75', 'E', 'FL1', 'FL2', 'FL3', 'FL4', 'FL5', 'FL6', 'FL7', 'FL8', 'FL9', 'FL10', 'FL11', 'FL12', 'FL3.1', 'FL3.2', 'FL3.3', 'FL3.4', 'FL3.5', 'FL3.6', 'FL3.7', 'FL3.8', 'FL3.9', 'FL3.10', 'FL3.11', 'FL3.12', 'FL3.13', 'FL3.14', 'FL3.15', 'HP1', 'HP2', 'HP3', 'HP4', 'HP5', 'LED-B1', 'LED-B2', 'LED-B3', 'LED-B4', 'LED-B5', 'LED-BH1', 'LED-RGB1', 'LED-V1', 'LED-V2', 'ID65', 'ID50', 'ISO 7589 Photographic Daylight', 'ISO 7589 Sensitometric Daylight', 'ISO 7589 Studio Tungsten', 'ISO 7589 Sensitometric Studio Tungsten', 'ISO 7589 Photoflood', 'ISO 7589 Sensitometric Photoflood', 'ISO 7589 Sensitometric Printer']</p> Optional[str], optional <p>Standard observer in degree, by default '10' It can be either '2' or '10'</p>"},{"location":"references/#microfading.microfading.MFT.get_illuminant--returns","title":"Returns","text":"<p>tuple     It returns a tuple with two set of values: the chromaticity coordinates of the illuminants (CCS) and the spectral distribution of the illuminants (SDS).</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_illuminant(self, illuminant:Optional[str] = 'D65', observer:Optional[str] = '10'):\n    \"\"\"Set the illuminant values\n\n    Parameters\n    ----------\n    illuminant : Optional[str], optional\n        Select the illuminant, by default 'D65'\n        It can be any value within the following list: ['A', 'B', 'C', 'D50', 'D55', 'D60', 'D65', 'D75', 'E', 'FL1', 'FL2', 'FL3', 'FL4', 'FL5', 'FL6', 'FL7', 'FL8', 'FL9', 'FL10', 'FL11', 'FL12', 'FL3.1', 'FL3.2', 'FL3.3', 'FL3.4', 'FL3.5', 'FL3.6', 'FL3.7', 'FL3.8', 'FL3.9', 'FL3.10', 'FL3.11', 'FL3.12', 'FL3.13', 'FL3.14', 'FL3.15', 'HP1', 'HP2', 'HP3', 'HP4', 'HP5', 'LED-B1', 'LED-B2', 'LED-B3', 'LED-B4', 'LED-B5', 'LED-BH1', 'LED-RGB1', 'LED-V1', 'LED-V2', 'ID65', 'ID50', 'ISO 7589 Photographic Daylight', 'ISO 7589 Sensitometric Daylight', 'ISO 7589 Studio Tungsten', 'ISO 7589 Sensitometric Studio Tungsten', 'ISO 7589 Photoflood', 'ISO 7589 Sensitometric Photoflood', 'ISO 7589 Sensitometric Printer']\n\n    observer : Optional[str], optional\n        Standard observer in degree, by default '10'\n        It can be either '2' or '10'\n\n    Returns\n    -------\n    tuple\n        It returns a tuple with two set of values: the chromaticity coordinates of the illuminants (CCS) and the spectral distribution of the illuminants (SDS).\n    \"\"\"\n\n    observers = {\n        '10': \"cie_10_1964\",\n        '2' : \"cie_2_1931\"\n    }\n\n    CCS = colour.CCS_ILLUMINANTS[observers[observer]][illuminant]\n    SDS = colour.SDS_ILLUMINANTS[illuminant]\n\n    return CCS, SDS\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_metadata","title":"<code>get_metadata(labels='all')</code>","text":"<p>Retrieve the metadata.</p>"},{"location":"references/#microfading.microfading.MFT.get_metadata--parameters","title":"Parameters","text":"<p>labels : Optional[list], optional     A list of strings corresponding to the wanted metadata labels, by default 'all'     The metadata labels can be found in the 'info' sheet of microfading excel files.     When 'all', it returns all the metadata</p>"},{"location":"references/#microfading.microfading.MFT.get_metadata--returns","title":"Returns","text":"<p>pandas dataframe     It returns the metadata inside a pandas dataframe where each column corresponds to a single file.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_metadata(self, labels:Optional[list] = 'all'):\n    \"\"\"Retrieve the metadata.\n\n    Parameters\n    ----------\n    labels : Optional[list], optional\n        A list of strings corresponding to the wanted metadata labels, by default 'all'\n        The metadata labels can be found in the 'info' sheet of microfading excel files.\n        When 'all', it returns all the metadata\n\n    Returns\n    -------\n    pandas dataframe\n        It returns the metadata inside a pandas dataframe where each column corresponds to a single file.\n    \"\"\"\n\n    df = self.read_files()\n    metadata = [x[0] for x in df]\n\n    df_metadata = pd.DataFrame(index = metadata[0].set_index('parameter').index)\n\n    for m in metadata:\n        m = m.set_index('parameter')\n        Id = m.loc['meas_id']['value']\n\n        df_metadata[Id] = m['value']\n\n    if labels == 'all':\n        return df_metadata\n\n    else:            \n        return df_metadata.loc[labels]     \n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_observer","title":"<code>get_observer(observer='10')</code>","text":"<p>Set the observer.</p>"},{"location":"references/#microfading.microfading.MFT.get_observer--parameters","title":"Parameters","text":"<p>observer : Optional[str], optional     Standard observer in degree, by default '10'     It can be either '2' or '10'</p>"},{"location":"references/#microfading.microfading.MFT.get_observer--returns","title":"Returns","text":"<pre><code>Returns the x_bar,  y_bar, z_bar spectra between 360 and 830 nm.\n</code></pre> Source code in <code>microfading/microfading.py</code> <pre><code>def get_observer(self, observer:Optional[str] = '10'):\n    \"\"\"Set the observer.\n\n    Parameters\n    ----------\n    observer : Optional[str], optional\n        Standard observer in degree, by default '10'\n        It can be either '2' or '10'\n\n    Returns\n    -------        \n        Returns the x_bar,  y_bar, z_bar spectra between 360 and 830 nm.\n    \"\"\"\n\n    observers = {\n        '10': \"CIE 1964 10 Degree Standard Observer\",\n        '2' : \"CIE 1931 2 Degree Standard Observer\"\n    }\n\n    return colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[observers[observer]]   \n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_sRGB","title":"<code>get_sRGB(illuminant='default', observer='default', dose_unit='He', dose_values='all', clip=True)</code>","text":"<p>Compute the sRGB values. </p>"},{"location":"references/#microfading.microfading.MFT.get_sRGB--parameters","title":"Parameters","text":"<p>illuminant : (str, optional)     Reference illuminant ('D65', or 'D50'). by default 'default'.     When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.</p> (str|int, optional) <p>Reference observer in degree ('10' or '2'). by default 'default'. When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.</p> Optional[str], optional <p>Unit of the light dose energy, by default ['He'] Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> Union[int, float, list, tuple], optional <p>Dose values for which the colourimetric values will be returned, by default 'all' When 'all', it returns the colourimetric values for all the dose values available in the given input data files. A single dose value (an integer or a float number) can be entered. A list of dose values, as integer or float, can also be entered. A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. </p> Optional[bool], optional <p>Whether to constraint the srgb values between 0 and 1.</p>"},{"location":"references/#microfading.microfading.MFT.get_sRGB--returns","title":"Returns","text":"<p>pandas dataframe     It returns the sRGB values inside a dataframe where each column corresponds to a single file.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_sRGB(self, illuminant='default', observer='default', dose_unit: Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', clip:Optional[bool] = True):\n    \"\"\"Compute the sRGB values. \n\n    Parameters\n    ----------\n    illuminant : (str, optional)  \n        Reference *illuminant* ('D65', or 'D50'). by default 'default'.\n        When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.\n\n    observer : (str|int, optional)\n        Reference *observer* in degree ('10' or '2'). by default 'default'.\n        When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.\n\n    dose_unit : Optional[str], optional\n        Unit of the light dose energy, by default ['He']\n        Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    dose_values : Union[int, float, list, tuple], optional\n        Dose values for which the colourimetric values will be returned, by default 'all'\n        When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n        A single dose value (an integer or a float number) can be entered.\n        A list of dose values, as integer or float, can also be entered.\n        A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n    clip : Optional[bool], optional\n        Whether to constraint the srgb values between 0 and 1.\n\n    Returns\n    -------\n    pandas dataframe\n        It returns the sRGB values inside a dataframe where each column corresponds to a single file.\n    \"\"\"\n\n    DB = databases.DB()\n\n\n    # Set the observer value\n    if observer == 'default':\n        if len(DB.get_colorimetry_info()) == 0:\n            observer = '10deg'\n        else:\n            observer = DB.get_colorimetry_info().loc['observer']['value']\n\n    else:\n        observer = f'{str(observer)}deg'\n\n    # Set the illuminant value\n    if illuminant == 'default':\n        if len(DB.get_colorimetry_info()) == 0:\n            illuminant = 'D65'\n        else:\n            illuminant = DB.get_colorimetry_info().loc['illuminant']['value']\n\n\n    # Get colorimetric data related to the standard observer\n    observers = {\n        '10deg': 'cie_10_1964',\n        '2deg' : 'cie_2_1931',\n    }\n    cmfs_observers = {\n        '10deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1964 10 Degree Standard Observer\"],\n        '2deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1931 2 Degree Standard Observer\"] \n        }\n\n    ccs_ill = colour.CCS_ILLUMINANTS[observers[observer]][illuminant]\n\n    meas_ids = self.get_meas_ids \n\n    df_sp = self.get_spectra(dose_unit=dose_unit, dose_values=dose_values)   \n    df_sp_nominal = [\n        df.loc[:, pd.IndexSlice[:, 'mean']] if 'mean' in df.columns.get_level_values(1)\n        else df.loc[:, pd.IndexSlice[:, 'value']]\n        for df in df_sp\n    ] \n\n    df_srgb = []\n\n\n    for df, meas_id in zip(df_sp_nominal, meas_ids):\n\n        srgb_values = pd.DataFrame(index=['R','G','B']).T            \n\n        for col in df.columns:\n\n            sp = df[col]\n            wl = df.index\n            sd = colour.SpectralDistribution(sp,wl)                \n\n            XYZ = colour.sd_to_XYZ(sd,cmfs_observers[observer], illuminant=colour.SDS_ILLUMINANTS[illuminant]) \n            srgb = np.round(colour.XYZ_to_sRGB(XYZ / 100, illuminant=ccs_ill), 4)                        \n            srgb_values = pd.concat([srgb_values, pd.DataFrame(srgb, index=['R','G','B']).T], axis=0)\n            srgb_values.index = np.arange(0,srgb_values.shape[0])\n\n        srgb_values.columns = pd.MultiIndex.from_product([[meas_id], srgb_values.columns])\n\n        if clip:\n            srgb_values = srgb_values.clip(0,1)\n\n        df_srgb.append(srgb_values)\n\n\n    return pd.concat(df_srgb, axis=1)\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_spectra","title":"<code>get_spectra(wl_range='all', dose_unit='He', dose_values='all', spectral_mode='rfl', smoothing=[1, 0])</code>","text":"<p>Retrieve the reflectance spectra related to the input files.</p>"},{"location":"references/#microfading.microfading.MFT.get_spectra--parameters","title":"Parameters","text":"<p>wl_range : Union[int, float, list, tuple], optional     Select the wavelengths for which the spectral values should be given with a two-values tuple corresponding to the lowest and highest wavelength values, by default 'all'     When 'all', it will returned all the available wavelengths contained in the datasets.     A single wavelength value (an integer or a float number) can be entered.     A list of specific wavelength values as integer or float can also be entered.     A tuple of two or three values (min, max, step) will take the range values between these two first values. By default the step is equal to 1.</p> string, optional <p>Unit of the light energy dose, by default 'He' Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec).</p> Union[int, float, list, tuple], optional <p>Dose values for which the reflectance values will be returned, by default 'all' When 'all', it returns the reflectance values for all the dose values available in the given input data files. A single dose value (an integer or a float number) can be entered. A list of dose values, as integer or float, can also be entered. A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. </p> string, optional <p>When 'rfl', it returns the reflectance spectra When 'abs', it returns the absorption spectra using the following equation: A = -log(R)</p> list of two integers, optional <p>Whether to smooth the reflectance data using the Savitzky-Golay filter from the Scipy package, by default [1,0] The first integer corresponds to the window length and should be less than or equal to the size of a reflectance spectrum. The second integer corresponds to the polyorder parameter which is used to fit the samples. The polyorder value must be less than the value of the window length.</p>"},{"location":"references/#microfading.microfading.MFT.get_spectra--returns","title":"Returns","text":"<p>A list of pandas dataframes     It returns a list of pandas dataframes where the columns correspond to the dose values and the rows correspond to the wavelengths.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_spectra(self, wl_range:Union[int, float, list, tuple] = 'all', dose_unit:Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', spectral_mode:Optional[str] = 'rfl', smoothing:Optional[list] = [1,0]):\n    \"\"\"Retrieve the reflectance spectra related to the input files.\n\n    Parameters\n    ----------\n    wl_range : Union[int, float, list, tuple], optional\n        Select the wavelengths for which the spectral values should be given with a two-values tuple corresponding to the lowest and highest wavelength values, by default 'all'\n        When 'all', it will returned all the available wavelengths contained in the datasets.\n        A single wavelength value (an integer or a float number) can be entered.\n        A list of specific wavelength values as integer or float can also be entered.\n        A tuple of two or three values (min, max, step) will take the range values between these two first values. By default the step is equal to 1.\n\n    dose_unit : string, optional\n        Unit of the light energy dose, by default 'He'\n        Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec).\n\n    dose_values : Union[int, float, list, tuple], optional\n        Dose values for which the reflectance values will be returned, by default 'all'\n        When 'all', it returns the reflectance values for all the dose values available in the given input data files.\n        A single dose value (an integer or a float number) can be entered.\n        A list of dose values, as integer or float, can also be entered.\n        A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n    spectral_mode : string, optional\n        When 'rfl', it returns the reflectance spectra\n        When 'abs', it returns the absorption spectra using the following equation: A = -log(R)\n\n    smoothing : list of two integers, optional\n        Whether to smooth the reflectance data using the Savitzky-Golay filter from the Scipy package, by default [1,0]\n        The first integer corresponds to the window length and should be less than or equal to the size of a reflectance spectrum. The second integer corresponds to the polyorder parameter which is used to fit the samples. The polyorder value must be less than the value of the window length.\n\n\n    Returns\n    -------\n    A list of pandas dataframes\n        It returns a list of pandas dataframes where the columns correspond to the dose values and the rows correspond to the wavelengths.\n    \"\"\"\n\n    data_sp = []\n    files = self.read_files(sheets=['spectra', 'CIELAB'])   \n\n    dose_units = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't':'t_sec'}     \n\n    for file in files:\n        df_sp = file[0]            \n\n        # whether to compute the absorption spectra\n        if spectral_mode == 'abs':\n            df_sp = np.log(df_sp) * (-1)\n\n\n        # Set the dose unit\n        if dose_unit == 'Hv':\n            Hv = file[1]['Hv_Mlxh','value'].values\n            df_sp.columns = df_sp.columns.set_levels(Hv, level=0)                \n            #df_sp.index.name = 'wl-nm_Hv-Mlxh'\n\n        elif dose_unit =='t':\n            t = file[1]['t_sec','value'].values\n            df_sp.columns = df_sp.columns.set_levels(t, level=0)\n            #df_sp.index.name = 'wl-nm_t-sec'\n\n\n        # Set the wavelengths\n        if isinstance(wl_range, tuple):\n            if len(wl_range) == 2:\n                wl_range = (wl_range[0],wl_range[1],1)\n\n            wavelengths = np.arange(wl_range[0], wl_range[1], wl_range[2])                               \n\n        elif isinstance(wl_range, list):\n            wavelengths = wl_range                               \n\n        elif isinstance(wl_range, int):\n            wl_range = [wl_range]\n            wavelengths = wl_range  \n\n        else:\n            wavelengths = df_sp.index          \n\n        df_sp = df_sp.loc[wavelengths]\n\n\n        # Smooth the data\n        doses = df_sp.columns\n        df_sp = pd.DataFrame(savgol_filter(df_sp.T.values, window_length=smoothing[0], polyorder=smoothing[1]).T, columns=doses, index=wavelengths)\n\n        # Set the dose values \n        if isinstance(dose_values, tuple):\n            if len(dose_values) == 2:\n                dose_values = (dose_values[0],dose_values[1],1)\n\n            wanted_doses = np.arange(dose_values[0], dose_values[1], dose_values[2])\n\n        elif isinstance(dose_values, int) or isinstance(dose_values, float):            \n            wanted_doses = [dose_values]\n\n        elif isinstance(dose_values, list):\n            wanted_doses = dose_values\n\n        else:\n            wanted_doses = sorted(set(df_sp.columns.get_level_values(0)))\n\n\n        def multiindex_2Dinterpolation(df, dose_unit, wanted_x, wanted_y, level_name='value'):\n            interpolator = RegularGridInterpolator((df.index, df.columns.get_level_values(0)), df.values, method='linear')\n\n            # Create a meshgrid of the new points\n            new_wv_grid, new_ev_grid = np.meshgrid(wanted_y, wanted_x, indexing='ij')\n\n            # Flatten the grid arrays and combine them into coordinate pairs\n            new_points = np.array([new_wv_grid.ravel(), new_ev_grid.ravel()]).T\n\n            # Interpolate the data at the new points\n            interpolated_values = interpolator(new_points)\n\n            # Reshape the interpolated values to match the new grid shape\n            interpolated_values = interpolated_values.reshape(len(wanted_y), len(wanted_x))\n\n            # Create a new DataFrame with the interpolated data\n            new_columns = pd.MultiIndex.from_product([wanted_x, [level_name]], names=[dose_units[dose_unit], 'value'])\n            interpolated_df = pd.DataFrame(interpolated_values, index=wanted_y, columns=new_columns)\n\n            interpolated_df.index.name = 'wavelength_nm'\n\n            return interpolated_df\n\n        if sorted(set(df_sp.columns.get_level_values(1))) == ['mean', 'std']:\n            df_sp_n = df_sp.xs(key='mean', axis=1, level=1)\n            df_sp_s = df_sp.xs(key='std', axis=1, level=1)\n\n            interpolated_df_sp_n = multiindex_2Dinterpolation(df_sp_n, dose_unit, wanted_doses, df_sp.index, 'mean')   #.T[::2].T\n            interpolated_df_sp_s = multiindex_2Dinterpolation(df_sp_s, dose_unit, wanted_doses, df_sp.index, 'std')    #.T[::2].T\n            interpolated_df_sp = pd.concat([interpolated_df_sp_n,interpolated_df_sp_s], axis=1).sort_index(axis=1)                \n\n\n        else:\n            interpolated_df_sp = multiindex_2Dinterpolation(df_sp, dose_unit, wanted_doses, df_sp.index)\n\n        # append the spectral data\n        data_sp.append(interpolated_df_sp) \n\n    return data_sp\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.get_xy","title":"<code>get_xy(illuminant='default', observer='default', dose_unit='He', dose_values='all')</code>","text":"<p>Compute the xy values. </p>"},{"location":"references/#microfading.microfading.MFT.get_xy--parameters","title":"Parameters","text":"<p>illuminant : (str, optional)     Reference illuminant ('D65', or 'D50'). by default 'default'.     When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.</p> (str|int, optional) <p>Reference observer in degree ('10' or '2'). by default 'default'. When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.</p> Optional[str], optional <p>Unit of the light dose energy, by default ['He'] Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> Union[int, float, list, tuple], optional <p>Dose values for which the colourimetric values will be returned, by default 'all' When 'all', it returns the colourimetric values for all the dose values available in the given input data files. A single dose value (an integer or a float number) can be entered. A list of dose values, as integer or float, can also be entered. A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. </p>"},{"location":"references/#microfading.microfading.MFT.get_xy--returns","title":"Returns","text":"<p>pandas dataframe     It returns the xy values inside a dataframe where each column corresponds to a single file.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_xy(self, illuminant:Optional[str] = 'default', observer:Union[str, int] = 'default', dose_unit: Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all'):\n    \"\"\"Compute the xy values. \n\n    Parameters\n    ----------\n    illuminant : (str, optional)  \n        Reference *illuminant* ('D65', or 'D50'). by default 'default'.\n        When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.\n\n    observer : (str|int, optional)\n        Reference *observer* in degree ('10' or '2'). by default 'default'.\n        When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10'.\n\n    dose_unit : Optional[str], optional\n        Unit of the light dose energy, by default ['He']\n        Any of the following units can be entered: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    dose_values : Union[int, float, list, tuple], optional\n        Dose values for which the colourimetric values will be returned, by default 'all'\n        When 'all', it returns the colourimetric values for all the dose values available in the given input data files.\n        A single dose value (an integer or a float number) can be entered.\n        A list of dose values, as integer or float, can also be entered.\n        A tuple of three values (min, max, step) will be used in a numpy.arange() function to return an array of dose values. \n\n    Returns\n    -------\n    pandas dataframe\n        It returns the xy values inside a dataframe where each column corresponds to a single file.\n    \"\"\"\n    DB = databases.DB()\n\n    # Set the observer value\n    if observer == 'default':\n        if len(DB.get_colorimetry_info()) == 0:\n            observer = '10deg'\n        else:\n            observer = DB.get_colorimetry_info().loc['observer']['value']\n\n    else:\n        observer = f'{str(observer)}deg'\n\n\n    # Set the illuminant value\n    if illuminant == 'default':\n        if len(DB.get_colorimetry_info()) == 0:\n            illuminant = 'D65'\n        else:\n            illuminant = DB.get_colorimetry_info().loc['illuminant']['value']               \n\n\n    # Get colorimetric data related to the standard observer\n    cmfs_observers = {\n        '10deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1964 10 Degree Standard Observer\"],\n        '2deg': colour.colorimetry.MSDS_CMFS_STANDARD_OBSERVER[\"CIE 1931 2 Degree Standard Observer\"] \n        }       \n\n\n    meas_ids = self.get_meas_ids                \n    df_sp = self.get_spectra(dose_unit=dose_unit, dose_values=dose_values)   \n    df_sp_nominal = [\n        df.loc[:, pd.IndexSlice[:, 'mean']] if 'mean' in df.columns.get_level_values(1)\n        else df.loc[:, pd.IndexSlice[:, 'value']]\n        for df in df_sp\n    ]     \n    df_xy = []\n\n\n    for df, meas_id in zip(df_sp_nominal, meas_ids):\n\n        xy_values = pd.DataFrame(index=['x','y']).T           \n\n        for col in df.columns:\n\n            sp = df[col]\n            wl = df.index\n            sd = colour.SpectralDistribution(sp,wl)                \n\n            XYZ = colour.sd_to_XYZ(sd,cmfs_observers[observer], illuminant=colour.SDS_ILLUMINANTS[illuminant])\n            xy = np.round(colour.XYZ_to_xy(XYZ),4)\n            xy_values = pd.concat([xy_values, pd.DataFrame(xy, index=['x','y']).T], axis=0)\n            xy_values.index = np.arange(0,xy_values.shape[0])\n\n        xy_values.columns = pd.MultiIndex.from_product([[meas_id], xy_values.columns])\n        df_xy.append(xy_values)\n\n    return pd.concat(df_xy, axis=1)\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.plot_CIELAB","title":"<code>plot_CIELAB(stds=[], dose_unit='He', dose_values='all', colors=None, title=None, fontsize=20, legend_labels='default', legend_position='in', legend_fontsize=20, legend_title=None, dE=False, obs_ill=True, save=False, path_fig='cwd', report=False)</code>","text":"<p>Plot the Lab values related to input the microfading files.</p>"},{"location":"references/#microfading.microfading.MFT.plot_CIELAB--parameters","title":"Parameters","text":"<p>stds : list, optional     A list of standard variation values respective to each element given in the data parameter, by default []</p> str, optional <p>Unit of the light energy dose, by default 'He' Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> [int, float, list, tuple], optional <p>Values of the light dose energy, by default 'all' A single value (integer or float number), a list of multiple numerical values, or range values with a tuple (start, end, step) can be entered. When 'all', it takes the values found in the data.   </p> [str, list], optional <p>Define the colors of the data points, by default None When 'sample', the color of each points will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) or a list of matplotlib colour values can be used.     </p> str, optional <p>Whether to add a title to the plot, by default None</p> int, optional <p>Fontsize of the plot (title, ticks, and labels), by default 24</p> [str, list], optional <p>A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default' When 'default', each label will composed of the Id number of the number followed by a short description</p> str, optional <p>Position of the legend, by default 'in' The legend can either be inside the figure ('in') or outside ('out')</p> int, optional <p>Fontsize of the legend, by default 24</p> str, optional <p>Add a title above the legend, by default ''</p> bool, optional <p>Whether to display the dE00 curves in the bottom left suplots instead of the CIELAB 2D space, by default False NOT IMPLEMENTED YET ! LEAVE PARAMETER TO FALSE</p> bool, optional <p>Whether to display the observer and illuminant values, by default True</p> bool, optional <p>Whether to save the figure, by default False</p> str, optional <p>Absolute path required to save the figure, by default 'cwd' When 'cwd', it will save the figure in the current working directory.</p>"},{"location":"references/#microfading.microfading.MFT.plot_CIELAB--returns","title":"Returns","text":"<p>png file     It returns a figure with 4 subplots that can be saved as a png file.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def plot_CIELAB(self, stds=[], dose_unit:Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', colors:Union[str,list] = None, title:Optional[str] = None, fontsize:Optional[int] = 20, legend_labels:Union[str,list] = 'default', legend_position:Optional[str] = 'in', legend_fontsize:Optional[int] = 20, legend_title:Optional[str] = None, dE:Optional[bool] = False, obs_ill:Optional[bool] = True, save:Optional[bool] = False, path_fig:Optional[str] = 'cwd', report:Optional[bool] = False):\n    \"\"\"Plot the Lab values related to input the microfading files.\n\n    Parameters\n    ----------\n    stds : list, optional\n        A list of standard variation values respective to each element given in the data parameter, by default []\n\n    dose_unit : str, optional\n        Unit of the light energy dose, by default 'He'\n        Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    dose_values : [int, float, list, tuple], optional        \n        Values of the light dose energy, by default 'all'\n        A single value (integer or float number), a list of multiple numerical values, or range values with a tuple (start, end, step) can be entered.\n        When 'all', it takes the values found in the data.   \n\n    colors : [str, list], optional\n        Define the colors of the data points, by default None\n        When 'sample', the color of each points will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) or a list of matplotlib colour values can be used.     \n\n    title : str, optional\n        Whether to add a title to the plot, by default None\n\n    fontsize : int, optional\n        Fontsize of the plot (title, ticks, and labels), by default 24\n\n    legend_labels : [str, list], optional\n        A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default'\n        When 'default', each label will composed of the Id number of the number followed by a short description\n\n    legend_position : str, optional\n        Position of the legend, by default 'in'\n        The legend can either be inside the figure ('in') or outside ('out')\n\n    legend_fontsize : int, optional\n        Fontsize of the legend, by default 24\n\n    legend_title : str, optional\n        Add a title above the legend, by default ''\n\n    dE : bool, optional\n        Whether to display the dE00 curves in the bottom left suplots instead of the CIELAB 2D space, by default False\n        NOT IMPLEMENTED YET ! LEAVE PARAMETER TO FALSE\n\n    obs_ill : bool, optional\n        Whether to display the observer and illuminant values, by default True\n\n    save : bool, optional\n        Whether to save the figure, by default False\n\n    path_fig : str, optional\n        Absolute path required to save the figure, by default 'cwd'\n        When 'cwd', it will save the figure in the current working directory.\n\n    Returns\n    -------\n    png file\n        It returns a figure with 4 subplots that can be saved as a png file.\n    \"\"\"\n\n    data_Lab = self.get_cielab(coordinates=['L*', 'a*', 'b*'], dose_unit=dose_unit, dose_values=dose_values)\n    data_Lab = [x.T.values for x in data_Lab]\n\n\n    # Retrieve the metadata\n    info = self.get_metadata()\n    ids = [x for x in self.get_meas_ids if 'BW' not in x] \n\n    if 'group_description' in info.index:                \n        group_descriptions = info.loc['group_description'].values\n\n    else:\n        group_descriptions = [''] * len(self.files)\n\n\n\n    # Define the colour of the curves\n    if colors == 'sample':\n        pass           \n\n    elif isinstance(colors, str):\n        colors = [colors] * len(self.files)\n\n    elif colors == None:\n        colors = [None] * len(self.files)\n\n    # Define the labels\n    if legend_labels == 'default':\n        legend_labels = [f'{x}-{y}' for x,y in zip(self.get_meas_ids,group_descriptions)]\n        legend_title = 'Measurement $n^o$'\n\n    # Whether to plot the observer and illuminant info\n    if obs_ill:\n        DB = databases.DB()\n        if len(DB.get_colorimetry_info()) == 0:\n            observer = '10deg'\n            illuminant = 'D65'\n        else:\n            observer = DB.get_colorimetry_info().loc['observer']['value']\n            illuminant = DB.get_colorimetry_info().loc['illuminant']['value']\n\n        dic_obs = {'10deg':'$\\mathrm{10^o}$', '2deg':'$\\mathrm{2^o}$'}            \n        obs_ill = f'{dic_obs[observer]}-{illuminant}'\n\n    else:\n        obs_ill = None\n\n    return plotting.CIELAB(data=data_Lab, legend_labels=legend_labels, colors=colors, title=title, fontsize=fontsize, legend_fontsize=legend_fontsize, legend_position=legend_position, legend_title=legend_title, dE=dE, obs_ill=obs_ill, save=save, path_fig=path_fig)\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.plot_bars","title":"<code>plot_bars(BWS_lines=True, coordinate='dE00', dose_unit='Hv', dose_value=0.5, xlabels='default', group_objects=False, fontsize=24, rotate_xlabels=0, position_xlabels='center', position_text=(0.03, 0.92), colors=None, save=False, path_fig='cwd')</code>","text":"<p>Plot a bar graph of a given colorimetric coordinate for a given light dose value.</p>"},{"location":"references/#microfading.microfading.MFT.plot_bars--parameters","title":"Parameters","text":"<p>BWS_lines : Optional[bool], optional     Whether to display the blue wool standard values as horizontal lines or as bars, by default True</p> Optional[str], optional <p>Colorimetric coordinate to be displayed, by default 'dE00' It can be any coordinates among the following list : ['L','a','b','C','h','dL','da','db','dC','dh','dE76','dE00','dR_vis'].</p> Optional[str], optional <p>Unit of the light energy dose, by default 'Hv' Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> Union[int, float], optional <p>Values of the light dose energy, by default 0.5</p> Union[str, list], optional <p>Values of the labels on the x-axis (one label per bar), by default 'default' When 'default', it takes the measurement id as label.</p> Optional[int], optional <p>Fontsize of the plot (title, ticks, and labels), by default 24</p> Optional[int], optional <p>Whether to rotate the labels on the x-axis, by default 0 It can be any integer value between 0 and 360.</p> Optional[str], optional <p>Position of the labels according to each bar ('center', 'left', 'right'), by default 'center'</p> Optional[tuple], optional <p>Position (x,y) of the text with the exposure dose value, by default (0.03,0.92)</p> Union[str,float,list], optional <p>Colors of the bar, by default None When 'sample', the color of each bar will be based on srgb values computed from the reflectance values.  A single string or float value can also be used to define the color of all the bars (see matplotlib colour values).  A list string can also be given, in that case, the number of element in the list should be equal to the number of bars. </p> bool, optional <p>Whether to save the figure, by default False</p> str, optional <p>Absolute path required to save the figure, by default 'cwd' When 'cwd', it will save the figure in the current working directory.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def plot_bars(self, BWS_lines:Optional[bool] = True, coordinate:Optional[str] = 'dE00', dose_unit:Optional[str] = 'Hv', dose_value:Union[int, float] = 0.5, xlabels:Union[str, list] = 'default', group_objects:Optional[bool] = False, fontsize:Optional[int] = 24, rotate_xlabels:Optional[int] = 0, position_xlabels:Optional[str] = 'center', position_text:Optional[tuple] = (0.03,0.92), colors:Union[str,float,list]=None, save:Optional[bool] = False, path_fig:Optional[str] = 'cwd'):\n    \"\"\"Plot a bar graph of a given colorimetric coordinate for a given light dose value.\n\n    Parameters\n    ----------\n    BWS_lines : Optional[bool], optional\n        Whether to display the blue wool standard values as horizontal lines or as bars, by default True\n\n    coordinate : Optional[str], optional\n        Colorimetric coordinate to be displayed, by default 'dE00'\n        It can be any coordinates among the following list : ['L*','a*','b*','C*','h','dL*','da*','db*','dC*','dh','dE76','dE00','dR_vis'].\n\n    dose_unit : Optional[str], optional\n        Unit of the light energy dose, by default 'Hv'\n        Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    dose_value : Union[int, float], optional\n        Values of the light dose energy, by default 0.5\n\n    xlabels : Union[str, list], optional\n        Values of the labels on the x-axis (one label per bar), by default 'default'\n        When 'default', it takes the measurement id as label.\n\n    fontsize : Optional[int], optional\n        Fontsize of the plot (title, ticks, and labels), by default 24\n\n    rotate_xlabels : Optional[int], optional\n        Whether to rotate the labels on the x-axis, by default 0\n        It can be any integer value between 0 and 360.\n\n    position_xlabels : Optional[str], optional\n        Position of the labels according to each bar ('center', 'left', 'right'), by default 'center'\n\n    position_text : Optional[tuple], optional\n        Position (x,y) of the text with the exposure dose value, by default (0.03,0.92)\n\n    colors : Union[str,float,list], optional\n        Colors of the bar, by default None\n        When 'sample', the color of each bar will be based on srgb values computed from the reflectance values. \n        A single string or float value can also be used to define the color of all the bars (see matplotlib colour values). \n        A list string can also be given, in that case, the number of element in the list should be equal to the number of bars. \n\n    save : bool, optional\n        Whether to save the figure, by default False\n\n    path_fig : str, optional\n        Absolute path required to save the figure, by default 'cwd'\n        When 'cwd', it will save the figure in the current working directory.\n    \"\"\"\n\n    # ['L*','a*','b*','C*','h','dL*','da*','db*','dC*','dh','dE76','dE00','dR_vis']\n\n    # Define the light dose value      \n    doses_dic = {'He':'He_MJ/m2', 'Hv':'Hv_Mlxh', 't':'t_sec'}\n    max_doses = [x.values[0] for x in self.get_doses(dose_unit=dose_unit, max_doses=True)]\n\n    if dose_value &gt; np.min(max_doses):\n        print(f'The choosen dose_value ({dose_value} {doses_dic[dose_unit].split(\"_\")[1]}) is bigger than one of the final dose values. Thus the dose_value has been set to {np.min(max_doses)} {doses_dic[dose_unit].split(\"_\")[1]}, which is the lowest final dose value.')\n        dose_value = np.min(max_doses)\n\n\n    # Define the labels on the x-axis\n    if xlabels == 'default':\n        xlabels = self.get_meas_ids\n\n    elif xlabels == 'meas_nb':\n        xlabels = [x.split('.')[-1] for x in self.get_meas_ids]\n\n    elif xlabels in [x for x in self.get_metadata().index if '[' not in x]:\n        xlabels = self.get_metadata(labels=xlabels).values\n\n\n    # Define the colour of the bars\n    if colors == 'sample':\n        colors = [x for x in self.get_sRGB(dose_values=0).values.reshape(len(self.files),-1)]\n\n    elif isinstance(colors, str):\n        colors = [colors] * len(self.files)\n\n    elif isinstance(colors, float):\n        colors = [str(colors)] * len(self.files)\n\n    # Define the objects ID\n    object_ids = self.get_metadata(labels='object_id').values\n\n    # Define the object name\n    object_names = self.get_metadata(labels='object_name').values\n\n    # Gather the data and relevant info inside a dataframe\n    all_data = self.get_cielab(coordinates=[coordinate], dose_unit=dose_unit, dose_values=dose_value)\n    cl_data = [x.iloc[0].values[0] for x in all_data]\n    cl_data_std = [x.iloc[0].values[1] if 'std' in x.columns.get_level_values(1) else 0 for x in all_data]\n\n    plot_data = {\n        'y': cl_data,\n        'y_std': cl_data_std, \n        'xlabels': xlabels,\n        'type': self.get_metadata(labels='object_type').values,\n        'name': object_ids,\n        'objectID':self.get_metadata(['object_id']).values[0],\n        'colors': colors\n    }\n\n    df_data = pd.DataFrame.from_dict(plot_data)        \n\n\n    # Create the plot\n    sns.set_theme(font='serif')\n    fig, ax = plt.subplots(1,1, figsize=(15,8))\n\n    if BWS_lines == True:         \n\n        df_BWS = df_data[df_data['type'] == 'BWS']\n        df_data = df_data[df_data['type'] != 'BWS']\n        object_ids = df_data['objectID'].values\n\n        ls_dic = {'BW1':'-','BW2':'--','BW3':'-.','BW4':':', 'BWS0028':'-','BWS0029':'--','BWS0030':'-.','BWS0031':':'}\n\n        for col in df_BWS.T.columns:\n            data_BWS = df_BWS.T[col]\n\n            ax.axhline(data_BWS['y'], color='blue', ls =ls_dic[data_BWS['name']], label=data_BWS['name'])\n            ax.axhspan(ymin=data_BWS['y']-data_BWS['y_std'], ymax=data_BWS['y']+data_BWS['y_std'], alpha=0.5, color='0.75', ec='none')        \n\n\n    x = np.arange(0,len(df_data))\n\n\n    if colors == None:\n        colors = None\n    else:\n        colors = df_data['colors']\n\n    if not group_objects: \n        ax.bar(x=x, height=df_data['y'], yerr=df_data['y_std'], capsize=5, color=colors, edgecolor='none')\n\n    else:\n\n        i = 1\n        x_ticks = []\n        labels = []\n\n\n        for obj in sorted(set(object_ids)):\n\n            df_obj = df_data.query(f'objectID == \"{obj}\"')\n\n\n            y_values = df_obj['y'].values\n            meas_ids = df_obj['xlabels'].values\n            srgb_values = df_obj['colors'].values\n\n            labels_obj = []\n            N = len(meas_ids)    \n            obj_tick = str(int(np.cumsum(np.arange(1,1+N))[-1] / N)).zfill(2)\n\n            for ID, value, srgb in zip(meas_ids, y_values, srgb_values):\n\n                ax.bar(i, value, width=1, color=srgb, ec=\"none\")\n\n                labels_obj.append(str(ID.split('.')[2]))\n                x_ticks.append(i)\n                i = i + 1\n\n\n            labels_obj = list(map(lambda x: x.replace((obj_tick), f'{obj_tick}\\n{obj}'), labels_obj))\n\n            labels.append(labels_obj)\n\n            ax.bar(i, 0)\n            labels.append([''])\n            i = i + 1    \n            x_ticks.append(i)\n\n        # Define the labels for x-axis ticks\n        labels = [x for xs in labels for x in xs]\n\n        # Set the x-ticks and xlabels\n        ax.set_xticks(x_ticks)\n        ax.set_xticklabels(labels)\n\n        # Display the legend\n        handles, labels = ax.get_legend_handles_labels()\n        unique = [(h, l) for i, (h, l) in enumerate(zip(handles, labels)) if l not in labels[:i]]\n        ax.legend(*zip(*unique),fontsize=fontsize-4)\n\n\n\n\n    ax.xaxis.set_tick_params(labelsize=fontsize)\n    ax.yaxis.set_tick_params(labelsize=fontsize)\n\n    ax.xaxis.grid() # horizontal lines only\n\n    ax.set_xlabel('Microfading analyses numbers', fontsize=fontsize)\n    ax.set_ylabel(labels_eq[coordinate], fontsize=fontsize)\n\n\n    #ax.set_xticks(x)\n    #ax.set_xticklabels(df_data['xlabels'], rotation=rotate_xlabels, ha=position_xlabels)\n\n    ax.text(x=position_text[0], y=position_text[1], s=f'Light dose = {dose_value} {doses_dic[dose_unit].split(\"_\")[1]}', fontsize=fontsize-6, transform=ax.transAxes, ha='left', va='top')\n\n    if BWS_lines == True:\n        ax.legend(fontsize=fontsize-4)\n\n    plt.tight_layout()\n\n    if save == True:\n        if path_fig == 'cwd':\n            path_fig = f'{os.getcwd()}/{coordinate}-bar.png'                    \n\n        fig.savefig(path_fig,dpi=300, facecolor='white') \n\n    plt.show()     \n</code></pre>"},{"location":"references/#microfading.microfading.MFT.plot_delta","title":"<code>plot_delta(stds=True, coordinates=['dE00'], dose_unit='He', legend_labels='default', initial_values=False, figsize=(15, 9), colors=None, lw='default', title=None, fontsize=24, legend_fontsize=24, legend_title=None, xlim=None, save=False, path_fig='cwd')</code>","text":"<p>Plot the delta values of choosen colorimetric coordinates related to the microfading analyses.</p>"},{"location":"references/#microfading.microfading.MFT.plot_delta--parameters","title":"Parameters","text":"<p>stds : bool, optional     Whether to show the standard deviation values if any, by default True.</p> list, optional <p>List of colorimetric coordinates, by default ['dE00'] Any of the following coordinates can be added to the list: 'dE76', 'dE00', 'dR_vis' , 'L', 'a', 'b', 'C', 'h'.</p> str, optional <p>Unit of the light energy dose, by default 'He' Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)</p> Union[str, list], optional <p>A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default' When 'default', each label will composed of the Id number of the number followed by a short description</p> Union[str, list], optional <p>Define the colors of the curves, by default None When 'sample', the color of each line will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) and will be applied to all the lines. Or a list of matplotlib colour values can be used. With a single coordinate, the list should have the same length as measurement files. With multiple coordinates, the list should have the same length as coordinates.</p> Union[int,list], optional <p>Width of the lines, by default 'default' When 'default', it attributes a given a width according to each coordinates, otherwise it gives a value of 2. A single value (an integer) can be entered and applied to all the lines. A list of integers can also be entered. With a single coordinate, the list should have the same length as measurement files. With multiple coordinates, the list should have the same length as coordinates.</p> str, optional <p>Whether to add a title to the plot, by default None</p> int, optional <p>Fontsize of the plot (title, ticks, and labels), by default 24</p> int, optional <p>Fontsize of the legend, by default 24</p> str, optional <p>Add a title above the legend, by default ''</p> tuple, optional <p>A tuple of two integers that define the left and right limits of the x-axis , by default None.</p> bool, optional <p>Whether to save the figure, by default False</p> str, optional <p>Absolute path required to save the figure, by default 'cwd' When 'cwd', it will save the figure in the current working directory.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def plot_delta(self, stds:Optional[bool] = True, coordinates:Optional[list] = ['dE00'], dose_unit:Optional[str] = 'He', legend_labels:Union[str, list] = 'default', initial_values:Optional[bool] = False, figsize:Optional[tuple] = (15,9), colors:Union[str,list] = None, lw:Union[int,list] = 'default', title:Optional[str] = None, fontsize:Optional[int] = 24, legend_fontsize:Optional[int] = 24, legend_title:Optional[str] = None, xlim:Optional[tuple] = None, save:Optional[bool] = False, path_fig:Optional[str] = 'cwd'):\n    \"\"\"Plot the delta values of choosen colorimetric coordinates related to the microfading analyses.\n\n    Parameters\n    ----------\n    stds : bool, optional\n        Whether to show the standard deviation values if any, by default True.\n\n    coordinates : list, optional\n        List of colorimetric coordinates, by default ['dE00']\n        Any of the following coordinates can be added to the list: 'dE76', 'dE00', 'dR_vis' , 'L*', 'a*', 'b*', 'C*', 'h'.\n\n    dose_unit : str, optional\n        Unit of the light energy dose, by default 'He'\n        Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec)\n\n    legend_labels : Union[str, list], optional\n        A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default'\n        When 'default', each label will composed of the Id number of the number followed by a short description\n\n    colors : Union[str, list], optional\n        Define the colors of the curves, by default None\n        When 'sample', the color of each line will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) and will be applied to all the lines. Or a list of matplotlib colour values can be used. With a single coordinate, the list should have the same length as measurement files. With multiple coordinates, the list should have the same length as coordinates.\n\n    lw : Union[int,list], optional\n        Width of the lines, by default 'default'\n        When 'default', it attributes a given a width according to each coordinates, otherwise it gives a value of 2.\n        A single value (an integer) can be entered and applied to all the lines.\n        A list of integers can also be entered. With a single coordinate, the list should have the same length as measurement files. With multiple coordinates, the list should have the same length as coordinates.\n\n    title : str, optional\n        Whether to add a title to the plot, by default None\n\n    fontsize : int, optional\n        Fontsize of the plot (title, ticks, and labels), by default 24\n\n    legend_fontsize : int, optional\n        Fontsize of the legend, by default 24\n\n    legend_title : str, optional\n        Add a title above the legend, by default ''\n\n    xlim : tuple, optional\n        A tuple of two integers that define the left and right limits of the x-axis , by default None.\n\n    save : bool, optional\n        Whether to save the figure, by default False\n\n    path_fig : str, optional\n        Absolute path required to save the figure, by default 'cwd'\n        When 'cwd', it will save the figure in the current working directory.\n    \"\"\"\n\n    # Retrieve the data\n    if xlim == None:\n        dose_values = 'all'\n    elif isinstance(xlim, tuple):\n        dose_values = (xlim[0], xlim[1], 0.05)\n\n    all_data = self.compute_delta(coordinates=coordinates, dose_unit=dose_unit, dose_values=dose_values)\n    nominal_data = []\n    stdev_data = []\n\n    for data in all_data:\n\n        if sorted(set(data.columns.get_level_values(1))) == ['mean', 'std']:\n            nominal = data.xs(key='mean', axis=1, level=1)\n            if stds:\n                stdev = data.xs(key='std', axis=1, level=1)   \n            else:\n                stdev = nominal.copy()   \n                stdev.iloc[:,:] = 0         \n\n        else:\n\n            nominal = data\n            stdev = data.copy()\n            stdev.iloc[:,:] = 0\n\n\n        nominal_data.append(nominal.reset_index().T.values)\n        stdev_data.append(stdev.T.values)\n\n\n\n    # Retrieve the metadata\n    info = self.get_metadata()\n    ids = [x for x in self.get_meas_ids]\n    meas_nbs = [x.split('.')[-1] for x in ids]\n\n    if 'spot_description' in info.index:                \n        group_descriptions = info.loc['spot_description'].values\n\n    else:\n        group_descriptions = [''] * len(self.files)\n\n\n    # Set the labels values\n    if legend_labels == 'default':                       \n        legend_labels = [f'{x}-{y}' for x,y in zip(ids, group_descriptions)] \n\n    elif legend_labels == '':\n        legend_labels = []\n\n    elif isinstance(legend_labels, list):\n        legend_labels = legend_labels\n        '''\n        labels_list = []\n        for i,Id in enumerate(self.get_meas_ids):\n            label = Id.split('.')[-1]\n            for el in labels:\n                label = label + f'-{self.get_metadata().loc[el].values[i]}'\n            labels_list.append(label)\n\n        labels = labels_list\n        '''\n\n    # Add the initial values of the colorimetric coordinates\n\n    if initial_values:  \n        initial_values = {}          \n        for coord in coordinates:\n            if coord in ['dL*', 'da*', 'db*', 'dC*', 'dh']:\n                initial_value = self.get_cielab(coordinates=[coord[1:]])[0][coord[1:]].iloc[0,:].values[0]\n                initial_values[coord[1:]] = initial_value\n    else:\n        initial_values = {}  \n\n    if len(meas_nbs) &gt; 1:\n        initial_values = {}\n\n    # Set the color of the lines according to the sample\n    if colors == 'sample':\n        colors = list(self.get_sRGB(dose_values=0).values.reshape(len(meas_nbs),-1))\n        colors = colors * len(coordinates)\n\n    # Whether to add a title or not\n    if title == 'default':\n        title = 'MFT'            \n    elif title == 'none':\n        title = None\n    else:\n        title = title \n\n    # Define the saving folder in case the figure should be saved\n    filename = ''\n    if save:\n        if path_fig == 'default':\n            path_fig = self.get_dir(folder_type='figures') / filename                \n\n        if path_fig == 'cwd':\n            path_fig = f'{os.getcwd()}/{filename}' \n\n\n    plotting.delta(data=nominal_data, yerr=stdev_data, dose_unit=[dose_unit], coordinates=coordinates, initial_values=initial_values, figsize=figsize, colors=colors, lw=lw, title=title, fontsize=fontsize, legend_labels=legend_labels, legend_fontsize=legend_fontsize, legend_title=legend_title, save=save, path_fig=path_fig)\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.plot_sp","title":"<code>plot_sp(stdev=False, spectra='i', dose_unit='He', dose_values='all', spectral_mode='R', legend_labels='default', title=None, fontsize=24, fontsize_legend=24, legend_title='', wl_range=None, colors=None, lw=2, ls='-', text_xy=(0.02, 0.03), save=False, path_fig='cwd', derivation=False, smoothing=(1, 0), report=False)</code>","text":"<p>Plot the reflectance spectra corresponding to the associated microfading analyses.</p>"},{"location":"references/#microfading.microfading.MFT.plot_sp--parameters","title":"Parameters","text":"<p>stdev : bool, optional     Whether to show the standard deviation values, by default False</p> Optional[str], optional <p>Define which spectra to display, by default 'i' 'i' for initial spectral,  'f' for final spectra, 'i+f' for initial and final spectra,  'all' for all the spectra,  'doses' for spectra at different dose values indicated by the dose_unit and dose_values parameters</p> str, optional <p>Unit of the light energy dose, by default 'He' Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec). It only works if the 'spectra' parameters has been set to 'doses'.</p> Union[int, float, list, tuple], optional <p>Values of the light dose energy, by default 'all' A single value (integer or float number), a list of multiple numerical values, or range values with a tuple (start, end, step) can be entered. When 'all', it takes the values found in the data. It only works if the 'spectra' parameters has been set to 'doses'.</p> string, optional <p>When 'R', it returns the reflectance spectra           When 'A', it returns the absorption spectra using the following equation: A = -log(R)</p> Union[str, list], optional <p>A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default' When 'default', each label will composed of the Id number of the number followed by a short description</p> str, optional <p>Whether to add a title to the plot, by default None</p> int, optional <p>Fontsize of the plot (title, ticks, and labels), by default 24</p> int, optional <p>Fontsize of the legend, by default 24</p> str, optional <p>Add a title above the legend, by default ''</p> tuple, optional <p>Define the wavelength range with a two-values tuple corresponding to the lowest and highest wavelength values, by default None</p> Union[str, list], optional <p>Define the colors of the reflectance curves, by default None When 'sample', the color of each line will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) or a list of matplotlib colour values can be used. </p> Union[int, list], optional <p>Define the width of the plot lines, by default 2 It can be a single integer value that will apply to all the curves. Or a list of integers can be used where the number of integer elements should match the number of reflectance curves.</p> Union[str, list], optional <p>Define the line style of the plot lines, by default '-' It can be a string ('-', '--', ':', '-.') that will apply to all the curves. Or a list of string can be used where the number of string elements should match the number of reflectance curves.</p> bool, optional <p>Whether to save the figure, by default False</p> str, optional <p>Absolute path required to save the figure, by default 'cwd' When 'cwd', it will save the figure in the current working directory.</p> bool, optional <p>Wether to compute and display the first derivative values of the spectra, by default False</p> bool, optional <p>Whether to smooth the reflectance curves, by default False</p> list, optional <p>Parameters related to the Savitzky-Golay filter, by default [10,1] Enter a list of two integers where the first value corresponds to the window_length and the second to the polyorder value. </p> Optional[bool], optional <p>Configure some aspects of the figure for use in a report, by default False</p>"},{"location":"references/#microfading.microfading.MFT.plot_sp--returns","title":"Returns","text":"<p>type     It returns a figure that can be save as a png file.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def plot_sp(self, stdev:Optional[bool] = False, spectra:Optional[str] = 'i', dose_unit:Optional[str] = 'He', dose_values:Union[int, float, list, tuple] = 'all', spectral_mode:Optional[str] = 'R', legend_labels:Union[str,list] = 'default', title:Optional[str] = None, fontsize:Optional[int] = 24, fontsize_legend:Optional[int] = 24, legend_title='', wl_range:Optional[tuple] = None, colors:Union[str,list] = None, lw:Union[int, list] = 2, ls:Union[str, list] = '-', text_xy:Optional[tuple] = (0.02,0.03), save=False, path_fig='cwd', derivation=False, smoothing=(1,0), report:Optional[bool] = False):\n    \"\"\"Plot the reflectance spectra corresponding to the associated microfading analyses.\n\n    Parameters\n    ----------\n    stdev : bool, optional\n        Whether to show the standard deviation values, by default False\n\n    spectra : Optional[str], optional\n        Define which spectra to display, by default 'i'\n        'i' for initial spectral, \n        'f' for final spectra,\n        'i+f' for initial and final spectra, \n        'all' for all the spectra, \n        'doses' for spectra at different dose values indicated by the dose_unit and dose_values parameters\n\n    dose_unit : str, optional\n        Unit of the light energy dose, by default 'He'\n        Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (sec). It only works if the 'spectra' parameters has been set to 'doses'.\n\n    dose_values : Union[int, float, list, tuple], optional\n        Values of the light dose energy, by default 'all'\n        A single value (integer or float number), a list of multiple numerical values, or range values with a tuple (start, end, step) can be entered.\n        When 'all', it takes the values found in the data. It only works if the 'spectra' parameters has been set to 'doses'.\n\n    spectral_mode : string, optional\n        When 'R', it returns the reflectance spectra            \n        When 'A', it returns the absorption spectra using the following equation: A = -log(R)\n\n    legend_labels : Union[str, list], optional\n        A list of labels respective to each element given in the data parameter that will be shown in the legend. When the list is empty there is no legend displayed, by default 'default'\n        When 'default', each label will composed of the Id number of the number followed by a short description\n\n    title : str, optional\n        Whether to add a title to the plot, by default None\n\n    fontsize : int, optional\n        Fontsize of the plot (title, ticks, and labels), by default 24\n\n    fontsize_legend : int, optional\n        Fontsize of the legend, by default 24\n\n    legend_title : str, optional\n        Add a title above the legend, by default ''\n\n    wl_range : tuple, optional\n        Define the wavelength range with a two-values tuple corresponding to the lowest and highest wavelength values, by default None\n\n    colors : Union[str, list], optional\n        Define the colors of the reflectance curves, by default None\n        When 'sample', the color of each line will be based on srgb values computed from the reflectance values. Alternatively, a single string value can be used to define the color (see matplotlib colour values) or a list of matplotlib colour values can be used. \n\n    lw : Union[int, list], optional\n        Define the width of the plot lines, by default 2\n        It can be a single integer value that will apply to all the curves. Or a list of integers can be used where the number of integer elements should match the number of reflectance curves.\n\n    ls : Union[str, list], optional\n        Define the line style of the plot lines, by default '-'\n        It can be a string ('-', '--', ':', '-.') that will apply to all the curves. Or a list of string can be used where the number of string elements should match the number of reflectance curves.\n\n    save : bool, optional\n        Whether to save the figure, by default False\n\n    path_fig : str, optional\n        Absolute path required to save the figure, by default 'cwd'\n        When 'cwd', it will save the figure in the current working directory.\n\n    derivation : bool, optional\n        Wether to compute and display the first derivative values of the spectra, by default False\n\n    smooth : bool, optional\n        Whether to smooth the reflectance curves, by default False\n\n    smooth_params : list, optional\n        Parameters related to the Savitzky-Golay filter, by default [10,1]\n        Enter a list of two integers where the first value corresponds to the window_length and the second to the polyorder value. \n\n    report : Optional[bool], optional\n        Configure some aspects of the figure for use in a report, by default False\n\n    Returns\n    -------\n    _type_\n        It returns a figure that can be save as a png file.\n    \"\"\"\n\n    # Apply the report characteristics\n\n    if report:\n        save = True\n        colors = 'sample'\n        spectra = 'i+f'\n        fontsize = 30\n\n    # Retrieve the metadata\n    info = self.get_metadata()\n\n    if 'spot_description' in info.index:                \n        spot_descriptions = info.loc['spot_description'].values\n\n    else:\n        spot_descriptions = [''] * len(self.files)\n\n\n    # Define the colour of the curves\n    if colors == 'sample':\n        colors = self.get_sRGB().iloc[0,:].values.clip(0,1).reshape(len(self.files),-1)\n\n    elif isinstance(colors, str):\n        colors = [colors] * len(self.files)\n\n    elif colors == None:\n        colors = [None] * len(self.files)\n\n    # Define the labels\n    if legend_labels == 'default':\n        legend_labels = [f'{x}-{y}' for x,y in zip(self.get_meas_ids,spot_descriptions)]\n        legend_title = 'Measurement $n^o$'\n\n    # Select the spectral data\n    if spectra == 'i':            \n        data_sp_all = self.get_spectra(wl_range=wl_range, smoothing=smoothing)\n        data_sp = [x[x.columns.get_level_values(0)[0]] for x in data_sp_all]            \n\n        text = 'Initial spectra'\n\n    elif spectra == 'f':\n        data_sp_all = self.get_spectra(wl_range=wl_range, smoothing=smoothing)\n        data_sp =[x[x.columns.get_level_values(0)[-1]] for x in data_sp_all] \n\n        text = 'Final spectra'\n\n    elif spectra == 'i+f':\n        data_sp_all = self.get_spectra(wl_range=wl_range, smoothing=smoothing)\n        data_sp = [x[x.columns.get_level_values(0)[[0]+[-1]]] for x in data_sp_all]            \n\n        ls = ['-', '--'] * len(data_sp)\n        lw = [3,2] * len(data_sp)\n        black_lines = ['k'] * len(data_sp)            \n        colors = list(itertools.chain.from_iterable(zip(colors, black_lines)))            \n\n\n        if legend_labels == 'default':\n            meas_labels = [f'{x}-{y}' for x,y in zip(self.get_meas_ids,spot_descriptions)]\n        else:\n            meas_labels = legend_labels\n        none_labels = [None] * len(meas_labels)\n        legend_labels = [item for pair in zip(meas_labels, none_labels) for item in pair]\n\n        text = 'Initial and final spectra (black dashed lines)'\n\n    elif spectra == 'doses':\n        data_sp = self.get_spectra(wl_range=wl_range, dose_unit=dose_unit,dose_values=dose_values, smoothing=smoothing)\n\n\n        dose_units = {'He': 'MJ/m2', 'Hv': 'Mlxh', 't': 'sec'}\n        legend_title = f'Light dose values'\n        legend_labels = [f'{str(x)} {dose_units[dose_unit]}' for x in dose_values] * len(data_sp)\n\n        text = ''\n\n        ls_list = ['-','--','-.',':','-','--','-.',':','-','--','-.',':',]\n        ls = ls_list[:len(dose_values)] * len(data_sp)        \n        srgb_i = self.get_sRGB().iloc[0,:].values.reshape(-1, 3)            \n        colors = np.repeat(srgb_i, data_sp[0].shape[1], axis=0).clip(0,1)          \n\n    else:\n        print(f'\"{spectra}\" is not an adequate value. Enter a value for the parameter \"spectra\" among the following list: \"i\", \"f\", \"i+f\", \"doses\".')\n        return           \n\n    # whether to compute the absorption spectra\n    if spectral_mode == 'abs':\n        data_sp = [np.log(x) * (-1) for x in data_sp]\n\n    # Reset the index\n    data = [x.reset_index() for x in data_sp]\n\n    # Whether to compute the first derivative\n    if derivation:\n        data = [pd.concat([x.iloc[:,0], pd.DataFrame(np.gradient(x.iloc[:,1:], axis=0))], axis=1) for x in data]\n\n    # Compile the spectra to plot inside a list\n    wanted_data = []  \n    wanted_std = []\n\n    # Set the wavelength column as index\n    data = [x.set_index(x.columns.get_level_values(0)[0]) for x in data]          \n\n    # Add the std values\n    if stdev:            \n        try:     \n\n            values_data = [x.T.iloc[::2].values for x in data]\n            values_wl = [x.index for x in data]\n            for el1, wl in zip(values_data, values_wl):\n                for el2 in el1:\n                    wanted_data.append((wl,el2))\n\n            values_std = [x.T.iloc[1::2].values for x in data]                \n            for el1 in values_std:\n                for el2 in el1:\n                    wanted_std.append(el2)\n        except IndexError:\n            wanted_std = []\n\n    else:\n        for el in data:                \n            data_values = [ (el.index,x) for x in el.T.values]\n            wanted_data = wanted_data + data_values \n        wanted_std = []\n\n\n    return plotting.spectra(data=wanted_data, stds=wanted_std, spectral_mode=spectral_mode, legend_labels=legend_labels, title=title, fontsize=fontsize, fontsize_legend=fontsize_legend, legend_title=legend_title, x_range=wl_range, colors=colors, lw=lw, ls=ls, text=text, text_xy=text_xy, save=save, path_fig=path_fig, derivation=derivation)\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.plot_swatches_circle","title":"<code>plot_swatches_circle(orientation='horizontal', light_doses=[0, 0.5, 1, 2, 5, 15], JND=[1, 2, 3, 5, 10], dose_unit='Hv', dE=True, fontsize=24, equation='power_3p', initial_params='auto', bounds=(-np.inf, np.inf), save=False, path_fig='cwd', title=None, report=False)</code>","text":"<p>Plot the microfading data with circular colored patches. </p>"},{"location":"references/#microfading.microfading.MFT.plot_swatches_circle--parameters","title":"Parameters","text":"list, optional <p>Light doses in Mlxh for which a coloured patches will be created, by default [0,0.5,1,2,5,1] There has been at least two numerical values in the list. The first value corresponds to the color background of the plot and is usually set to 0. The other values will be plotted as circular patches.</p> list, optional <p>Whether to plot circular patches of just noticeable differences, by default [1,2,3,5,10] NOT YET IMPLEMENTED</p> [str, tuple], optional <p>Unit of the light energy dose, by default 'Hv' Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (hours) (exh,50,10,365)</p> bool, optional <p>Whether to include the dE00 value between the background and each circular patche, by default True</p> int, optional <p>Fontsize of the plot (title, ticks, and labels), by default 24        </p> str, optional <p>Mathematical equation used to fit the coordinate values, by default 'c0(xc1) + c2'. Any others mathematical can be given. The following equation can also be used for fitting microfading data: '((x) / (c0 + (c1x)))'.</p> List[float], optional <p>Initial guesses of the 'c' parameters given in the equation (c0, c1, c2, etc.), by default [0.1, 0.0] In the default values, only c0 and c1 are provided ; c2 is retrieved from the initial value of each colorimetric coordinate plot.</p> bool, optional <p>Whether to save the figure, by default False</p> str, optional <p>Absolute path required to save the figure, by default 'cwd' When 'cwd', it will save the figure in the current working directory.</p> str, optional <p>Whether to add a title to the plot, by default None, by default None        </p> bool, optional <p>description, by default False</p>"},{"location":"references/#microfading.microfading.MFT.plot_swatches_circle--returns","title":"Returns","text":"<p>type description</p> Source code in <code>microfading/microfading.py</code> <pre><code>def plot_swatches_circle(self, orientation:Optional[str] = 'horizontal', light_doses:Optional[list] = [0,0.5,1,2,5,15], JND:Optional[list] = [1,2,3,5,10], dose_unit:Union[str,tuple] = 'Hv', dE:Optional[bool] = True, fontsize:Optional[int] = 24, equation:Optional[str] = 'power_3p', initial_params:Optional[List[float]] = 'auto', bounds:Optional[list] = (-np.inf, np.inf), save:Optional[bool] = False, path_fig:Optional[str] = 'cwd', title:Optional[str] = None, report:Optional[bool] = False): \n    \"\"\"Plot the microfading data with circular colored patches. \n\n    Parameters\n    ----------\n\n    light_doses : list, optional\n        Light doses in Mlxh for which a coloured patches will be created, by default [0,0.5,1,2,5,1]\n        There has been at least two numerical values in the list. The first value corresponds to the color background of the plot and is usually set to 0. The other values will be plotted as circular patches.\n\n    JND : list, optional\n        Whether to plot circular patches of just noticeable differences, by default [1,2,3,5,10]\n        NOT YET IMPLEMENTED\n\n    dose_unit : [str, tuple], optional\n        Unit of the light energy dose, by default 'Hv'\n        Any of the following units can be used: 'He', 'Hv', 't'. Where 'He' corresponds to radiant energy (MJ/m2), 'Hv' to exposure dose (Mlxh), and 't' to times (hours) (exh,50,10,365)\n\n    dE : bool, optional\n        Whether to include the dE00 value between the background and each circular patche, by default True\n\n    fontsize : int, optional\n        Fontsize of the plot (title, ticks, and labels), by default 24        \n\n    equation : str, optional\n        Mathematical equation used to fit the coordinate values, by default 'c0*(x**c1) + c2'.\n        Any others mathematical can be given. The following equation can also be used for fitting microfading data: '((x) / (c0 + (c1*x)))'.\n\n    initial_params : List[float], optional\n        Initial guesses of the 'c' parameters given in the equation (c0, c1, c2, etc.), by default [0.1, 0.0]\n        In the default values, only c0 and c1 are provided ; c2 is retrieved from the initial value of each colorimetric coordinate plot.\n\n    save : bool, optional\n        Whether to save the figure, by default False\n\n    path_fig : str, optional\n        Absolute path required to save the figure, by default 'cwd'\n        When 'cwd', it will save the figure in the current working directory.\n\n    title : str, optional\n        Whether to add a title to the plot, by default None, by default None        \n\n    report : bool, optional\n        _description_, by default False\n\n    Returns\n    -------\n    _type_\n        _description_\n    \"\"\"\n\n    # Define the title\n    if title == 'default':\n        title = list(self.get_meas_ids)\n\n\n    # Compute the extrapolated Lab values\n    list_extrapolated_Lab = []\n\n    for coord in ['L*','a*','b*']:            \n\n        fitted_coord = self.compute_fitting(coordinate=coord, plot=False, return_data=True, dose_unit=dose_unit, equation=equation,initial_params=initial_params, bounds=bounds,x_range=(light_doses[0], light_doses[-1]+1, 0.1))[1].loc[light_doses]\n\n        list_extrapolated_Lab.append(fitted_coord.T.values)\n\n\n    # Run the plotting function for each filehow to b\n    for i in range(0, len(self.files)):\n        wanted_Lab = pd.DataFrame([x[i] for x in list_extrapolated_Lab]).T.values\n\n        plotting.swatches_circle(data=[wanted_Lab], data_type='Lab', orientation=orientation, light_doses=light_doses, dose_unit=dose_unit, dE=dE, fontsize=fontsize, save=save, title=title, path_fig=path_fig)        \n</code></pre>"},{"location":"references/#microfading.microfading.MFT.plots","title":"<code>plots(plots=['CIELAB', 'SP', 'SW', 'dE', 'dLab'])</code>","text":"<p>Create plots</p>"},{"location":"references/#microfading.microfading.MFT.plots--parameters","title":"Parameters","text":"<p>plots : list, optional     description, by default ['CIELAB', 'SP', 'SW', 'dE', 'dLab']</p> Source code in <code>microfading/microfading.py</code> <pre><code>def plots(self, plots=['CIELAB', 'SP', 'SW', 'dE', 'dLab']):\n    \"\"\"Create plots\n\n    Parameters\n    ----------\n    plots : list, optional\n        _description_, by default ['CIELAB', 'SP', 'SW', 'dE', 'dLab']\n    \"\"\"\n\n    for plot in plots:\n        if plot == 'CIELAB':\n            self.plot_CIELAB(legend_labels='default', legend_fontsize=18)\n\n        elif plot == 'SP':\n            self.plot_sp(spectra='i+f')\n\n        elif plot == 'SW':\n            self.plot_swatches_circle()\n\n        elif plot == 'dE':\n            self.plot_delta()\n</code></pre>"},{"location":"references/#microfading.microfading.MFT.read_files","title":"<code>read_files(sheets=['info', 'CIELAB', 'spectra'])</code>","text":"<p>Read the data files given as argument when defining the instance of the MFT class.</p>"},{"location":"references/#microfading.microfading.MFT.read_files--parameters","title":"Parameters","text":"<p>sheets : Optional[list], optional     Name of the excel sheets to be selected, by default ['info', 'CIELAB', 'spectra']</p>"},{"location":"references/#microfading.microfading.MFT.read_files--returns","title":"Returns","text":"<p>A list of list of pandas dataframes     The content of each input data file is returned as a list pandas dataframes (3 dataframes maximum, one dataframe per sheet). Ultimately, the function returns a list of list, so that when there are several input data files, each list - related a single file - corresponds to a single element of a list.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def read_files(self, sheets:Optional[list] = ['info', 'CIELAB', 'spectra']):\n    \"\"\"Read the data files given as argument when defining the instance of the MFT class.\n\n    Parameters\n    ----------\n    sheets : Optional[list], optional\n        Name of the excel sheets to be selected, by default ['info', 'CIELAB', 'spectra']\n\n    Returns\n    -------\n    A list of list of pandas dataframes\n        The content of each input data file is returned as a list pandas dataframes (3 dataframes maximum, one dataframe per sheet). Ultimately, the function returns a list of list, so that when there are several input data files, each list - related a single file - corresponds to a single element of a list.            \n    \"\"\"\n\n    files = []        \n\n    for file in self.files:\n\n        df_info = pd.read_excel(file, sheet_name='info')\n        df_sp = pd.read_excel(file, sheet_name='spectra', header=[0,1], index_col=0)\n        df_cl = pd.read_excel(file, sheet_name='CIELAB', header=[0,1])                      \n\n\n        if sheets == ['info', 'CIELAB', 'spectra']:\n            files.append([df_info, df_cl, df_sp])\n\n        elif sheets == ['info']:\n            files.append([df_info])\n\n        elif sheets == ['CIELAB']:\n            files.append([df_cl])\n\n        elif sheets == ['spectra']:\n            files.append([df_sp])\n\n        elif sheets == ['spectra', 'CIELAB']:\n            files.append([df_sp, df_cl])\n\n        elif sheets == ['CIELAB','spectra']:\n            files.append([df_cl, df_sp])\n\n        elif sheets == ['info','CIELAB']:\n            files.append([df_info, df_cl])\n\n        elif sheets == ['info','spectra']:\n            files.append([df_info, df_sp])\n\n    return files\n</code></pre>"},{"location":"references/#microfading.microfading.get_colorimetry_info","title":"<code>get_colorimetry_info()</code>","text":"<p>Retrieve the colorimetric information (observer and illuminant) recorded in the config_info.json file of the microfading package.</p>"},{"location":"references/#microfading.microfading.get_colorimetry_info--returns","title":"Returns","text":"<p>pandas dataframe or string     It returns the information inside a dataframe if they have been recorded.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_colorimetry_info():\n    \"\"\"Retrieve the colorimetric information (observer and illuminant) recorded in the config_info.json file of the microfading package.\n\n    Returns\n    -------\n    pandas dataframe or string\n        It returns the information inside a dataframe if they have been recorded.\n    \"\"\"    \n    return config.get_colorimetry_info()\n</code></pre>"},{"location":"references/#microfading.microfading.get_config","title":"<code>get_config(key='all')</code>","text":"<p>Retrieve the content of the config_info.json file</p>"},{"location":"references/#microfading.microfading.get_config--parameters","title":"Parameters","text":"<p>key : Optional[str], optional     Give you the possibility to retrieve a specific category of information, by default 'all'     One can enter a key value among the following list: ['colorimetry', 'databases', 'devices', 'exposure', 'filters', 'functions', 'lamps', 'light_dose', 'institution', 'report_figures']</p>"},{"location":"references/#microfading.microfading.get_config--returns","title":"Returns","text":"<p>dict     It returns the information inside a dictionary.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_config(key:Optional[str] = 'all'):\n    \"\"\"Retrieve the content of the config_info.json file\n\n    Parameters\n    ----------\n    key : Optional[str], optional\n        Give you the possibility to retrieve a specific category of information, by default 'all'\n        One can enter a key value among the following list: ['colorimetry', 'databases', 'devices', 'exposure', 'filters', 'functions', 'lamps', 'light_dose', 'institution', 'report_figures']\n\n    Returns\n    -------\n    dict\n        It returns the information inside a dictionary.\n    \"\"\"\n    return config.get_config_info(key=key)\n</code></pre>"},{"location":"references/#microfading.microfading.get_config_path","title":"<code>get_config_path()</code>","text":"<p>Retrieve the absolute path of the config_info.json file.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_config_path():\n    \"\"\"Retrieve the absolute path of the config_info.json file.   \n    \"\"\"\n    return config.get_config_path()\n</code></pre>"},{"location":"references/#microfading.microfading.get_datasets","title":"<code>get_datasets(MFT='fotonowy', rawfiles=False, BWS=True, stdev=False)</code>","text":"<p>Retrieve exemples of dataset files. These files are meant to give the users the possibility to test the MFT class and its functions.  </p>"},{"location":"references/#microfading.microfading.get_datasets--parameters","title":"Parameters","text":"<p>MFT : Optional[str], optional     Microfading device that has been used to obtain the files, by default 'fotonowy'     One can choose a single option among the following choices: 'fotonowy', 'sMFT',      'fotonowy' corresponds to the microfading device of the Polish company Fotonowy     'sMFT' corresponds to stereo-MFT (see Patin et al. 2022. Journal of Cultural Heritage, 57)</p> Optional[bool], optional <p>Whether to get rawdata files, by default False The raw files were obtained from microfading analyses performed with the Fotonowy device and consist of four files per analysis.</p> Optional[bool], optional <p>Whether to include the microfading measurements on blue wool standards (BWS), by default True</p> Optional[bool], optional <p>Whether to have microfading measurements wiht standard deviation values, by default False It only works if the rawfiles parameters is set to 'False'. The rawfiles do not have standard deviation values.</p>"},{"location":"references/#microfading.microfading.get_datasets--returns","title":"Returns","text":"<p>list     It returns a list of strings, where each string corresponds the absolute path of a microfading measurement excel file. Subsequently, one can use the list as input for the MFT class.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_datasets(MFT:Optional[str] = 'fotonowy', rawfiles:Optional[bool] = False, BWS:Optional[bool] = True, stdev:Optional[bool] = False):\n    \"\"\"Retrieve exemples of dataset files. These files are meant to give the users the possibility to test the MFT class and its functions.  \n\n    Parameters\n    ----------\n    MFT : Optional[str], optional\n        Microfading device that has been used to obtain the files, by default 'fotonowy'\n        One can choose a single option among the following choices: 'fotonowy', 'sMFT', \n        'fotonowy' corresponds to the microfading device of the Polish company Fotonowy\n        'sMFT' corresponds to stereo-MFT (see Patin et al. 2022. Journal of Cultural Heritage, 57)\n\n    rawfiles : Optional[bool], optional\n        Whether to get rawdata files, by default False\n        The raw files were obtained from microfading analyses performed with the Fotonowy device and consist of four files per analysis.\n\n    BWS : Optional[bool], optional\n        Whether to include the microfading measurements on blue wool standards (BWS), by default True\n\n    stdev : Optional[bool], optional\n        Whether to have microfading measurements wiht standard deviation values, by default False\n        It only works if the rawfiles parameters is set to 'False'. The rawfiles do not have standard deviation values.\n\n    Returns\n    -------\n    list\n        It returns a list of strings, where each string corresponds the absolute path of a microfading measurement excel file. Subsequently, one can use the list as input for the MFT class. \n    \"\"\"\n\n    # Whether to select files with standard deviation values\n    if stdev:\n        if MFT == 'sMFT':\n            data_files = [\n                '2024-144_MF.BWS0024.G02_avg_BW1_model_2024-08-02_MFT1.xlsx',\n                '2024-144_MF.BWS0025.G02_avg_BW2_model_2024-08-02_MFT1.xlsx',\n                '2024-144_MF.BWS0026.G02_avg_BW3_model_2024-08-02_MFT1.xlsx',                \n            ]\n\n        elif MFT == 'fotonowy':\n            data_files = [\n                '2024-144_MF.BWS0024.G01_avg_BW1_model_2024-07-30_MFT2.xlsx',\n                '2024-144_MF.BWS0025.G01_avg_BW2_model_2024-08-02_MFT2.xlsx',\n                '2024-144_MF.BWS0026.G01_avg_BW3_model_2024-08-07_MFT2.xlsx',\n                '2024-144_MF.dayflower4.G01_avg_0h_model_2024-07-30_MFT2.xlsx',\n                '2024-144_MF.indigo3.G01_avg_0h_model_2024-08-02_MFT2.xlsx',\n            ]\n\n    else:\n        if MFT == 'sMFT':\n            data_files = [\n                '2024-144_MF.BWS0026.04_G02_BW3_model_2024-08-02_MFT1.xlsx',\n                '2024-144_MF.BWS0025.04_G02_BW2_model_2024-08-02_MFT1.xlsx',\n                '2024-144_MF.BWS0024.04_G02_BW1_model_2024-08-02_MFT1.xlsx',\n                '2024-144_MF.yellowwood.01_G01_yellow_model_2024-08-01_MFT1.xlsx',\n                '2024-144_MF.vermillon.01_G01_red_model_2024-07-31_MFT1.xlsx',\n            ]\n\n        elif MFT == 'fotonowy':\n            data_files = [\n                '2024-144_MF.BWS0024.01_G01_BW1_model_2024-07-30_MFT2.xlsx',\n                '2024-144_MF.BWS0025.01_G01_BW2_model_2024-08-02_MFT2.xlsx',\n                '2024-144_MF.BWS0026.01_G01_BW3_model_2024-08-07_MFT2.xlsx',\n                '2024-144_MF.vermillon3.01_G01_0h_sample_2024-07-31_MFT2.xlsx',\n                '2024-144_MF.yellowwood4.01_G01_0h_model_2024-08-01_MFT2.xlsx',\n            ]\n\n    # Whether to select rawfiles according to a choosen device\n    if rawfiles:\n        if MFT == 'sMFT':\n            data_files = [\n                '2024-144_BWS0024_04_G02_BW1_c01_000001.txt',\n                '2024-144_yellowwood_01_G01_yellow_c01_000001.txt',\n            ]\n\n        elif MFT == 'fotonowy':\n            data_files = [\n                '2024-8200 P-001 G01 uncleaned_01-spect_convert.txt',\n                '2024-8200 P-001 G01 uncleaned_01-spect.txt',\n                '2024-8200 P-001 G01 uncleaned_01.txt',\n                '2024-8200 P-001 G01 uncleaned_01.rfc',\n                '2024-144 BWS0024 G01 BW1_01-spect_convert.txt',\n                '2024-144 BWS0024 G01 BW1_01-spect.txt',\n                '2024-144 BWS0024 G01 BW1_01.txt',\n                '2024-144 BWS0024 G01 BW1_01.rfc',\n            ]\n\n    # Whether to include the BWS files or not\n    if BWS == False:\n        data_files = [x for x in data_files if 'BWS' not in x]\n\n\n    # Get the paths to the data files within the package\n    file_paths = []\n    for file_name in data_files:\n\n        with pkg_resources.path('microfading.datasets', file_name) as data_file:\n             file_paths.append(data_file)\n\n\n    return file_paths   \n</code></pre>"},{"location":"references/#microfading.microfading.get_devices_info","title":"<code>get_devices_info()</code>","text":"<p>Retrieve the configuration information related to the devices.</p>"},{"location":"references/#microfading.microfading.get_devices_info--returns","title":"Returns","text":"<p>pandas dataframe     It returns the list of devices inside a pandas dataframe with four columns: 'Id', 'name', 'description', 'process_function'</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_devices_info():\n    \"\"\"Retrieve the configuration information related to the devices.\n\n    Returns\n    -------\n    pandas dataframe\n        It returns the list of devices inside a pandas dataframe with four columns: 'Id', 'name', 'description', 'process_function'\n    \"\"\"    \n    return config.get_devices_info()\n</code></pre>"},{"location":"references/#microfading.microfading.get_exposure_conditions","title":"<code>get_exposure_conditions()</code>","text":"<p>Retrieve the exposure lighting conditions recorded in the config_info.json file of the microfading package.</p>"},{"location":"references/#microfading.microfading.get_exposure_conditions--returns","title":"Returns","text":"<p>pandas dataframe or string     It returns the information inside a dataframe if they have been recorded.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_exposure_conditions():\n    \"\"\"Retrieve the exposure lighting conditions recorded in the config_info.json file of the microfading package.\n\n    Returns\n    -------\n    pandas dataframe or string\n        It returns the information inside a dataframe if they have been recorded.\n    \"\"\"   \n    return config.get_exposure_conditions()\n</code></pre>"},{"location":"references/#microfading.microfading.get_institution_info","title":"<code>get_institution_info()</code>","text":"<p>Retrieve the information related to the institution that performed the microfading analysis.</p>"},{"location":"references/#microfading.microfading.get_institution_info--returns","title":"Returns","text":"<p>pandas dataframe     It returns the institution info inside a pandas dataframe.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_institution_info():\n    \"\"\"Retrieve the information related to the institution that performed the microfading analysis.\n\n    Returns\n    -------\n    pandas dataframe\n        It returns the institution info inside a pandas dataframe.\n    \"\"\"    \n    return config.get_institution_info()\n</code></pre>"},{"location":"references/#microfading.microfading.get_light_dose_info","title":"<code>get_light_dose_info()</code>","text":"<p>Retrieve the light dose info recorded in the config_info.json file of the microfading package.</p>"},{"location":"references/#microfading.microfading.get_light_dose_info--returns","title":"Returns","text":"<p>pandas dataframe or string     It returns the information inside a dataframe if they have been recorded.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def get_light_dose_info():\n    \"\"\"Retrieve the light dose info recorded in the config_info.json file of the microfading package.\n\n    Returns\n    -------\n    pandas dataframe or string\n        It returns the information inside a dataframe if they have been recorded.\n    \"\"\"       \n    return config.get_light_dose_info()\n</code></pre>"},{"location":"references/#microfading.microfading.is_DB","title":"<code>is_DB()</code>","text":"<p>Check whether the databases files were created.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def is_DB():\n    \"Check whether the databases files were created.\"\n\n    # instantiate a DB class object\n    DB = databases.DB()\n    DB_config = DB.get_db_config()['databases']\n\n    if len(DB_config) == 0:\n        print('The databases have not been configured. Please enter databases configuration info by using the function set_DB().')\n        return False\n\n    db_files = ['DB_projects.csv', 'DB_objects.csv','institutions.txt', 'persons.txt','object_types.txt', 'object_techniques.txt', 'object_supports.txt', 'object_creators.txt']\n\n    if all(list(map(os.path.isfile, [str(Path(DB.folder_db)/x) for x in db_files]))):\n        print(f'All the databases were created and can be found in the following directory: {DB.folder_db}')\n\n        return True\n\n    else:\n        print('The databases files were created, but one or several files are currently missing.')\n        print(f'The files should be located in the following directory: {DB.folder_db}')\n\n        return False\n</code></pre>"},{"location":"references/#microfading.microfading.process_rawdata","title":"<code>process_rawdata(files, device, filenaming='none', folder='.', db='default', comment='', authors='XX', white_standard='default', interpolation='default', step=0.1, observer='default', illuminant='default', background='black', delete_files=True, return_filename=True)</code>","text":"<p>Process the microfading raw files created by the software that performed the microfading analysis. </p>"},{"location":"references/#microfading.microfading.process_rawdata--parameters","title":"Parameters","text":"<p>files : list     A list of string that corresponds to the absolute path of the raw files.</p> str <p>Define the  microfading that has been used to generate the raw files ('fotonowy_default', 'sMFT_default').</p> [str | list], optional <p>Define the filename of the output excel file, by default 'none'  When 'none', it uses the filename of the raw files When 'auto', it creates a filename based on the info provided by the databases A list of parameters provided in the info sheet of the excel output can be used to create a filename   </p> str, optional <p>Folder where the final data files should be saved, by default '.'</p> bool, optional <p>Whether to make use of the databases, by default False When True, it will populate the info sheet in the interim file (the output excel file) with the data found in the databases. Make sure that the databases were created and that the information about about the project and the objects were recorded.</p> str, optional <p>Whether to include a comment in the final excel file, by default ''</p> str, optional <p>Initials of the persons that performed and processed the microfading measurements, by default 'XX' (unknown). Make sure that you registered the persons in the persons.txt file (see function 'add_new_person'). If there are several persons, use a dash to connect the initials (e.g: 'JD-MG-OL').</p> str, optional <p>Whether to perform the interpolation ('He', 'Hv', 't') or not ('none'), by default 'He' 'He' performs interpolation based on the radiant exposure (MJ/m2) 'Hv' performs interpolation based on the exposure dose (Mlxh) 't' performs interpolation based on the exposure duration (sec)</p> [float  |  int], optional <p>Interpolation step related to the scale previously mentioned ('He', 'Hv', 'time'), by default 0.1</p> str, optional <p>Reference CIE observer in degree ('10deg' or '2deg'). by default 'default'. When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10deg'. </p> (str, optional) <p>Reference CIE illuminant. It can be any value of the following list: ['A', 'B', 'C', 'D50', 'D55', 'D60', 'D65', 'D75', 'E', 'FL1', 'FL2', 'FL3', 'FL4', 'FL5', 'FL6', 'FL7', 'FL8', 'FL9', 'FL10', 'FL11', 'FL12', 'FL3.1', 'FL3.2', 'FL3.3', 'FL3.4', 'FL3.5', 'FL3.6', 'FL3.7', 'FL3.8', 'FL3.9', 'FL3.10', 'FL3.11', 'FL3.12', 'FL3.13', 'FL3.14', 'FL3.15', 'HP1', 'HP2', 'HP3', 'HP4', 'HP5', 'LED-B1', 'LED-B2', 'LED-B3', 'LED-B4', 'LED-B5', 'LED-BH1', 'LED-RGB1', 'LED-V1', 'LED-V2', 'ID65', 'ID50']. by default 'default'. When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.      </p> bool, optional <p>Whether to delete the raw files</p>"},{"location":"references/#microfading.microfading.process_rawdata--returns","title":"Returns","text":"<p>Excel file     It returns an excel file composed of three tabs (info, CIELAB, spectra).</p> Source code in <code>microfading/microfading.py</code> <pre><code>def process_rawdata(files: list, device: str, filenaming:Optional[str] = 'none', folder:Optional[str] = '.', db:Optional[bool] = 'default', comment:Optional[str] = '', authors:Optional[str] = 'XX', white_standard:Optional[str] = 'default', interpolation:Optional[str] = 'default', step:Optional[float | int] = 0.1, observer:Optional[str] = 'default', illuminant:Optional[str] = 'default', background:Optional[str] = 'black', delete_files:Optional[bool] = True, return_filename:Optional[bool] = True):\n    \"\"\"Process the microfading raw files created by the software that performed the microfading analysis. \n\n    Parameters\n    ----------\n    files : list\n        A list of string that corresponds to the absolute path of the raw files.\n\n    device : str\n        Define the  microfading that has been used to generate the raw files ('fotonowy_default', 'sMFT_default').\n\n    filenaming : [str | list], optional\n        Define the filename of the output excel file, by default 'none' \n        When 'none', it uses the filename of the raw files\n        When 'auto', it creates a filename based on the info provided by the databases\n        A list of parameters provided in the info sheet of the excel output can be used to create a filename   \n\n    folder : str, optional\n        Folder where the final data files should be saved, by default '.'\n\n    db : bool, optional\n        Whether to make use of the databases, by default False\n        When True, it will populate the info sheet in the interim file (the output excel file) with the data found in the databases.\n        Make sure that the databases were created and that the information about about the project and the objects were recorded.\n\n    comment : str, optional\n        Whether to include a comment in the final excel file, by default ''\n\n    authors : str, optional\n        Initials of the persons that performed and processed the microfading measurements, by default 'XX' (unknown).\n        Make sure that you registered the persons in the persons.txt file (see function 'add_new_person').\n        If there are several persons, use a dash to connect the initials (e.g: 'JD-MG-OL').\n\n    interpolation : str, optional\n        Whether to perform the interpolation ('He', 'Hv', 't') or not ('none'), by default 'He'\n        'He' performs interpolation based on the radiant exposure (MJ/m2)\n        'Hv' performs interpolation based on the exposure dose (Mlxh)\n        't' performs interpolation based on the exposure duration (sec)\n\n    step : [float  |  int], optional\n        Interpolation step related to the scale previously mentioned ('He', 'Hv', 'time'), by default 0.1\n\n    observer : str, optional\n        Reference CIE *observer* in degree ('10deg' or '2deg'). by default 'default'.\n        When 'default', it fetches the observer value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the observer value to '10deg'. \n\n    illuminant : (str, optional)  \n        Reference CIE *illuminant*. It can be any value of the following list: ['A', 'B', 'C', 'D50', 'D55', 'D60', 'D65', 'D75', 'E', 'FL1', 'FL2', 'FL3', 'FL4', 'FL5', 'FL6', 'FL7', 'FL8', 'FL9', 'FL10', 'FL11', 'FL12', 'FL3.1', 'FL3.2', 'FL3.3', 'FL3.4', 'FL3.5', 'FL3.6', 'FL3.7', 'FL3.8', 'FL3.9', 'FL3.10', 'FL3.11', 'FL3.12', 'FL3.13', 'FL3.14', 'FL3.15', 'HP1', 'HP2', 'HP3', 'HP4', 'HP5', 'LED-B1', 'LED-B2', 'LED-B3', 'LED-B4', 'LED-B5', 'LED-BH1', 'LED-RGB1', 'LED-V1', 'LED-V2', 'ID65', 'ID50']. by default 'default'.\n        When 'default', it fetches the illuminant value recorded in the db_config.json file of the package. If no value has been recorded, then it sets the illuminant value to 'D65'.      \n\n    delete_files : bool, optional\n        Whether to delete the raw files\n\n    Returns\n    -------\n    Excel file\n        It returns an excel file composed of three tabs (info, CIELAB, spectra).\n    \"\"\"\n\n    # Load the config_info file    \n    config_info = config.get_config_info()\n\n\n    # Set the db value\n    if db == 'default':\n        if len(config_info['databases']) == 0:\n            db = False            \n        else:\n            db = config_info['databases']['usage']\n\n\n    # Set the observer value\n    if observer == 'default':        \n        if len(config_info['colorimetry']) == 0:\n            observer = '10deg'\n        else:\n            observer = config.get_colorimetry_info().loc['observer'].values[0]\n\n\n    # Set the illuminant value\n    if illuminant == 'default':\n        if len(config_info['colorimetry']) == 0:\n            illuminant = 'D65'\n        else:\n            illuminant = config.get_colorimetry_info().loc['illuminant'].values[0]\n\n\n    # Set the interpolation value\n    if interpolation == 'default':\n        if len(config_info['light_dose']) == 0:\n            interpolation = 'He'\n        else:\n            interpolation = config.get_light_dose_info().loc['unit'].values[0].split('_')[0]\n\n\n    # Set the white reference value\n    if white_standard == 'default':\n        if len(config_info['colorimetry']) == 0:\n            white_standard = 'default'\n        else:\n            white_standard = config.get_colorimetry_info().loc['white_standard'].values[0]  \n\n\n    # Retrieve the process function\n    if device.lower() in ['fotonowy', 'smft', 'stereo']:\n        process_function = device.lower()\n\n    else:\n        process_function = config_info['devices'][device]['process_function']\n\n\n    # Run the process_rawfiles function\n    if 'fotonowy' in process_function:\n\n        return process_rawfiles.MFT_fotonowy(files=files, filenaming=filenaming, folder=folder, db=db, comment=comment, device_nb=device, authors=authors, white_standard=white_standard, interpolation=interpolation, step=step, observer=observer, illuminant=illuminant, background=background, delete_files=delete_files, return_filename=return_filename)\n</code></pre>"},{"location":"references/#microfading.microfading.reset_config","title":"<code>reset_config()</code>","text":"<p>Reset the content of config_info.json to its initial state, i.e. all empty dictionaries.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def reset_config():\n    \"\"\"Reset the content of config_info.json to its initial state, i.e. all empty dictionaries.  \n    \"\"\"\n    return config.reset_config()\n</code></pre>"},{"location":"references/#microfading.microfading.set_DB","title":"<code>set_DB(folder_path='', use=True)</code>","text":"<p>Record the databases info in the config_info.json file of the microfading package.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def set_DB(folder_path:Optional[str] = '', use:Optional[bool] = True):\n    \"\"\"Record the databases info in the config_info.json file of the microfading package.\n    \"\"\"\n    return config.set_db(folder_path=folder_path, use=use)\n</code></pre>"},{"location":"references/#microfading.microfading.set_colorimetry_info","title":"<code>set_colorimetry_info()</code>","text":"<p>Record the colorimetric information (observer, illuminant, white standard) in the config_info.json file of the microfading package.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def set_colorimetry_info():\n    \"\"\"Record the colorimetric information (observer, illuminant, white standard) in the config_info.json file of the microfading package.\n    \"\"\"\n    return config.set_colorimetry_info()\n</code></pre>"},{"location":"references/#microfading.microfading.set_devices_info","title":"<code>set_devices_info()</code>","text":"<p>Record the device info in the config_info.json file of the microfading package.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def set_devices_info():\n    \"\"\"Record the device info in the config_info.json file of the microfading package.\n    \"\"\"\n    return config.set_devices_info()\n</code></pre>"},{"location":"references/#microfading.microfading.set_exposure_conditions","title":"<code>set_exposure_conditions()</code>","text":"<p>Record the exposure lighting conditions in the config_info.json file of the microfading package.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def set_exposure_conditions():\n    \"\"\"Record the exposure lighting conditions in the config_info.json file of the microfading package.\n    \"\"\"\n    return config.set_exposure_conditions()\n</code></pre>"},{"location":"references/#microfading.microfading.set_institution_info","title":"<code>set_institution_info()</code>","text":"<p>Set the information regarding your institution. As a user of the microfading package, you can enter information regarding your professional environment. These information will be automatically added in the microfading data file and inside the reports.</p>"},{"location":"references/#microfading.microfading.set_institution_info--returns","title":"Returns","text":"<p>It returns several ipywdigets where you can enter the information regarding your professional environment.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def set_institution_info():\n    \"\"\"Set the information regarding your institution. As a user of the microfading package, you can enter information regarding your professional environment. These information will be automatically added in the microfading data file and inside the reports.\n\n    Returns\n    -------\n    It returns several ipywdigets where you can enter the information regarding your professional environment.\n    \"\"\"\n    return config.set_institution_info()\n</code></pre>"},{"location":"references/#microfading.microfading.set_light_dose","title":"<code>set_light_dose()</code>","text":"<p>Record the unit of the light dose in the config_info.json file of the microfading package.</p> Source code in <code>microfading/microfading.py</code> <pre><code>def set_light_dose():\n    \"\"\"Record the unit of the light dose in the config_info.json file of the microfading package.\n    \"\"\"    \n    return config.set_light_dose()\n</code></pre>"}]}